// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/contrib/lite/toco/toco_flags.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

/// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Supported I/O file formats. Some formats may be input-only or output-only.
public enum Toco_FileFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// GraphDef, third_party/tensorflow/core/framework/graph.proto
  case tensorflowGraphdef // = 1

  /// Tensorflow's mobile inference model.
  /// third_party/tensorflow/contrib/tflite/schema.fbs
  case tflite // = 2

  /// GraphViz
  /// Export-only.
  case graphvizDot // = 3

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .tensorflowGraphdef
    case 2: self = .tflite
    case 3: self = .graphvizDot
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .tensorflowGraphdef: return 1
    case .tflite: return 2
    case .graphvizDot: return 3
    }
  }

}

/// TocoFlags encodes extra parameters that drive tooling operations, that
/// are not normally encoded in model files and in general may not be thought
/// of as properties of models, instead describing how models are to be
/// processed in the context of the present tooling job.
///
/// Next ID to use: 21.
public struct Toco_TocoFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input file format
  public var inputFormat: Toco_FileFormat {
    get {return _storage._inputFormat ?? .unknown}
    set {_uniqueStorage()._inputFormat = newValue}
  }
  /// Returns true if `inputFormat` has been explicitly set.
  public var hasInputFormat: Bool {return _storage._inputFormat != nil}
  /// Clears the value of `inputFormat`. Subsequent reads from it will return its default value.
  public mutating func clearInputFormat() {_storage._inputFormat = nil}

  /// Output file format
  public var outputFormat: Toco_FileFormat {
    get {return _storage._outputFormat ?? .unknown}
    set {_uniqueStorage()._outputFormat = newValue}
  }
  /// Returns true if `outputFormat` has been explicitly set.
  public var hasOutputFormat: Bool {return _storage._outputFormat != nil}
  /// Clears the value of `outputFormat`. Subsequent reads from it will return its default value.
  public mutating func clearOutputFormat() {_storage._outputFormat = nil}

  /// Similar to inference_type, but allows to control specifically the
  /// quantization of input arrays, separately from other arrays.
  ///
  /// If not set, then the value of inference_type is implicitly used, i.e.
  /// by default input arrays are quantized like other arrays.
  ///
  /// Like inference_type, this only affects real-number arrays. By "real-number"
  /// we mean float arrays, and quantized arrays. This excludes plain
  /// integer arrays, strings arrays, and every other data type.
  ///
  /// The typical use for this flag is for vision models taking a bitmap
  /// as input, typically with uint8 channels, yet still requiring floating-point
  /// inference. For such image models, the uint8 input is quantized, i.e.
  /// the uint8 values are interpreted as real numbers, and the quantization
  /// parameters used for such input arrays are their mean_value, std_value
  /// parameters.
  public var inferenceInputType: Toco_IODataType {
    get {return _storage._inferenceInputType ?? .unknown}
    set {_uniqueStorage()._inferenceInputType = newValue}
  }
  /// Returns true if `inferenceInputType` has been explicitly set.
  public var hasInferenceInputType: Bool {return _storage._inferenceInputType != nil}
  /// Clears the value of `inferenceInputType`. Subsequent reads from it will return its default value.
  public mutating func clearInferenceInputType() {_storage._inferenceInputType = nil}

  /// Sets the type of real-number arrays in the output file, that is, controls
  /// the representation (quantization) of real numbers in the output file,
  /// except for input arrays, which are controlled by inference_input_type.
  ///
  /// NOTE: this flag only impacts real-number arrays. By "real-number"
  /// we mean float arrays, and quantized arrays. This excludes plain
  /// integer arrays, strings arrays, and every other data type.
  ///
  /// For real-number arrays, the impact of this flag is to allow the output
  /// file to choose a different real-numbers representation (quantization)
  /// from what the input file used. For any other types of arrays, changing
  /// the data type would not make sense.
  ///
  /// Specifically:
  ///    - If FLOAT, then real-numbers arrays will be of type float in
  ///      the output file. If they were quantized in the input file, then
  ///      they get dequantized.
  ///    - If QUANTIZED_UINT8, then real-numbers arrays will be quantized
  ///      as uint8 in the output file. If they were float in the input file,
  ///      then they get quantized.
  ///    - If not set, then all real-numbers arrays retain the same type in the
  ///      output file as they have in the input file.
  public var inferenceType: Toco_IODataType {
    get {return _storage._inferenceType ?? .unknown}
    set {_uniqueStorage()._inferenceType = newValue}
  }
  /// Returns true if `inferenceType` has been explicitly set.
  public var hasInferenceType: Bool {return _storage._inferenceType != nil}
  /// Clears the value of `inferenceType`. Subsequent reads from it will return its default value.
  public mutating func clearInferenceType() {_storage._inferenceType = nil}

  /// default_ranges_min and default_ranges_max are helpers to experiment
  /// with quantization of models. Normally, quantization requires the input
  /// model to have (min, max) range information for every activations array.
  /// This is needed in order to know how to quantize arrays and still achieve
  /// satisfactory accuracy. However, in some circumstances one would just like
  /// to estimate the performance of quantized inference, without caring about
  /// accuracy. That is what default_ranges_min and default_ranges_max are for:
  /// when specified, they will be used as default (min, max) range boundaries
  /// for all activation arrays that lack (min, max) range information, thus
  /// allowing for quantization to proceed.
  ///
  /// It should be clear from the above explanation that these parameters are
  /// for experimentation purposes only and should not be used in production:
  /// they make it easy to quantize models, but the resulting quantized model
  /// will be inaccurate.
  ///
  /// These values only apply to arrays quantized with the kUint8 data type.
  public var defaultRangesMin: Float {
    get {return _storage._defaultRangesMin ?? 0}
    set {_uniqueStorage()._defaultRangesMin = newValue}
  }
  /// Returns true if `defaultRangesMin` has been explicitly set.
  public var hasDefaultRangesMin: Bool {return _storage._defaultRangesMin != nil}
  /// Clears the value of `defaultRangesMin`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultRangesMin() {_storage._defaultRangesMin = nil}

  public var defaultRangesMax: Float {
    get {return _storage._defaultRangesMax ?? 0}
    set {_uniqueStorage()._defaultRangesMax = newValue}
  }
  /// Returns true if `defaultRangesMax` has been explicitly set.
  public var hasDefaultRangesMax: Bool {return _storage._defaultRangesMax != nil}
  /// Clears the value of `defaultRangesMax`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultRangesMax() {_storage._defaultRangesMax = nil}

  /// Equivalent versions of default_ranges_min/_max for arrays quantized with
  /// the kInt16 data type.
  public var defaultInt16RangesMin: Float {
    get {return _storage._defaultInt16RangesMin ?? 0}
    set {_uniqueStorage()._defaultInt16RangesMin = newValue}
  }
  /// Returns true if `defaultInt16RangesMin` has been explicitly set.
  public var hasDefaultInt16RangesMin: Bool {return _storage._defaultInt16RangesMin != nil}
  /// Clears the value of `defaultInt16RangesMin`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultInt16RangesMin() {_storage._defaultInt16RangesMin = nil}

  public var defaultInt16RangesMax: Float {
    get {return _storage._defaultInt16RangesMax ?? 0}
    set {_uniqueStorage()._defaultInt16RangesMax = newValue}
  }
  /// Returns true if `defaultInt16RangesMax` has been explicitly set.
  public var hasDefaultInt16RangesMax: Bool {return _storage._defaultInt16RangesMax != nil}
  /// Clears the value of `defaultInt16RangesMax`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultInt16RangesMax() {_storage._defaultInt16RangesMax = nil}

  /// Ignore and discard FakeQuant nodes. For instance, that can be used to
  /// generate plain float code without fake-quantization from a quantized
  /// graph.
  public var dropFakeQuant: Bool {
    get {return _storage._dropFakeQuant ?? false}
    set {_uniqueStorage()._dropFakeQuant = newValue}
  }
  /// Returns true if `dropFakeQuant` has been explicitly set.
  public var hasDropFakeQuant: Bool {return _storage._dropFakeQuant != nil}
  /// Clears the value of `dropFakeQuant`. Subsequent reads from it will return its default value.
  public mutating func clearDropFakeQuant() {_storage._dropFakeQuant = nil}

  /// Normally, FakeQuant nodes must be strict boundaries for graph
  /// transformations, in order to ensure that quantized inference has the
  /// exact same arithmetic behavior as quantized training --- which is the
  /// whole point of quantized training and of FakeQuant nodes in the first
  /// place. However, that entails subtle requirements on where exactly
  /// FakeQuant nodes must be placed in the graph. Some quantized graphs
  /// have FakeQuant nodes at unexpected locations, that prevent graph
  /// transformations that are necessary in order to generate inference
  /// code for these graphs. Such graphs should be fixed, but as a
  /// temporary work-around, setting this reorder_across_fake_quant flag
  /// allows toco to perform necessary graph transformations on them,
  /// at the cost of no longer faithfully matching inference and training
  /// arithmetic.
  public var reorderAcrossFakeQuant: Bool {
    get {return _storage._reorderAcrossFakeQuant ?? false}
    set {_uniqueStorage()._reorderAcrossFakeQuant = newValue}
  }
  /// Returns true if `reorderAcrossFakeQuant` has been explicitly set.
  public var hasReorderAcrossFakeQuant: Bool {return _storage._reorderAcrossFakeQuant != nil}
  /// Clears the value of `reorderAcrossFakeQuant`. Subsequent reads from it will return its default value.
  public mutating func clearReorderAcrossFakeQuant() {_storage._reorderAcrossFakeQuant = nil}

  /// If true, allow TOCO to create TF Lite Custom operators for all the
  /// unsupported Tensorflow ops.
  public var allowCustomOps: Bool {
    get {return _storage._allowCustomOps ?? false}
    set {_uniqueStorage()._allowCustomOps = newValue}
  }
  /// Returns true if `allowCustomOps` has been explicitly set.
  public var hasAllowCustomOps: Bool {return _storage._allowCustomOps != nil}
  /// Clears the value of `allowCustomOps`. Subsequent reads from it will return its default value.
  public mutating func clearAllowCustomOps() {_storage._allowCustomOps = nil}

  /// Applies only to the case when the input format is TENSORFLOW_GRAPHDEF.
  /// If true, then control dependencies will be immediately dropped during
  /// import.
  /// If not set, the default behavior is as follows:
  ///    - Default to false if the output format is TENSORFLOW_GRAPHDEF.
  ///    - Default to true in all other cases.
  public var dropControlDependency: Bool {
    get {return _storage._dropControlDependency ?? false}
    set {_uniqueStorage()._dropControlDependency = newValue}
  }
  /// Returns true if `dropControlDependency` has been explicitly set.
  public var hasDropControlDependency: Bool {return _storage._dropControlDependency != nil}
  /// Clears the value of `dropControlDependency`. Subsequent reads from it will return its default value.
  public mutating func clearDropControlDependency() {_storage._dropControlDependency = nil}

  /// Disables transformations that fuse subgraphs such as known LSTMs (not all
  /// LSTMs are identified).
  public var debugDisableRecurrentCellFusion: Bool {
    get {return _storage._debugDisableRecurrentCellFusion ?? false}
    set {_uniqueStorage()._debugDisableRecurrentCellFusion = newValue}
  }
  /// Returns true if `debugDisableRecurrentCellFusion` has been explicitly set.
  public var hasDebugDisableRecurrentCellFusion: Bool {return _storage._debugDisableRecurrentCellFusion != nil}
  /// Clears the value of `debugDisableRecurrentCellFusion`. Subsequent reads from it will return its default value.
  public mutating func clearDebugDisableRecurrentCellFusion() {_storage._debugDisableRecurrentCellFusion = nil}

  /// Uses the FakeQuantWithMinMaxArgs.num_bits attribute to adjust quantized
  /// array data types throughout the graph. The graph must be properly annotated
  /// with FakeQuant* ops on at least the edges and may contain additional ops on
  /// the interior of the graph to widen/narrow as desired.
  ///
  /// Input and output array data types may change because of this propagation
  /// and users must be sure to query the final data_type values.
  public var propagateFakeQuantNumBits: Bool {
    get {return _storage._propagateFakeQuantNumBits ?? false}
    set {_uniqueStorage()._propagateFakeQuantNumBits = newValue}
  }
  /// Returns true if `propagateFakeQuantNumBits` has been explicitly set.
  public var hasPropagateFakeQuantNumBits: Bool {return _storage._propagateFakeQuantNumBits != nil}
  /// Clears the value of `propagateFakeQuantNumBits`. Subsequent reads from it will return its default value.
  public mutating func clearPropagateFakeQuantNumBits() {_storage._propagateFakeQuantNumBits = nil}

  /// Some fast uint8 GEMM kernels require uint8 weights to avoid the value 0.
  /// This flag allows nudging them to 1 to allow proceeding, with moderate
  /// inaccuracy.
  public var allowNudgingWeightsToUseFastGemmKernel: Bool {
    get {return _storage._allowNudgingWeightsToUseFastGemmKernel ?? false}
    set {_uniqueStorage()._allowNudgingWeightsToUseFastGemmKernel = newValue}
  }
  /// Returns true if `allowNudgingWeightsToUseFastGemmKernel` has been explicitly set.
  public var hasAllowNudgingWeightsToUseFastGemmKernel: Bool {return _storage._allowNudgingWeightsToUseFastGemmKernel != nil}
  /// Clears the value of `allowNudgingWeightsToUseFastGemmKernel`. Subsequent reads from it will return its default value.
  public mutating func clearAllowNudgingWeightsToUseFastGemmKernel() {_storage._allowNudgingWeightsToUseFastGemmKernel = nil}

  /// Minimum size of constant arrays to deduplicate; arrays smaller will not be
  /// deduplicated.
  public var dedupeArrayMinSizeBytes: Int64 {
    get {return _storage._dedupeArrayMinSizeBytes ?? 64}
    set {_uniqueStorage()._dedupeArrayMinSizeBytes = newValue}
  }
  /// Returns true if `dedupeArrayMinSizeBytes` has been explicitly set.
  public var hasDedupeArrayMinSizeBytes: Bool {return _storage._dedupeArrayMinSizeBytes != nil}
  /// Clears the value of `dedupeArrayMinSizeBytes`. Subsequent reads from it will return its default value.
  public mutating func clearDedupeArrayMinSizeBytes() {_storage._dedupeArrayMinSizeBytes = nil}

  /// Split the LSTM inputs from 5 tensors to 18 tensors for TFLite.
  /// Ignored if the output format is not TFLite.
  public var splitTfliteLstmInputs: Bool {
    get {return _storage._splitTfliteLstmInputs ?? true}
    set {_uniqueStorage()._splitTfliteLstmInputs = newValue}
  }
  /// Returns true if `splitTfliteLstmInputs` has been explicitly set.
  public var hasSplitTfliteLstmInputs: Bool {return _storage._splitTfliteLstmInputs != nil}
  /// Clears the value of `splitTfliteLstmInputs`. Subsequent reads from it will return its default value.
  public mutating func clearSplitTfliteLstmInputs() {_storage._splitTfliteLstmInputs = nil}

  /// Store weights as quantized weights followed by dequantize operations.
  /// Computation is still done in float, but reduces model size (at the cost of
  /// accuracy and latency).
  public var quantizeWeights: Bool {
    get {return _storage._quantizeWeights ?? false}
    set {_uniqueStorage()._quantizeWeights = newValue}
  }
  /// Returns true if `quantizeWeights` has been explicitly set.
  public var hasQuantizeWeights: Bool {return _storage._quantizeWeights != nil}
  /// Clears the value of `quantizeWeights`. Subsequent reads from it will return its default value.
  public mutating func clearQuantizeWeights() {_storage._quantizeWeights = nil}

  /// Full filepath of folder to dump the graphs at various stages of processing
  /// GraphViz .dot files. Preferred over --output_format=GRAPHVIZ_DOT in order
  /// to keep the requirements of the output file.
  public var dumpGraphvizDir: String {
    get {return _storage._dumpGraphvizDir ?? String()}
    set {_uniqueStorage()._dumpGraphvizDir = newValue}
  }
  /// Returns true if `dumpGraphvizDir` has been explicitly set.
  public var hasDumpGraphvizDir: Bool {return _storage._dumpGraphvizDir != nil}
  /// Clears the value of `dumpGraphvizDir`. Subsequent reads from it will return its default value.
  public mutating func clearDumpGraphvizDir() {_storage._dumpGraphvizDir = nil}

  /// Boolean indicating whether to dump the graph after every graph
  /// transformation.
  public var dumpGraphvizIncludeVideo: Bool {
    get {return _storage._dumpGraphvizIncludeVideo ?? false}
    set {_uniqueStorage()._dumpGraphvizIncludeVideo = newValue}
  }
  /// Returns true if `dumpGraphvizIncludeVideo` has been explicitly set.
  public var hasDumpGraphvizIncludeVideo: Bool {return _storage._dumpGraphvizIncludeVideo != nil}
  /// Clears the value of `dumpGraphvizIncludeVideo`. Subsequent reads from it will return its default value.
  public mutating func clearDumpGraphvizIncludeVideo() {_storage._dumpGraphvizIncludeVideo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "toco"

extension Toco_FileFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILE_FORMAT_UNKNOWN"),
    1: .same(proto: "TENSORFLOW_GRAPHDEF"),
    2: .same(proto: "TFLITE"),
    3: .same(proto: "GRAPHVIZ_DOT"),
  ]
}

extension Toco_TocoFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TocoFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_format"),
    2: .standard(proto: "output_format"),
    11: .standard(proto: "inference_input_type"),
    4: .standard(proto: "inference_type"),
    5: .standard(proto: "default_ranges_min"),
    6: .standard(proto: "default_ranges_max"),
    15: .standard(proto: "default_int16_ranges_min"),
    16: .standard(proto: "default_int16_ranges_max"),
    7: .standard(proto: "drop_fake_quant"),
    8: .standard(proto: "reorder_across_fake_quant"),
    10: .standard(proto: "allow_custom_ops"),
    12: .standard(proto: "drop_control_dependency"),
    13: .standard(proto: "debug_disable_recurrent_cell_fusion"),
    14: .standard(proto: "propagate_fake_quant_num_bits"),
    17: .standard(proto: "allow_nudging_weights_to_use_fast_gemm_kernel"),
    18: .standard(proto: "dedupe_array_min_size_bytes"),
    19: .standard(proto: "split_tflite_lstm_inputs"),
    20: .standard(proto: "quantize_weights"),
    24: .standard(proto: "dump_graphviz_dir"),
    25: .standard(proto: "dump_graphviz_include_video"),
  ]

  fileprivate class _StorageClass {
    var _inputFormat: Toco_FileFormat? = nil
    var _outputFormat: Toco_FileFormat? = nil
    var _inferenceInputType: Toco_IODataType? = nil
    var _inferenceType: Toco_IODataType? = nil
    var _defaultRangesMin: Float? = nil
    var _defaultRangesMax: Float? = nil
    var _defaultInt16RangesMin: Float? = nil
    var _defaultInt16RangesMax: Float? = nil
    var _dropFakeQuant: Bool? = nil
    var _reorderAcrossFakeQuant: Bool? = nil
    var _allowCustomOps: Bool? = nil
    var _dropControlDependency: Bool? = nil
    var _debugDisableRecurrentCellFusion: Bool? = nil
    var _propagateFakeQuantNumBits: Bool? = nil
    var _allowNudgingWeightsToUseFastGemmKernel: Bool? = nil
    var _dedupeArrayMinSizeBytes: Int64? = nil
    var _splitTfliteLstmInputs: Bool? = nil
    var _quantizeWeights: Bool? = nil
    var _dumpGraphvizDir: String? = nil
    var _dumpGraphvizIncludeVideo: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputFormat = source._inputFormat
      _outputFormat = source._outputFormat
      _inferenceInputType = source._inferenceInputType
      _inferenceType = source._inferenceType
      _defaultRangesMin = source._defaultRangesMin
      _defaultRangesMax = source._defaultRangesMax
      _defaultInt16RangesMin = source._defaultInt16RangesMin
      _defaultInt16RangesMax = source._defaultInt16RangesMax
      _dropFakeQuant = source._dropFakeQuant
      _reorderAcrossFakeQuant = source._reorderAcrossFakeQuant
      _allowCustomOps = source._allowCustomOps
      _dropControlDependency = source._dropControlDependency
      _debugDisableRecurrentCellFusion = source._debugDisableRecurrentCellFusion
      _propagateFakeQuantNumBits = source._propagateFakeQuantNumBits
      _allowNudgingWeightsToUseFastGemmKernel = source._allowNudgingWeightsToUseFastGemmKernel
      _dedupeArrayMinSizeBytes = source._dedupeArrayMinSizeBytes
      _splitTfliteLstmInputs = source._splitTfliteLstmInputs
      _quantizeWeights = source._quantizeWeights
      _dumpGraphvizDir = source._dumpGraphvizDir
      _dumpGraphvizIncludeVideo = source._dumpGraphvizIncludeVideo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._inputFormat)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._outputFormat)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._inferenceType)
        case 5: try decoder.decodeSingularFloatField(value: &_storage._defaultRangesMin)
        case 6: try decoder.decodeSingularFloatField(value: &_storage._defaultRangesMax)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._dropFakeQuant)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._reorderAcrossFakeQuant)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._allowCustomOps)
        case 11: try decoder.decodeSingularEnumField(value: &_storage._inferenceInputType)
        case 12: try decoder.decodeSingularBoolField(value: &_storage._dropControlDependency)
        case 13: try decoder.decodeSingularBoolField(value: &_storage._debugDisableRecurrentCellFusion)
        case 14: try decoder.decodeSingularBoolField(value: &_storage._propagateFakeQuantNumBits)
        case 15: try decoder.decodeSingularFloatField(value: &_storage._defaultInt16RangesMin)
        case 16: try decoder.decodeSingularFloatField(value: &_storage._defaultInt16RangesMax)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._allowNudgingWeightsToUseFastGemmKernel)
        case 18: try decoder.decodeSingularInt64Field(value: &_storage._dedupeArrayMinSizeBytes)
        case 19: try decoder.decodeSingularBoolField(value: &_storage._splitTfliteLstmInputs)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._quantizeWeights)
        case 24: try decoder.decodeSingularStringField(value: &_storage._dumpGraphvizDir)
        case 25: try decoder.decodeSingularBoolField(value: &_storage._dumpGraphvizIncludeVideo)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._inputFormat {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }
      if let v = _storage._outputFormat {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._inferenceType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }
      if let v = _storage._defaultRangesMin {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
      }
      if let v = _storage._defaultRangesMax {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      }
      if let v = _storage._dropFakeQuant {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
      if let v = _storage._reorderAcrossFakeQuant {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
      if let v = _storage._allowCustomOps {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
      if let v = _storage._inferenceInputType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      }
      if let v = _storage._dropControlDependency {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      }
      if let v = _storage._debugDisableRecurrentCellFusion {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }
      if let v = _storage._propagateFakeQuantNumBits {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      }
      if let v = _storage._defaultInt16RangesMin {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 15)
      }
      if let v = _storage._defaultInt16RangesMax {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 16)
      }
      if let v = _storage._allowNudgingWeightsToUseFastGemmKernel {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._dedupeArrayMinSizeBytes {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._splitTfliteLstmInputs {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      }
      if let v = _storage._quantizeWeights {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      }
      if let v = _storage._dumpGraphvizDir {
        try visitor.visitSingularStringField(value: v, fieldNumber: 24)
      }
      if let v = _storage._dumpGraphvizIncludeVideo {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_TocoFlags) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputFormat != other_storage._inputFormat {return false}
        if _storage._outputFormat != other_storage._outputFormat {return false}
        if _storage._inferenceInputType != other_storage._inferenceInputType {return false}
        if _storage._inferenceType != other_storage._inferenceType {return false}
        if _storage._defaultRangesMin != other_storage._defaultRangesMin {return false}
        if _storage._defaultRangesMax != other_storage._defaultRangesMax {return false}
        if _storage._defaultInt16RangesMin != other_storage._defaultInt16RangesMin {return false}
        if _storage._defaultInt16RangesMax != other_storage._defaultInt16RangesMax {return false}
        if _storage._dropFakeQuant != other_storage._dropFakeQuant {return false}
        if _storage._reorderAcrossFakeQuant != other_storage._reorderAcrossFakeQuant {return false}
        if _storage._allowCustomOps != other_storage._allowCustomOps {return false}
        if _storage._dropControlDependency != other_storage._dropControlDependency {return false}
        if _storage._debugDisableRecurrentCellFusion != other_storage._debugDisableRecurrentCellFusion {return false}
        if _storage._propagateFakeQuantNumBits != other_storage._propagateFakeQuantNumBits {return false}
        if _storage._allowNudgingWeightsToUseFastGemmKernel != other_storage._allowNudgingWeightsToUseFastGemmKernel {return false}
        if _storage._dedupeArrayMinSizeBytes != other_storage._dedupeArrayMinSizeBytes {return false}
        if _storage._splitTfliteLstmInputs != other_storage._splitTfliteLstmInputs {return false}
        if _storage._quantizeWeights != other_storage._quantizeWeights {return false}
        if _storage._dumpGraphvizDir != other_storage._dumpGraphvizDir {return false}
        if _storage._dumpGraphvizIncludeVideo != other_storage._dumpGraphvizIncludeVideo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
