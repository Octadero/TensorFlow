// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/contrib/lite/toco/model_flags.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

/// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///     http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Toco_InputArrayShape {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dims: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Next ID to USE: 7.
public struct Toco_InputArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the input arrays, i.e. the arrays from which input activations
  /// will be read.
  public var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_storage._name = nil}

  /// Shape of the input.  For many applications the dimensions are {batch,
  /// height, width, depth}.  Often the batch is left "unspecified" by providing
  /// a value of -1.
  ///
  /// The last dimension is typically called 'depth' or 'channels'. For example,
  /// for an image model taking RGB images as input, this would have the value 3.
  public var shape: Toco_InputArrayShape {
    get {return _storage._shape ?? Toco_InputArrayShape()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_storage._shape = nil}

  /// mean_value and std_value parameters control the interpretation of raw input
  /// activation values (elements of the input array) as real numbers. The
  /// mapping is given by:
  ///
  ///    real_value = (raw_input_value - mean_value) / std_value
  ///
  /// In particular, the defaults (mean_value=0, std_value=1) yield
  /// real_value = raw_input_value. Often, non-default values are used in image
  /// models. For example, an image model taking uint8 image channel values as
  /// its raw inputs, in [0, 255] range, may use mean_value=128, std_value=128 to
  /// map them into the interval [-1, 1).
  ///
  /// Note: this matches exactly the meaning of mean_value and std_value in
  /// (TensorFlow via LegacyFedInput).
  public var meanValue: Float {
    get {return _storage._meanValue ?? 0}
    set {_uniqueStorage()._meanValue = newValue}
  }
  /// Returns true if `meanValue` has been explicitly set.
  public var hasMeanValue: Bool {return _storage._meanValue != nil}
  /// Clears the value of `meanValue`. Subsequent reads from it will return its default value.
  public mutating func clearMeanValue() {_storage._meanValue = nil}

  public var stdValue: Float {
    get {return _storage._stdValue ?? 1}
    set {_uniqueStorage()._stdValue = newValue}
  }
  /// Returns true if `stdValue` has been explicitly set.
  public var hasStdValue: Bool {return _storage._stdValue != nil}
  /// Clears the value of `stdValue`. Subsequent reads from it will return its default value.
  public mutating func clearStdValue() {_storage._stdValue = nil}

  /// Data type of the input.
  ///
  /// In many graphs, the input arrays already have defined data types,
  /// e.g. Placeholder nodes in a TensorFlow GraphDef have a dtype attribute.
  /// In those cases, it is not needed to specify this data_type flag.
  /// The purpose of this flag is only to define the data type of input
  /// arrays whose type isn't defined in the input graph file. For example,
  /// when specifying an arbitrary (not Placeholder) --input_array into
  /// a TensorFlow GraphDef.
  ///
  /// When this data_type is quantized (e.g. QUANTIZED_UINT8), the
  /// corresponding quantization parameters are the mean_value, std_value
  /// fields.
  ///
  /// It is also important to understand the nuance between this data_type
  /// flag and the inference_input_type in TocoFlags. The basic difference
  /// is that this data_type (like all ModelFlags) describes a property
  /// of the input graph, while inference_input_type (like all TocoFlags)
  /// describes an aspect of the toco transformation process and thus of
  /// the output file. The types of input arrays may be different between
  /// the input and output files if quantization or dequantization occurred.
  /// Such differences can only occur for real-number data i.e. only
  /// between FLOAT and quantized types (e.g. QUANTIZED_UINT8).
  public var dataType: Toco_IODataType {
    get {return _storage._dataType ?? .unknown}
    set {_uniqueStorage()._dataType = newValue}
  }
  /// Returns true if `dataType` has been explicitly set.
  public var hasDataType: Bool {return _storage._dataType != nil}
  /// Clears the value of `dataType`. Subsequent reads from it will return its default value.
  public mutating func clearDataType() {_storage._dataType = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Toco_RnnState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stateArray: String {
    get {return _stateArray ?? String()}
    set {_stateArray = newValue}
  }
  /// Returns true if `stateArray` has been explicitly set.
  public var hasStateArray: Bool {return self._stateArray != nil}
  /// Clears the value of `stateArray`. Subsequent reads from it will return its default value.
  public mutating func clearStateArray() {self._stateArray = nil}

  public var backEdgeSourceArray: String {
    get {return _backEdgeSourceArray ?? String()}
    set {_backEdgeSourceArray = newValue}
  }
  /// Returns true if `backEdgeSourceArray` has been explicitly set.
  public var hasBackEdgeSourceArray: Bool {return self._backEdgeSourceArray != nil}
  /// Clears the value of `backEdgeSourceArray`. Subsequent reads from it will return its default value.
  public mutating func clearBackEdgeSourceArray() {self._backEdgeSourceArray = nil}

  public var discardable: Bool {
    get {return _discardable ?? false}
    set {_discardable = newValue}
  }
  /// Returns true if `discardable` has been explicitly set.
  public var hasDiscardable: Bool {return self._discardable != nil}
  /// Clears the value of `discardable`. Subsequent reads from it will return its default value.
  public mutating func clearDiscardable() {self._discardable = nil}

  /// size allows to specify a 1-D shape for the RNN state array.
  /// Will be expanded with 1's to fit the model.
  /// TODO(benoitjacob): should allow a generic, explicit shape.
  public var size: Int32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  public var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  public mutating func clearSize() {self._size = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stateArray: String? = nil
  fileprivate var _backEdgeSourceArray: String? = nil
  fileprivate var _discardable: Bool? = nil
  fileprivate var _size: Int32? = nil
}

/// An ArraysExtraInfo message stores a collection of additional Information
/// about arrays in a model, complementing the information in the model itself.
/// It is intentionally a separate message so that it may be serialized and
/// passed separately from the model. See --arrays_extra_info_file.
///
/// A typical use case is to manually specify MinMax for specific arrays in a
/// model that does not already contain such MinMax information.
public struct Toco_ArraysExtraInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var entries: [Toco_ArraysExtraInfo.Entry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Next ID to use: 8.
    public var name: String {
      get {return _storage._name ?? String()}
      set {_uniqueStorage()._name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool {return _storage._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() {_storage._name = nil}

    public var nameRegexp: String {
      get {return _storage._nameRegexp ?? String()}
      set {_uniqueStorage()._nameRegexp = newValue}
    }
    /// Returns true if `nameRegexp` has been explicitly set.
    public var hasNameRegexp: Bool {return _storage._nameRegexp != nil}
    /// Clears the value of `nameRegexp`. Subsequent reads from it will return its default value.
    public mutating func clearNameRegexp() {_storage._nameRegexp = nil}

    public var min: Double {
      get {return _storage._min ?? 0}
      set {_uniqueStorage()._min = newValue}
    }
    /// Returns true if `min` has been explicitly set.
    public var hasMin: Bool {return _storage._min != nil}
    /// Clears the value of `min`. Subsequent reads from it will return its default value.
    public mutating func clearMin() {_storage._min = nil}

    public var max: Double {
      get {return _storage._max ?? 0}
      set {_uniqueStorage()._max = newValue}
    }
    /// Returns true if `max` has been explicitly set.
    public var hasMax: Bool {return _storage._max != nil}
    /// Clears the value of `max`. Subsequent reads from it will return its default value.
    public mutating func clearMax() {_storage._max = nil}

    public var dataType: Toco_IODataType {
      get {return _storage._dataType ?? .unknown}
      set {_uniqueStorage()._dataType = newValue}
    }
    /// Returns true if `dataType` has been explicitly set.
    public var hasDataType: Bool {return _storage._dataType != nil}
    /// Clears the value of `dataType`. Subsequent reads from it will return its default value.
    public mutating func clearDataType() {_storage._dataType = nil}

    public var shape: Toco_InputArrayShape {
      get {return _storage._shape ?? Toco_InputArrayShape()}
      set {_uniqueStorage()._shape = newValue}
    }
    /// Returns true if `shape` has been explicitly set.
    public var hasShape: Bool {return _storage._shape != nil}
    /// Clears the value of `shape`. Subsequent reads from it will return its default value.
    public mutating func clearShape() {_storage._shape = nil}

    public var constantFloatValue: Float {
      get {return _storage._constantFloatValue ?? 0}
      set {_uniqueStorage()._constantFloatValue = newValue}
    }
    /// Returns true if `constantFloatValue` has been explicitly set.
    public var hasConstantFloatValue: Bool {return _storage._constantFloatValue != nil}
    /// Clears the value of `constantFloatValue`. Subsequent reads from it will return its default value.
    public mutating func clearConstantFloatValue() {_storage._constantFloatValue = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// ModelFlags encodes properties of a model that, depending on the file
/// format, may or may not be recorded in the model file. The purpose of
/// representing these properties in ModelFlags is to allow passing them
/// separately from the input model file, for instance as command-line
/// parameters, so that we can offer a single uniform interface that can
/// handle files from different input formats.
///
/// For each of these properties, and each supported file format, we
/// detail in comments below whether the property exists in the given file
/// format.
///
/// Obsolete flags that have been removed:
///   optional int32 input_depth = 3;
///   optional int32 input_width = 4;
///   optional int32 input_height = 5;
///   optional int32 batch = 6 [ default = 1];
///   optional float mean_value = 7;
///   optional float std_value = 8 [default = 1.];
///   optional int32 input_dims = 11 [ default = 4];
///   repeated int32 input_shape = 13;
///
/// Next ID to USE: 20.
public struct Toco_ModelFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information about the input arrays, i.e. the arrays from which input
  /// activations will be read.
  public var inputArrays: [Toco_InputArray] {
    get {return _storage._inputArrays}
    set {_uniqueStorage()._inputArrays = newValue}
  }

  /// Name of the output arrays, i.e. the arrays into which output activations
  /// will be written.
  public var outputArrays: [String] {
    get {return _storage._outputArrays}
    set {_uniqueStorage()._outputArrays = newValue}
  }

  /// If true, the model accepts an arbitrary batch size. Mutually exclusive with
  /// the 'batch' field: at most one of these two fields can be set.
  public var variableBatch: Bool {
    get {return _storage._variableBatch ?? false}
    set {_uniqueStorage()._variableBatch = newValue}
  }
  /// Returns true if `variableBatch` has been explicitly set.
  public var hasVariableBatch: Bool {return _storage._variableBatch != nil}
  /// Clears the value of `variableBatch`. Subsequent reads from it will return its default value.
  public mutating func clearVariableBatch() {_storage._variableBatch = nil}

  public var rnnStates: [Toco_RnnState] {
    get {return _storage._rnnStates}
    set {_uniqueStorage()._rnnStates = newValue}
  }

  public var modelChecks: [Toco_ModelFlags.ModelCheck] {
    get {return _storage._modelChecks}
    set {_uniqueStorage()._modelChecks = newValue}
  }

  /// If true, will allow passing inexistent arrays in --input_arrays
  /// and --output_arrays. This makes little sense, is only useful to
  /// more easily get graph visualizations.
  public var allowNonexistentArrays: Bool {
    get {return _storage._allowNonexistentArrays ?? false}
    set {_uniqueStorage()._allowNonexistentArrays = newValue}
  }
  /// Returns true if `allowNonexistentArrays` has been explicitly set.
  public var hasAllowNonexistentArrays: Bool {return _storage._allowNonexistentArrays != nil}
  /// Clears the value of `allowNonexistentArrays`. Subsequent reads from it will return its default value.
  public mutating func clearAllowNonexistentArrays() {_storage._allowNonexistentArrays = nil}

  /// If true, will allow passing non-ascii-printable characters in
  /// --input_arrays and --output_arrays. By default (if false), only
  /// ascii printable characters are allowed, i.e. character codes
  /// ranging from 32 to 127. This is disallowed by default so as to
  /// catch common copy-and-paste issues where invisible unicode
  /// characters are unwittingly added to these strings.
  public var allowNonasciiArrays: Bool {
    get {return _storage._allowNonasciiArrays ?? false}
    set {_uniqueStorage()._allowNonasciiArrays = newValue}
  }
  /// Returns true if `allowNonasciiArrays` has been explicitly set.
  public var hasAllowNonasciiArrays: Bool {return _storage._allowNonasciiArrays != nil}
  /// Clears the value of `allowNonasciiArrays`. Subsequent reads from it will return its default value.
  public mutating func clearAllowNonasciiArrays() {_storage._allowNonasciiArrays = nil}

  /// If set, this ArraysExtraInfo allows to pass extra information about arrays
  /// not specified in the input model file, such as extra MinMax information.
  public var arraysExtraInfo: Toco_ArraysExtraInfo {
    get {return _storage._arraysExtraInfo ?? Toco_ArraysExtraInfo()}
    set {_uniqueStorage()._arraysExtraInfo = newValue}
  }
  /// Returns true if `arraysExtraInfo` has been explicitly set.
  public var hasArraysExtraInfo: Bool {return _storage._arraysExtraInfo != nil}
  /// Clears the value of `arraysExtraInfo`. Subsequent reads from it will return its default value.
  public mutating func clearArraysExtraInfo() {_storage._arraysExtraInfo = nil}

  /// When set to false, toco will not change the input ranges and the output
  /// ranges of concat operator to the overlap of all input ranges.
  public var changeConcatInputRanges: Bool {
    get {return _storage._changeConcatInputRanges ?? true}
    set {_uniqueStorage()._changeConcatInputRanges = newValue}
  }
  /// Returns true if `changeConcatInputRanges` has been explicitly set.
  public var hasChangeConcatInputRanges: Bool {return _storage._changeConcatInputRanges != nil}
  /// Clears the value of `changeConcatInputRanges`. Subsequent reads from it will return its default value.
  public mutating func clearChangeConcatInputRanges() {_storage._changeConcatInputRanges = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Checks applied to the model, typically after toco's comprehensive
  /// graph transformations.
  /// Next ID to USE: 4.
  public struct ModelCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Use the name of a type of operator to check its counts.
    /// Use "Total" for overall operator counts.
    /// Use "Arrays" for overall array counts.
    public var countType: String {
      get {return _countType ?? "None"}
      set {_countType = newValue}
    }
    /// Returns true if `countType` has been explicitly set.
    public var hasCountType: Bool {return self._countType != nil}
    /// Clears the value of `countType`. Subsequent reads from it will return its default value.
    public mutating func clearCountType() {self._countType = nil}

    /// A count of zero is a meaningful check, so negative used to mean disable.
    public var countMin: Int32 {
      get {return _countMin ?? -1}
      set {_countMin = newValue}
    }
    /// Returns true if `countMin` has been explicitly set.
    public var hasCountMin: Bool {return self._countMin != nil}
    /// Clears the value of `countMin`. Subsequent reads from it will return its default value.
    public mutating func clearCountMin() {self._countMin = nil}

    /// If count_max < count_min, then count_min is only allowed value.
    public var countMax: Int32 {
      get {return _countMax ?? -1}
      set {_countMax = newValue}
    }
    /// Returns true if `countMax` has been explicitly set.
    public var hasCountMax: Bool {return self._countMax != nil}
    /// Clears the value of `countMax`. Subsequent reads from it will return its default value.
    public mutating func clearCountMax() {self._countMax = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _countType: String? = nil
    fileprivate var _countMin: Int32? = nil
    fileprivate var _countMax: Int32? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "toco"

extension Toco_InputArrayShape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputArrayShape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "dims"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeRepeatedInt32Field(value: &self.dims)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dims.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.dims, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_InputArrayShape) -> Bool {
    if self.dims != other.dims {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Toco_InputArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    6: .same(proto: "shape"),
    3: .standard(proto: "mean_value"),
    4: .standard(proto: "std_value"),
    5: .standard(proto: "data_type"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _shape: Toco_InputArrayShape? = nil
    var _meanValue: Float? = nil
    var _stdValue: Float? = nil
    var _dataType: Toco_IODataType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _shape = source._shape
      _meanValue = source._meanValue
      _stdValue = source._stdValue
      _dataType = source._dataType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 3: try decoder.decodeSingularFloatField(value: &_storage._meanValue)
        case 4: try decoder.decodeSingularFloatField(value: &_storage._stdValue)
        case 5: try decoder.decodeSingularEnumField(value: &_storage._dataType)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._shape)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._meanValue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
      }
      if let v = _storage._stdValue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
      }
      if let v = _storage._dataType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      }
      if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_InputArray) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._shape != other_storage._shape {return false}
        if _storage._meanValue != other_storage._meanValue {return false}
        if _storage._stdValue != other_storage._stdValue {return false}
        if _storage._dataType != other_storage._dataType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Toco_RnnState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RnnState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "state_array"),
    2: .standard(proto: "back_edge_source_array"),
    5: .same(proto: "discardable"),
    3: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._stateArray)
      case 2: try decoder.decodeSingularStringField(value: &self._backEdgeSourceArray)
      case 3: try decoder.decodeSingularInt32Field(value: &self._size)
      case 5: try decoder.decodeSingularBoolField(value: &self._discardable)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stateArray {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._backEdgeSourceArray {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._size {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._discardable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_RnnState) -> Bool {
    if self._stateArray != other._stateArray {return false}
    if self._backEdgeSourceArray != other._backEdgeSourceArray {return false}
    if self._discardable != other._discardable {return false}
    if self._size != other._size {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Toco_ArraysExtraInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArraysExtraInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.entries)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_ArraysExtraInfo) -> Bool {
    if self.entries != other.entries {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Toco_ArraysExtraInfo.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Toco_ArraysExtraInfo.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    7: .standard(proto: "name_regexp"),
    2: .same(proto: "min"),
    3: .same(proto: "max"),
    4: .standard(proto: "data_type"),
    5: .same(proto: "shape"),
    6: .standard(proto: "constant_float_value"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _nameRegexp: String? = nil
    var _min: Double? = nil
    var _max: Double? = nil
    var _dataType: Toco_IODataType? = nil
    var _shape: Toco_InputArrayShape? = nil
    var _constantFloatValue: Float? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _nameRegexp = source._nameRegexp
      _min = source._min
      _max = source._max
      _dataType = source._dataType
      _shape = source._shape
      _constantFloatValue = source._constantFloatValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularDoubleField(value: &_storage._min)
        case 3: try decoder.decodeSingularDoubleField(value: &_storage._max)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._dataType)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._shape)
        case 6: try decoder.decodeSingularFloatField(value: &_storage._constantFloatValue)
        case 7: try decoder.decodeSingularStringField(value: &_storage._nameRegexp)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._min {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
      }
      if let v = _storage._max {
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
      }
      if let v = _storage._dataType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }
      if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._constantFloatValue {
        try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
      }
      if let v = _storage._nameRegexp {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_ArraysExtraInfo.Entry) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._nameRegexp != other_storage._nameRegexp {return false}
        if _storage._min != other_storage._min {return false}
        if _storage._max != other_storage._max {return false}
        if _storage._dataType != other_storage._dataType {return false}
        if _storage._shape != other_storage._shape {return false}
        if _storage._constantFloatValue != other_storage._constantFloatValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Toco_ModelFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_arrays"),
    2: .standard(proto: "output_arrays"),
    10: .standard(proto: "variable_batch"),
    12: .standard(proto: "rnn_states"),
    14: .standard(proto: "model_checks"),
    16: .standard(proto: "allow_nonexistent_arrays"),
    17: .standard(proto: "allow_nonascii_arrays"),
    18: .standard(proto: "arrays_extra_info"),
    19: .standard(proto: "change_concat_input_ranges"),
  ]

  fileprivate class _StorageClass {
    var _inputArrays: [Toco_InputArray] = []
    var _outputArrays: [String] = []
    var _variableBatch: Bool? = nil
    var _rnnStates: [Toco_RnnState] = []
    var _modelChecks: [Toco_ModelFlags.ModelCheck] = []
    var _allowNonexistentArrays: Bool? = nil
    var _allowNonasciiArrays: Bool? = nil
    var _arraysExtraInfo: Toco_ArraysExtraInfo? = nil
    var _changeConcatInputRanges: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inputArrays = source._inputArrays
      _outputArrays = source._outputArrays
      _variableBatch = source._variableBatch
      _rnnStates = source._rnnStates
      _modelChecks = source._modelChecks
      _allowNonexistentArrays = source._allowNonexistentArrays
      _allowNonasciiArrays = source._allowNonasciiArrays
      _arraysExtraInfo = source._arraysExtraInfo
      _changeConcatInputRanges = source._changeConcatInputRanges
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._inputArrays)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._outputArrays)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._variableBatch)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._rnnStates)
        case 14: try decoder.decodeRepeatedMessageField(value: &_storage._modelChecks)
        case 16: try decoder.decodeSingularBoolField(value: &_storage._allowNonexistentArrays)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._allowNonasciiArrays)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._arraysExtraInfo)
        case 19: try decoder.decodeSingularBoolField(value: &_storage._changeConcatInputRanges)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._inputArrays.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputArrays, fieldNumber: 1)
      }
      if !_storage._outputArrays.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._outputArrays, fieldNumber: 2)
      }
      if let v = _storage._variableBatch {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      }
      if !_storage._rnnStates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rnnStates, fieldNumber: 12)
      }
      if !_storage._modelChecks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._modelChecks, fieldNumber: 14)
      }
      if let v = _storage._allowNonexistentArrays {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }
      if let v = _storage._allowNonasciiArrays {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }
      if let v = _storage._arraysExtraInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._changeConcatInputRanges {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_ModelFlags) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._inputArrays != other_storage._inputArrays {return false}
        if _storage._outputArrays != other_storage._outputArrays {return false}
        if _storage._variableBatch != other_storage._variableBatch {return false}
        if _storage._rnnStates != other_storage._rnnStates {return false}
        if _storage._modelChecks != other_storage._modelChecks {return false}
        if _storage._allowNonexistentArrays != other_storage._allowNonexistentArrays {return false}
        if _storage._allowNonasciiArrays != other_storage._allowNonasciiArrays {return false}
        if _storage._arraysExtraInfo != other_storage._arraysExtraInfo {return false}
        if _storage._changeConcatInputRanges != other_storage._changeConcatInputRanges {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Toco_ModelFlags.ModelCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Toco_ModelFlags.protoMessageName + ".ModelCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "count_type"),
    2: .standard(proto: "count_min"),
    3: .standard(proto: "count_max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self._countType)
      case 2: try decoder.decodeSingularInt32Field(value: &self._countMin)
      case 3: try decoder.decodeSingularInt32Field(value: &self._countMax)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._countType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._countMin {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }
    if let v = self._countMax {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Toco_ModelFlags.ModelCheck) -> Bool {
    if self._countType != other._countType {return false}
    if self._countMin != other._countMin {return false}
    if self._countMax != other._countMax {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
