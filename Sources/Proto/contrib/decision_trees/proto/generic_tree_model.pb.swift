// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/contrib/decision_trees/proto/generic_tree_model.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Generic representation of tree-based models.

// This proto establishes a shared standard: "fully compatible" projects should
// provide support for all reasonable models expressed through it. Therefore,
// it should be kept as simple as possible, and should never contain
// project-specific design choices.

// Status: work in progress. This proto can change anytime without notice.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A generic handle for any type of model.
public struct Tensorflow_DecisionTrees_Model: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Model"

  public var model: OneOf_Model? {
    get {return _storage._model}
    set {_uniqueStorage()._model = newValue}
  }

  public var decisionTree: Tensorflow_DecisionTrees_DecisionTree {
    get {
      if case .decisionTree(let v)? = _storage._model {return v}
      return Tensorflow_DecisionTrees_DecisionTree()
    }
    set {_uniqueStorage()._model = .decisionTree(newValue)}
  }

  public var ensemble: Tensorflow_DecisionTrees_Ensemble {
    get {
      if case .ensemble(let v)? = _storage._model {return v}
      return Tensorflow_DecisionTrees_Ensemble()
    }
    set {_uniqueStorage()._model = .ensemble(newValue)}
  }

  public var customModel: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .customModel(let v)? = _storage._model {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {_uniqueStorage()._model = .customModel(newValue)}
  }

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._additionalData}
    set {_uniqueStorage()._additionalData = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Model: Equatable {
    case decisionTree(Tensorflow_DecisionTrees_DecisionTree)
    case ensemble(Tensorflow_DecisionTrees_Ensemble)
    case customModel(SwiftProtobuf.Google_Protobuf_Any)

    public static func ==(lhs: Tensorflow_DecisionTrees_Model.OneOf_Model, rhs: Tensorflow_DecisionTrees_Model.OneOf_Model) -> Bool {
      switch (lhs, rhs) {
      case (.decisionTree(let l), .decisionTree(let r)): return l == r
      case (.ensemble(let l), .ensemble(let r)): return l == r
      case (.customModel(let l), .customModel(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tensorflow_DecisionTrees_DecisionTree?
          if let current = _storage._model {
            try decoder.handleConflictingOneOf()
            if case .decisionTree(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._model = .decisionTree(v)}
        case 2:
          var v: Tensorflow_DecisionTrees_Ensemble?
          if let current = _storage._model {
            try decoder.handleConflictingOneOf()
            if case .ensemble(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._model = .ensemble(v)}
        case 3:
          var v: SwiftProtobuf.Google_Protobuf_Any?
          if let current = _storage._model {
            try decoder.handleConflictingOneOf()
            if case .customModel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._model = .customModel(v)}
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._model {
      case .decisionTree(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .ensemble(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .customModel(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if !_storage._additionalData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_DecisionTrees_ModelAndFeatures: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ModelAndFeatures"

  /// Given a FeatureId feature_id, the feature's description is in
  /// features[feature_id.id.value].
  public var features: Dictionary<String,Tensorflow_DecisionTrees_ModelAndFeatures.Feature> {
    get {return _storage._features}
    set {_uniqueStorage()._features = newValue}
  }

  public var model: Tensorflow_DecisionTrees_Model {
    get {return _storage._model ?? Tensorflow_DecisionTrees_Model()}
    set {_uniqueStorage()._model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  public var hasModel: Bool {return _storage._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  public mutating func clearModel() {_storage._model = nil}

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._additionalData}
    set {_uniqueStorage()._additionalData = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Feature: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_DecisionTrees_ModelAndFeatures.protoMessageName + ".Feature"

    /// TODO(jonasz): Remove this field, as it's confusing. Ctx: cr/153569450.
    public var featureID: Tensorflow_DecisionTrees_FeatureId {
      get {return _storage._featureID ?? Tensorflow_DecisionTrees_FeatureId()}
      set {_uniqueStorage()._featureID = newValue}
    }
    /// Returns true if `featureID` has been explicitly set.
    public var hasFeatureID: Bool {return _storage._featureID != nil}
    /// Clears the value of `featureID`. Subsequent reads from it will return its default value.
    public mutating func clearFeatureID() {_storage._featureID = nil}

    public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
      get {return _storage._additionalData}
      set {_uniqueStorage()._additionalData = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularMessageField(value: &_storage._featureID)
          case 2: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if let v = _storage._featureID {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !_storage._additionalData.isEmpty {
          try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 2)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_DecisionTrees_ModelAndFeatures.Feature>.self, value: &_storage._features)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._model)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._features.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_DecisionTrees_ModelAndFeatures.Feature>.self, value: _storage._features, fieldNumber: 1)
      }
      if let v = _storage._model {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._additionalData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An ordered sequence of models. This message can be used to express bagged or
/// boosted models, as well as custom ensembles.
public struct Tensorflow_DecisionTrees_Ensemble: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Ensemble"

  /// A higher id for more readable printing.
  public var members: [Tensorflow_DecisionTrees_Ensemble.Member] {
    get {return _storage._members}
    set {_uniqueStorage()._members = newValue}
  }

  /// The presence of a certain combination_technique indicates how to combine
  /// the outputs of member models in order to compute the ensemble's output.
  public var combinationTechnique: OneOf_CombinationTechnique? {
    get {return _storage._combinationTechnique}
    set {_uniqueStorage()._combinationTechnique = newValue}
  }

  public var summationCombinationTechnique: Tensorflow_DecisionTrees_Summation {
    get {
      if case .summationCombinationTechnique(let v)? = _storage._combinationTechnique {return v}
      return Tensorflow_DecisionTrees_Summation()
    }
    set {_uniqueStorage()._combinationTechnique = .summationCombinationTechnique(newValue)}
  }

  public var averagingCombinationTechnique: Tensorflow_DecisionTrees_Averaging {
    get {
      if case .averagingCombinationTechnique(let v)? = _storage._combinationTechnique {return v}
      return Tensorflow_DecisionTrees_Averaging()
    }
    set {_uniqueStorage()._combinationTechnique = .averagingCombinationTechnique(newValue)}
  }

  public var customCombinationTechnique: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .customCombinationTechnique(let v)? = _storage._combinationTechnique {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {_uniqueStorage()._combinationTechnique = .customCombinationTechnique(newValue)}
  }

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._additionalData}
    set {_uniqueStorage()._additionalData = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The presence of a certain combination_technique indicates how to combine
  /// the outputs of member models in order to compute the ensemble's output.
  public enum OneOf_CombinationTechnique: Equatable {
    case summationCombinationTechnique(Tensorflow_DecisionTrees_Summation)
    case averagingCombinationTechnique(Tensorflow_DecisionTrees_Averaging)
    case customCombinationTechnique(SwiftProtobuf.Google_Protobuf_Any)

    public static func ==(lhs: Tensorflow_DecisionTrees_Ensemble.OneOf_CombinationTechnique, rhs: Tensorflow_DecisionTrees_Ensemble.OneOf_CombinationTechnique) -> Bool {
      switch (lhs, rhs) {
      case (.summationCombinationTechnique(let l), .summationCombinationTechnique(let r)): return l == r
      case (.averagingCombinationTechnique(let l), .averagingCombinationTechnique(let r)): return l == r
      case (.customCombinationTechnique(let l), .customCombinationTechnique(let r)): return l == r
      default: return false
      }
    }
  }

  public struct Member: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_DecisionTrees_Ensemble.protoMessageName + ".Member"

    public var submodel: Tensorflow_DecisionTrees_Model {
      get {return _storage._submodel ?? Tensorflow_DecisionTrees_Model()}
      set {_uniqueStorage()._submodel = newValue}
    }
    /// Returns true if `submodel` has been explicitly set.
    public var hasSubmodel: Bool {return _storage._submodel != nil}
    /// Clears the value of `submodel`. Subsequent reads from it will return its default value.
    public mutating func clearSubmodel() {_storage._submodel = nil}

    public var submodelID: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _storage._submodelID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_uniqueStorage()._submodelID = newValue}
    }
    /// Returns true if `submodelID` has been explicitly set.
    public var hasSubmodelID: Bool {return _storage._submodelID != nil}
    /// Clears the value of `submodelID`. Subsequent reads from it will return its default value.
    public mutating func clearSubmodelID() {_storage._submodelID = nil}

    public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
      get {return _storage._additionalData}
      set {_uniqueStorage()._additionalData = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularMessageField(value: &_storage._submodel)
          case 2: try decoder.decodeSingularMessageField(value: &_storage._submodelID)
          case 3: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if let v = _storage._submodel {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if let v = _storage._submodelID {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
        if !_storage._additionalData.isEmpty {
          try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 3)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tensorflow_DecisionTrees_Summation?
          if let current = _storage._combinationTechnique {
            try decoder.handleConflictingOneOf()
            if case .summationCombinationTechnique(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._combinationTechnique = .summationCombinationTechnique(v)}
        case 2:
          var v: Tensorflow_DecisionTrees_Averaging?
          if let current = _storage._combinationTechnique {
            try decoder.handleConflictingOneOf()
            if case .averagingCombinationTechnique(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._combinationTechnique = .averagingCombinationTechnique(v)}
        case 3:
          var v: SwiftProtobuf.Google_Protobuf_Any?
          if let current = _storage._combinationTechnique {
            try decoder.handleConflictingOneOf()
            if case .customCombinationTechnique(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._combinationTechnique = .customCombinationTechnique(v)}
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
        case 100: try decoder.decodeRepeatedMessageField(value: &_storage._members)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._combinationTechnique {
      case .summationCombinationTechnique(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .averagingCombinationTechnique(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .customCombinationTechnique(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if !_storage._additionalData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 4)
      }
      if !_storage._members.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._members, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// When present, the Ensemble's output is the sum of member models' outputs.
public struct Tensorflow_DecisionTrees_Summation: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Summation"

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.additionalData)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.additionalData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.additionalData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// When present, the Ensemble's output is the average of member models' outputs.
public struct Tensorflow_DecisionTrees_Averaging: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Averaging"

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.additionalData)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.additionalData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.additionalData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_DecisionTrees_DecisionTree: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".DecisionTree"

  public var nodes: [Tensorflow_DecisionTrees_TreeNode] = []

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.nodes)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.additionalData)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if !self.additionalData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.additionalData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_DecisionTrees_TreeNode: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TreeNode"

  /// Following fields are provided for convenience and better readability.
  /// Filling them in is not required.
  public var nodeID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._nodeID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._nodeID = newValue}
  }
  /// Returns true if `nodeID` has been explicitly set.
  public var hasNodeID: Bool {return _storage._nodeID != nil}
  /// Clears the value of `nodeID`. Subsequent reads from it will return its default value.
  public mutating func clearNodeID() {_storage._nodeID = nil}

  public var depth: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._depth ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._depth = newValue}
  }
  /// Returns true if `depth` has been explicitly set.
  public var hasDepth: Bool {return _storage._depth != nil}
  /// Clears the value of `depth`. Subsequent reads from it will return its default value.
  public mutating func clearDepth() {_storage._depth = nil}

  public var subtreeSize: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._subtreeSize ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._subtreeSize = newValue}
  }
  /// Returns true if `subtreeSize` has been explicitly set.
  public var hasSubtreeSize: Bool {return _storage._subtreeSize != nil}
  /// Clears the value of `subtreeSize`. Subsequent reads from it will return its default value.
  public mutating func clearSubtreeSize() {_storage._subtreeSize = nil}

  public var nodeType: OneOf_NodeType? {
    get {return _storage._nodeType}
    set {_uniqueStorage()._nodeType = newValue}
  }

  public var binaryNode: Tensorflow_DecisionTrees_BinaryNode {
    get {
      if case .binaryNode(let v)? = _storage._nodeType {return v}
      return Tensorflow_DecisionTrees_BinaryNode()
    }
    set {_uniqueStorage()._nodeType = .binaryNode(newValue)}
  }

  public var leaf: Tensorflow_DecisionTrees_Leaf {
    get {
      if case .leaf(let v)? = _storage._nodeType {return v}
      return Tensorflow_DecisionTrees_Leaf()
    }
    set {_uniqueStorage()._nodeType = .leaf(newValue)}
  }

  public var customNodeType: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .customNodeType(let v)? = _storage._nodeType {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {_uniqueStorage()._nodeType = .customNodeType(newValue)}
  }

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._additionalData}
    set {_uniqueStorage()._additionalData = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_NodeType: Equatable {
    case binaryNode(Tensorflow_DecisionTrees_BinaryNode)
    case leaf(Tensorflow_DecisionTrees_Leaf)
    case customNodeType(SwiftProtobuf.Google_Protobuf_Any)

    public static func ==(lhs: Tensorflow_DecisionTrees_TreeNode.OneOf_NodeType, rhs: Tensorflow_DecisionTrees_TreeNode.OneOf_NodeType) -> Bool {
      switch (lhs, rhs) {
      case (.binaryNode(let l), .binaryNode(let r)): return l == r
      case (.leaf(let l), .leaf(let r)): return l == r
      case (.customNodeType(let l), .customNodeType(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._nodeID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._depth)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._subtreeSize)
        case 4:
          var v: Tensorflow_DecisionTrees_BinaryNode?
          if let current = _storage._nodeType {
            try decoder.handleConflictingOneOf()
            if case .binaryNode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nodeType = .binaryNode(v)}
        case 5:
          var v: Tensorflow_DecisionTrees_Leaf?
          if let current = _storage._nodeType {
            try decoder.handleConflictingOneOf()
            if case .leaf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nodeType = .leaf(v)}
        case 6:
          var v: SwiftProtobuf.Google_Protobuf_Any?
          if let current = _storage._nodeType {
            try decoder.handleConflictingOneOf()
            if case .customNodeType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._nodeType = .customNodeType(v)}
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._nodeID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._depth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._subtreeSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      switch _storage._nodeType {
      case .binaryNode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .leaf(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .customNodeType(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case nil: break
      }
      if !_storage._additionalData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_DecisionTrees_BinaryNode: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".BinaryNode"

  public var leftChildID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._leftChildID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._leftChildID = newValue}
  }
  /// Returns true if `leftChildID` has been explicitly set.
  public var hasLeftChildID: Bool {return _storage._leftChildID != nil}
  /// Clears the value of `leftChildID`. Subsequent reads from it will return its default value.
  public mutating func clearLeftChildID() {_storage._leftChildID = nil}

  public var rightChildID: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._rightChildID ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._rightChildID = newValue}
  }
  /// Returns true if `rightChildID` has been explicitly set.
  public var hasRightChildID: Bool {return _storage._rightChildID != nil}
  /// Clears the value of `rightChildID`. Subsequent reads from it will return its default value.
  public mutating func clearRightChildID() {_storage._rightChildID = nil}

  /// When left_child_test is undefined for a particular datapoint (e.g. because
  /// it's not defined when feature value is missing), the datapoint should go
  /// in this direction.
  public var defaultDirection: Tensorflow_DecisionTrees_BinaryNode.Direction {
    get {return _storage._defaultDirection}
    set {_uniqueStorage()._defaultDirection = newValue}
  }

  /// When a datapoint satisfies the test, it should be propagated to the left
  /// child.
  public var leftChildTest: OneOf_LeftChildTest? {
    get {return _storage._leftChildTest}
    set {_uniqueStorage()._leftChildTest = newValue}
  }

  public var inequalityLeftChildTest: Tensorflow_DecisionTrees_InequalityTest {
    get {
      if case .inequalityLeftChildTest(let v)? = _storage._leftChildTest {return v}
      return Tensorflow_DecisionTrees_InequalityTest()
    }
    set {_uniqueStorage()._leftChildTest = .inequalityLeftChildTest(newValue)}
  }

  public var customLeftChildTest: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .customLeftChildTest(let v)? = _storage._leftChildTest {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {_uniqueStorage()._leftChildTest = .customLeftChildTest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// When a datapoint satisfies the test, it should be propagated to the left
  /// child.
  public enum OneOf_LeftChildTest: Equatable {
    case inequalityLeftChildTest(Tensorflow_DecisionTrees_InequalityTest)
    case customLeftChildTest(SwiftProtobuf.Google_Protobuf_Any)

    public static func ==(lhs: Tensorflow_DecisionTrees_BinaryNode.OneOf_LeftChildTest, rhs: Tensorflow_DecisionTrees_BinaryNode.OneOf_LeftChildTest) -> Bool {
      switch (lhs, rhs) {
      case (.inequalityLeftChildTest(let l), .inequalityLeftChildTest(let r)): return l == r
      case (.customLeftChildTest(let l), .customLeftChildTest(let r)): return l == r
      default: return false
      }
    }
  }

  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case left // = 0
    case right // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .left
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .left
      case 1: self = .right
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .left: return 0
      case .right: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._leftChildID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._rightChildID)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._defaultDirection)
        case 4:
          var v: Tensorflow_DecisionTrees_InequalityTest?
          if let current = _storage._leftChildTest {
            try decoder.handleConflictingOneOf()
            if case .inequalityLeftChildTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._leftChildTest = .inequalityLeftChildTest(v)}
        case 5:
          var v: SwiftProtobuf.Google_Protobuf_Any?
          if let current = _storage._leftChildTest {
            try decoder.handleConflictingOneOf()
            if case .customLeftChildTest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._leftChildTest = .customLeftChildTest(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._leftChildID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._rightChildID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._defaultDirection != .left {
        try visitor.visitSingularEnumField(value: _storage._defaultDirection, fieldNumber: 3)
      }
      switch _storage._leftChildTest {
      case .inequalityLeftChildTest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .customLeftChildTest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A SparseVector represents a vector in which only certain select elements
/// are non-zero.  Maps labels to values (e.g. class id to probability or count).
public struct Tensorflow_DecisionTrees_SparseVector: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SparseVector"

  public var sparseValue: Dictionary<Int64,Tensorflow_DecisionTrees_Value> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorflow_DecisionTrees_Value>.self, value: &self.sparseValue)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sparseValue.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorflow_DecisionTrees_Value>.self, value: self.sparseValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_DecisionTrees_Vector: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Vector"

  public var value: [Tensorflow_DecisionTrees_Value] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.value)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_DecisionTrees_Leaf: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Leaf"

  public var leaf: OneOf_Leaf? {
    get {return _storage._leaf}
    set {_uniqueStorage()._leaf = newValue}
  }

  /// The interpretation of the values held in the leaves of a decision tree
  /// is application specific, but some common cases are:
  /// 1) len(vector) = 1, and the floating point value[0] holds the class 0
  ///    probability in a two class classification problem.
  /// 2) len(vector) = 1, and the integer value[0] holds the class prediction.
  /// 3) The floating point value[i] holds the class i probability prediction.
  /// 4) The floating point value[i] holds the i-th component of the
  ///    vector prediction in a regression problem.
  /// 5) sparse_vector holds the sparse class predictions for a classification
  ///    problem with a large number of classes.
  public var vector: Tensorflow_DecisionTrees_Vector {
    get {
      if case .vector(let v)? = _storage._leaf {return v}
      return Tensorflow_DecisionTrees_Vector()
    }
    set {_uniqueStorage()._leaf = .vector(newValue)}
  }

  public var sparseVector: Tensorflow_DecisionTrees_SparseVector {
    get {
      if case .sparseVector(let v)? = _storage._leaf {return v}
      return Tensorflow_DecisionTrees_SparseVector()
    }
    set {_uniqueStorage()._leaf = .sparseVector(newValue)}
  }

  /// For non-standard handling of leaves.
  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._additionalData}
    set {_uniqueStorage()._additionalData = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Leaf: Equatable {
    /// The interpretation of the values held in the leaves of a decision tree
    /// is application specific, but some common cases are:
    /// 1) len(vector) = 1, and the floating point value[0] holds the class 0
    ///    probability in a two class classification problem.
    /// 2) len(vector) = 1, and the integer value[0] holds the class prediction.
    /// 3) The floating point value[i] holds the class i probability prediction.
    /// 4) The floating point value[i] holds the i-th component of the
    ///    vector prediction in a regression problem.
    /// 5) sparse_vector holds the sparse class predictions for a classification
    ///    problem with a large number of classes.
    case vector(Tensorflow_DecisionTrees_Vector)
    case sparseVector(Tensorflow_DecisionTrees_SparseVector)

    public static func ==(lhs: Tensorflow_DecisionTrees_Leaf.OneOf_Leaf, rhs: Tensorflow_DecisionTrees_Leaf.OneOf_Leaf) -> Bool {
      switch (lhs, rhs) {
      case (.vector(let l), .vector(let r)): return l == r
      case (.sparseVector(let l), .sparseVector(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tensorflow_DecisionTrees_Vector?
          if let current = _storage._leaf {
            try decoder.handleConflictingOneOf()
            if case .vector(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._leaf = .vector(v)}
        case 2:
          var v: Tensorflow_DecisionTrees_SparseVector?
          if let current = _storage._leaf {
            try decoder.handleConflictingOneOf()
            if case .sparseVector(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._leaf = .sparseVector(v)}
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._leaf {
      case .vector(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .sparseVector(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case nil: break
      }
      if !_storage._additionalData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_DecisionTrees_FeatureId: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".FeatureId"

  public var id: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._id ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_storage._id = nil}

  public var additionalData: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._additionalData}
    set {_uniqueStorage()._additionalData = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._id)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._additionalData)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._additionalData.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalData, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_DecisionTrees_ObliqueFeatures: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ObliqueFeatures"

  /// total value is sum(features[i] * weights[i]).
  public var features: [Tensorflow_DecisionTrees_FeatureId] = []

  public var weights: [Float] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.features)
      case 2: try decoder.decodeRepeatedFloatField(value: &self.weights)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.features.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.features, fieldNumber: 1)
    }
    if !self.weights.isEmpty {
      try visitor.visitPackedFloatField(value: self.weights, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_DecisionTrees_InequalityTest: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".InequalityTest"

  /// When the feature is missing, the test's outcome is undefined.
  public var featureSum: OneOf_FeatureSum? {
    get {return _storage._featureSum}
    set {_uniqueStorage()._featureSum = newValue}
  }

  public var featureID: Tensorflow_DecisionTrees_FeatureId {
    get {
      if case .featureID(let v)? = _storage._featureSum {return v}
      return Tensorflow_DecisionTrees_FeatureId()
    }
    set {_uniqueStorage()._featureSum = .featureID(newValue)}
  }

  public var oblique: Tensorflow_DecisionTrees_ObliqueFeatures {
    get {
      if case .oblique(let v)? = _storage._featureSum {return v}
      return Tensorflow_DecisionTrees_ObliqueFeatures()
    }
    set {_uniqueStorage()._featureSum = .oblique(newValue)}
  }

  public var type: Tensorflow_DecisionTrees_InequalityTest.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var threshold: Tensorflow_DecisionTrees_Value {
    get {return _storage._threshold ?? Tensorflow_DecisionTrees_Value()}
    set {_uniqueStorage()._threshold = newValue}
  }
  /// Returns true if `threshold` has been explicitly set.
  public var hasThreshold: Bool {return _storage._threshold != nil}
  /// Clears the value of `threshold`. Subsequent reads from it will return its default value.
  public mutating func clearThreshold() {_storage._threshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// When the feature is missing, the test's outcome is undefined.
  public enum OneOf_FeatureSum: Equatable {
    case featureID(Tensorflow_DecisionTrees_FeatureId)
    case oblique(Tensorflow_DecisionTrees_ObliqueFeatures)

    public static func ==(lhs: Tensorflow_DecisionTrees_InequalityTest.OneOf_FeatureSum, rhs: Tensorflow_DecisionTrees_InequalityTest.OneOf_FeatureSum) -> Bool {
      switch (lhs, rhs) {
      case (.featureID(let l), .featureID(let r)): return l == r
      case (.oblique(let l), .oblique(let r)): return l == r
      default: return false
      }
    }
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case lessOrEqual // = 0
    case lessThan // = 1
    case greaterOrEqual // = 2
    case greaterThan // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .lessOrEqual
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lessOrEqual
      case 1: self = .lessThan
      case 2: self = .greaterOrEqual
      case 3: self = .greaterThan
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .lessOrEqual: return 0
      case .lessThan: return 1
      case .greaterOrEqual: return 2
      case .greaterThan: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tensorflow_DecisionTrees_FeatureId?
          if let current = _storage._featureSum {
            try decoder.handleConflictingOneOf()
            if case .featureID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._featureSum = .featureID(v)}
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._threshold)
        case 4:
          var v: Tensorflow_DecisionTrees_ObliqueFeatures?
          if let current = _storage._featureSum {
            try decoder.handleConflictingOneOf()
            if case .oblique(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._featureSum = .oblique(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .featureID(let v)? = _storage._featureSum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._type != .lessOrEqual {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if let v = _storage._threshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if case .oblique(let v)? = _storage._featureSum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a single value of any type, e.g. 5 or "abc".
public struct Tensorflow_DecisionTrees_Value: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".Value"

  public var value: OneOf_Value? {
    get {return _storage._value}
    set {_uniqueStorage()._value = newValue}
  }

  public var floatValue: Float {
    get {
      if case .floatValue(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .floatValue(newValue)}
  }

  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .doubleValue(newValue)}
  }

  public var int32Value: Int32 {
    get {
      if case .int32Value(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .int32Value(newValue)}
  }

  public var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = _storage._value {return v}
      return 0
    }
    set {_uniqueStorage()._value = .int64Value(newValue)}
  }

  public var customValue: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .customValue(let v)? = _storage._value {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {_uniqueStorage()._value = .customValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    case floatValue(Float)
    case doubleValue(Double)
    case int32Value(Int32)
    case int64Value(Int64)
    case customValue(SwiftProtobuf.Google_Protobuf_Any)

    public static func ==(lhs: Tensorflow_DecisionTrees_Value.OneOf_Value, rhs: Tensorflow_DecisionTrees_Value.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.floatValue(let l), .floatValue(let r)): return l == r
      case (.doubleValue(let l), .doubleValue(let r)): return l == r
      case (.int32Value(let l), .int32Value(let r)): return l == r
      case (.int64Value(let l), .int64Value(let r)): return l == r
      case (.customValue(let l), .customValue(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._value = .floatValue(v)}
        case 2:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {_storage._value = .doubleValue(v)}
        case 3:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {_storage._value = .int32Value(v)}
        case 4:
          if _storage._value != nil {try decoder.handleConflictingOneOf()}
          var v: Int64?
          try decoder.decodeSingularInt64Field(value: &v)
          if let v = v {_storage._value = .int64Value(v)}
        case 5:
          var v: SwiftProtobuf.Google_Protobuf_Any?
          if let current = _storage._value {
            try decoder.handleConflictingOneOf()
            if case .customValue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._value = .customValue(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._value {
      case .floatValue(let v)?:
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      case .doubleValue(let v)?:
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
      case .int32Value(let v)?:
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      case .int64Value(let v)?:
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
      case .customValue(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow.decision_trees"

extension Tensorflow_DecisionTrees_Model: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "decision_tree"),
    2: .same(proto: "ensemble"),
    3: .standard(proto: "custom_model"),
    4: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _model: Tensorflow_DecisionTrees_Model.OneOf_Model?
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _model = source._model
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Model) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._model != other_storage._model {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_ModelAndFeatures: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
    2: .same(proto: "model"),
    3: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _features: Dictionary<String,Tensorflow_DecisionTrees_ModelAndFeatures.Feature> = [:]
    var _model: Tensorflow_DecisionTrees_Model? = nil
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _features = source._features
      _model = source._model
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_ModelAndFeatures) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._features != other_storage._features {return false}
        if _storage._model != other_storage._model {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_ModelAndFeatures.Feature: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_id"),
    2: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _featureID: Tensorflow_DecisionTrees_FeatureId? = nil
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _featureID = source._featureID
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_ModelAndFeatures.Feature) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._featureID != other_storage._featureID {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_Ensemble: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    100: .same(proto: "members"),
    1: .standard(proto: "summation_combination_technique"),
    2: .standard(proto: "averaging_combination_technique"),
    3: .standard(proto: "custom_combination_technique"),
    4: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _members: [Tensorflow_DecisionTrees_Ensemble.Member] = []
    var _combinationTechnique: Tensorflow_DecisionTrees_Ensemble.OneOf_CombinationTechnique?
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _members = source._members
      _combinationTechnique = source._combinationTechnique
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Ensemble) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._members != other_storage._members {return false}
        if _storage._combinationTechnique != other_storage._combinationTechnique {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_Ensemble.Member: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "submodel"),
    2: .standard(proto: "submodel_id"),
    3: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _submodel: Tensorflow_DecisionTrees_Model? = nil
    var _submodelID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _submodel = source._submodel
      _submodelID = source._submodelID
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Ensemble.Member) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._submodel != other_storage._submodel {return false}
        if _storage._submodelID != other_storage._submodelID {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_Summation: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "additional_data"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Summation) -> Bool {
    if self.additionalData != other.additionalData {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_Averaging: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "additional_data"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Averaging) -> Bool {
    if self.additionalData != other.additionalData {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_DecisionTree: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "additional_data"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_DecisionTree) -> Bool {
    if self.nodes != other.nodes {return false}
    if self.additionalData != other.additionalData {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_TreeNode: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "depth"),
    3: .standard(proto: "subtree_size"),
    4: .standard(proto: "binary_node"),
    5: .same(proto: "leaf"),
    6: .standard(proto: "custom_node_type"),
    7: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _nodeID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _depth: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _subtreeSize: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _nodeType: Tensorflow_DecisionTrees_TreeNode.OneOf_NodeType?
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _nodeID = source._nodeID
      _depth = source._depth
      _subtreeSize = source._subtreeSize
      _nodeType = source._nodeType
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_TreeNode) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._nodeID != other_storage._nodeID {return false}
        if _storage._depth != other_storage._depth {return false}
        if _storage._subtreeSize != other_storage._subtreeSize {return false}
        if _storage._nodeType != other_storage._nodeType {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_BinaryNode: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "left_child_id"),
    2: .standard(proto: "right_child_id"),
    3: .standard(proto: "default_direction"),
    4: .standard(proto: "inequality_left_child_test"),
    5: .standard(proto: "custom_left_child_test"),
  ]

  fileprivate class _StorageClass {
    var _leftChildID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _rightChildID: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _defaultDirection: Tensorflow_DecisionTrees_BinaryNode.Direction = .left
    var _leftChildTest: Tensorflow_DecisionTrees_BinaryNode.OneOf_LeftChildTest?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leftChildID = source._leftChildID
      _rightChildID = source._rightChildID
      _defaultDirection = source._defaultDirection
      _leftChildTest = source._leftChildTest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_BinaryNode) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._leftChildID != other_storage._leftChildID {return false}
        if _storage._rightChildID != other_storage._rightChildID {return false}
        if _storage._defaultDirection != other_storage._defaultDirection {return false}
        if _storage._leftChildTest != other_storage._leftChildTest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_BinaryNode.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEFT"),
    1: .same(proto: "RIGHT"),
  ]
}

extension Tensorflow_DecisionTrees_SparseVector: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sparse_value"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_SparseVector) -> Bool {
    if self.sparseValue != other.sparseValue {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_Vector: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Vector) -> Bool {
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_Leaf: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vector"),
    2: .standard(proto: "sparse_vector"),
    3: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _leaf: Tensorflow_DecisionTrees_Leaf.OneOf_Leaf?
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leaf = source._leaf
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Leaf) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._leaf != other_storage._leaf {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_FeatureId: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "additional_data"),
  ]

  fileprivate class _StorageClass {
    var _id: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _additionalData: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _additionalData = source._additionalData
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_FeatureId) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        if _storage._additionalData != other_storage._additionalData {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_ObliqueFeatures: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
    2: .same(proto: "weights"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_ObliqueFeatures) -> Bool {
    if self.features != other.features {return false}
    if self.weights != other.weights {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_InequalityTest: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "feature_id"),
    4: .same(proto: "oblique"),
    2: .same(proto: "type"),
    3: .same(proto: "threshold"),
  ]

  fileprivate class _StorageClass {
    var _featureSum: Tensorflow_DecisionTrees_InequalityTest.OneOf_FeatureSum?
    var _type: Tensorflow_DecisionTrees_InequalityTest.TypeEnum = .lessOrEqual
    var _threshold: Tensorflow_DecisionTrees_Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _featureSum = source._featureSum
      _type = source._type
      _threshold = source._threshold
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_InequalityTest) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._featureSum != other_storage._featureSum {return false}
        if _storage._type != other_storage._type {return false}
        if _storage._threshold != other_storage._threshold {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DecisionTrees_InequalityTest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LESS_OR_EQUAL"),
    1: .same(proto: "LESS_THAN"),
    2: .same(proto: "GREATER_OR_EQUAL"),
    3: .same(proto: "GREATER_THAN"),
  ]
}

extension Tensorflow_DecisionTrees_Value: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "float_value"),
    2: .standard(proto: "double_value"),
    3: .standard(proto: "int32_value"),
    4: .standard(proto: "int64_value"),
    5: .standard(proto: "custom_value"),
  ]

  fileprivate class _StorageClass {
    var _value: Tensorflow_DecisionTrees_Value.OneOf_Value?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DecisionTrees_Value) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._value != other_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
