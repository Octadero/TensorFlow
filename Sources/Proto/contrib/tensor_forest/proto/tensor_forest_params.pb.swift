// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/contrib/tensor_forest/proto/tensor_forest_params.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Leaf models specify what is returned at inference time, and how it is
/// stored in the decision_trees.Leaf protos.
public enum Tensorflow_Tensorforest_LeafModelType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case modelDenseClassification // = 0
  case modelSparseClassification // = 1
  case modelRegression // = 2
  case modelSparseOrDenseClassification // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .modelDenseClassification
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .modelDenseClassification
    case 1: self = .modelSparseClassification
    case 2: self = .modelRegression
    case 3: self = .modelSparseOrDenseClassification
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .modelDenseClassification: return 0
    case .modelSparseClassification: return 1
    case .modelRegression: return 2
    case .modelSparseOrDenseClassification: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Stats models generally specify information that is collected which is
/// necessary to choose a split at a node. Specifically, they operate on
/// a SplitCandidate::LeafStat proto.
public enum Tensorflow_Tensorforest_StatsModelType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case statsDenseGini // = 0
  case statsSparseGini // = 1
  case statsLeastSquaresRegression // = 2

  /// STATS_SPARSE_THEN_DENSE_GINI is deprecated and no longer supported.
  case statsSparseThenDenseGini // = 3
  case statsFixedSizeSparseGini // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .statsDenseGini
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statsDenseGini
    case 1: self = .statsSparseGini
    case 2: self = .statsLeastSquaresRegression
    case 3: self = .statsSparseThenDenseGini
    case 4: self = .statsFixedSizeSparseGini
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .statsDenseGini: return 0
    case .statsSparseGini: return 1
    case .statsLeastSquaresRegression: return 2
    case .statsSparseThenDenseGini: return 3
    case .statsFixedSizeSparseGini: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Allows selection of operations on the collection of split candidates.
/// Basic infers right split stats from the leaf stats and each candidate's
/// left stats.
public enum Tensorflow_Tensorforest_SplitCollectionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case collectionBasic // = 0
  case graphRunnerCollection // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .collectionBasic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .collectionBasic
    case 1: self = .graphRunnerCollection
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .collectionBasic: return 0
    case .graphRunnerCollection: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Pruning strategies define how candidates are pruned over time.
/// SPLIT_PRUNE_HALF prunes the worst half of splits every prune_ever_samples,
/// etc.  Note that prune_every_samples plays against the depth-dependent
/// split_after_samples, so they should be set together.
public enum Tensorflow_Tensorforest_SplitPruningStrategyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case splitPruneNone // = 0
  case splitPruneHalf // = 1
  case splitPruneQuarter // = 2
  case splitPrune10Percent // = 3

  /// SPLIT_PRUNE_HOEFFDING prunes splits whose Gini impurity is worst than
  /// the best split's by more than the Hoeffding bound.
  case splitPruneHoeffding // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .splitPruneNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .splitPruneNone
    case 1: self = .splitPruneHalf
    case 2: self = .splitPruneQuarter
    case 3: self = .splitPrune10Percent
    case 4: self = .splitPruneHoeffding
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .splitPruneNone: return 0
    case .splitPruneHalf: return 1
    case .splitPruneQuarter: return 2
    case .splitPrune10Percent: return 3
    case .splitPruneHoeffding: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Finish strategies define when slots are considered finished.
/// Basic requires at least split_after_samples, and doesn't allow slots to
/// finish until the leaf has received more than one class. Hoeffding splits
/// early after min_split_samples if one split is dominating the rest according
/// to hoeffding bounds. Bootstrap does the same but compares gini's calculated
/// with sampled smoothed counts.
public enum Tensorflow_Tensorforest_SplitFinishStrategyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case splitFinishBasic // = 0
  case splitFinishDominateHoeffding // = 2
  case splitFinishDominateBootstrap // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .splitFinishBasic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .splitFinishBasic
    case 2: self = .splitFinishDominateHoeffding
    case 3: self = .splitFinishDominateBootstrap
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .splitFinishBasic: return 0
    case .splitFinishDominateHoeffding: return 2
    case .splitFinishDominateBootstrap: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

public struct Tensorflow_Tensorforest_SplitPruningConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SplitPruningConfig"

  public var pruneEverySamples: Tensorflow_Tensorforest_DepthDependentParam {
    get {return _storage._pruneEverySamples ?? Tensorflow_Tensorforest_DepthDependentParam()}
    set {_uniqueStorage()._pruneEverySamples = newValue}
  }
  /// Returns true if `pruneEverySamples` has been explicitly set.
  public var hasPruneEverySamples: Bool {return _storage._pruneEverySamples != nil}
  /// Clears the value of `pruneEverySamples`. Subsequent reads from it will return its default value.
  public mutating func clearPruneEverySamples() {_storage._pruneEverySamples = nil}

  public var type: Tensorflow_Tensorforest_SplitPruningStrategyType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._pruneEverySamples)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._pruneEverySamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._type != .splitPruneNone {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_Tensorforest_SplitFinishConfig: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SplitFinishConfig"

  /// Configure how often we check for finish, because some finish methods
  /// are expensive to perform.
  public var checkEverySteps: Tensorflow_Tensorforest_DepthDependentParam {
    get {return _storage._checkEverySteps ?? Tensorflow_Tensorforest_DepthDependentParam()}
    set {_uniqueStorage()._checkEverySteps = newValue}
  }
  /// Returns true if `checkEverySteps` has been explicitly set.
  public var hasCheckEverySteps: Bool {return _storage._checkEverySteps != nil}
  /// Clears the value of `checkEverySteps`. Subsequent reads from it will return its default value.
  public mutating func clearCheckEverySteps() {_storage._checkEverySteps = nil}

  public var type: Tensorflow_Tensorforest_SplitFinishStrategyType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._checkEverySteps)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._checkEverySteps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._type != .splitFinishBasic {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A parameter that changes linearly with depth, with upper and lower bounds.
public struct Tensorflow_Tensorforest_LinearParam: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".LinearParam"

  public var slope: Float = 0

  public var yIntercept: Float = 0

  public var minVal: Float = 0

  public var maxVal: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.slope)
      case 2: try decoder.decodeSingularFloatField(value: &self.yIntercept)
      case 3: try decoder.decodeSingularFloatField(value: &self.minVal)
      case 4: try decoder.decodeSingularFloatField(value: &self.maxVal)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.slope != 0 {
      try visitor.visitSingularFloatField(value: self.slope, fieldNumber: 1)
    }
    if self.yIntercept != 0 {
      try visitor.visitSingularFloatField(value: self.yIntercept, fieldNumber: 2)
    }
    if self.minVal != 0 {
      try visitor.visitSingularFloatField(value: self.minVal, fieldNumber: 3)
    }
    if self.maxVal != 0 {
      try visitor.visitSingularFloatField(value: self.maxVal, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// A parameter that changes expoentially with the form
///     f = c + mb^(k*d)
/// where:
///  c: constant bias
///  b: base
///  m: multiplier
///  k: depth multiplier
///  d: depth
public struct Tensorflow_Tensorforest_ExponentialParam: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ExponentialParam"

  public var bias: Float = 0

  public var base: Float = 0

  public var multiplier: Float = 0

  public var depthMultiplier: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.bias)
      case 2: try decoder.decodeSingularFloatField(value: &self.base)
      case 3: try decoder.decodeSingularFloatField(value: &self.multiplier)
      case 4: try decoder.decodeSingularFloatField(value: &self.depthMultiplier)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bias != 0 {
      try visitor.visitSingularFloatField(value: self.bias, fieldNumber: 1)
    }
    if self.base != 0 {
      try visitor.visitSingularFloatField(value: self.base, fieldNumber: 2)
    }
    if self.multiplier != 0 {
      try visitor.visitSingularFloatField(value: self.multiplier, fieldNumber: 3)
    }
    if self.depthMultiplier != 0 {
      try visitor.visitSingularFloatField(value: self.depthMultiplier, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// A parameter that is 'off' until depth >= a threshold, then is 'on'.
public struct Tensorflow_Tensorforest_ThresholdParam: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdParam"

  public var onValue: Float = 0

  public var offValue: Float = 0

  public var threshold: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.onValue)
      case 2: try decoder.decodeSingularFloatField(value: &self.offValue)
      case 3: try decoder.decodeSingularFloatField(value: &self.threshold)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.onValue != 0 {
      try visitor.visitSingularFloatField(value: self.onValue, fieldNumber: 1)
    }
    if self.offValue != 0 {
      try visitor.visitSingularFloatField(value: self.offValue, fieldNumber: 2)
    }
    if self.threshold != 0 {
      try visitor.visitSingularFloatField(value: self.threshold, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// A parameter that may change with node depth.
public struct Tensorflow_Tensorforest_DepthDependentParam: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".DepthDependentParam"

  public var paramType: OneOf_ParamType? {
    get {return _storage._paramType}
    set {_uniqueStorage()._paramType = newValue}
  }

  public var constantValue: Float {
    get {
      if case .constantValue(let v)? = _storage._paramType {return v}
      return 0
    }
    set {_uniqueStorage()._paramType = .constantValue(newValue)}
  }

  public var linear: Tensorflow_Tensorforest_LinearParam {
    get {
      if case .linear(let v)? = _storage._paramType {return v}
      return Tensorflow_Tensorforest_LinearParam()
    }
    set {_uniqueStorage()._paramType = .linear(newValue)}
  }

  public var exponential: Tensorflow_Tensorforest_ExponentialParam {
    get {
      if case .exponential(let v)? = _storage._paramType {return v}
      return Tensorflow_Tensorforest_ExponentialParam()
    }
    set {_uniqueStorage()._paramType = .exponential(newValue)}
  }

  public var threshold: Tensorflow_Tensorforest_ThresholdParam {
    get {
      if case .threshold(let v)? = _storage._paramType {return v}
      return Tensorflow_Tensorforest_ThresholdParam()
    }
    set {_uniqueStorage()._paramType = .threshold(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ParamType: Equatable {
    case constantValue(Float)
    case linear(Tensorflow_Tensorforest_LinearParam)
    case exponential(Tensorflow_Tensorforest_ExponentialParam)
    case threshold(Tensorflow_Tensorforest_ThresholdParam)

    public static func ==(lhs: Tensorflow_Tensorforest_DepthDependentParam.OneOf_ParamType, rhs: Tensorflow_Tensorforest_DepthDependentParam.OneOf_ParamType) -> Bool {
      switch (lhs, rhs) {
      case (.constantValue(let l), .constantValue(let r)): return l == r
      case (.linear(let l), .linear(let r)): return l == r
      case (.exponential(let l), .exponential(let r)): return l == r
      case (.threshold(let l), .threshold(let r)): return l == r
      default: return false
      }
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._paramType != nil {try decoder.handleConflictingOneOf()}
          var v: Float?
          try decoder.decodeSingularFloatField(value: &v)
          if let v = v {_storage._paramType = .constantValue(v)}
        case 2:
          var v: Tensorflow_Tensorforest_LinearParam?
          if let current = _storage._paramType {
            try decoder.handleConflictingOneOf()
            if case .linear(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paramType = .linear(v)}
        case 3:
          var v: Tensorflow_Tensorforest_ExponentialParam?
          if let current = _storage._paramType {
            try decoder.handleConflictingOneOf()
            if case .exponential(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paramType = .exponential(v)}
        case 4:
          var v: Tensorflow_Tensorforest_ThresholdParam?
          if let current = _storage._paramType {
            try decoder.handleConflictingOneOf()
            if case .threshold(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._paramType = .threshold(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._paramType {
      case .constantValue(let v)?:
        try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
      case .linear(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .exponential(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .threshold(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_Tensorforest_TensorForestParams: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TensorForestParams"

  /// ------------ Types that control training subsystems ------ //
  public var leafType: Tensorflow_Tensorforest_LeafModelType {
    get {return _storage._leafType}
    set {_uniqueStorage()._leafType = newValue}
  }

  public var statsType: Tensorflow_Tensorforest_StatsModelType {
    get {return _storage._statsType}
    set {_uniqueStorage()._statsType = newValue}
  }

  public var collectionType: Tensorflow_Tensorforest_SplitCollectionType {
    get {return _storage._collectionType}
    set {_uniqueStorage()._collectionType = newValue}
  }

  public var pruningType: Tensorflow_Tensorforest_SplitPruningConfig {
    get {return _storage._pruningType ?? Tensorflow_Tensorforest_SplitPruningConfig()}
    set {_uniqueStorage()._pruningType = newValue}
  }
  /// Returns true if `pruningType` has been explicitly set.
  public var hasPruningType: Bool {return _storage._pruningType != nil}
  /// Clears the value of `pruningType`. Subsequent reads from it will return its default value.
  public mutating func clearPruningType() {_storage._pruningType = nil}

  public var finishType: Tensorflow_Tensorforest_SplitFinishConfig {
    get {return _storage._finishType ?? Tensorflow_Tensorforest_SplitFinishConfig()}
    set {_uniqueStorage()._finishType = newValue}
  }
  /// Returns true if `finishType` has been explicitly set.
  public var hasFinishType: Bool {return _storage._finishType != nil}
  /// Clears the value of `finishType`. Subsequent reads from it will return its default value.
  public mutating func clearFinishType() {_storage._finishType = nil}

  /// --------- Parameters that can't change by definition --------------- //
  public var numTrees: Int32 {
    get {return _storage._numTrees}
    set {_uniqueStorage()._numTrees = newValue}
  }

  public var maxNodes: Int32 {
    get {return _storage._maxNodes}
    set {_uniqueStorage()._maxNodes = newValue}
  }

  public var numFeatures: Int32 {
    get {return _storage._numFeatures}
    set {_uniqueStorage()._numFeatures = newValue}
  }

  public var inequalityTestType: Tensorflow_DecisionTrees_InequalityTest.TypeEnum {
    get {return _storage._inequalityTestType}
    set {_uniqueStorage()._inequalityTestType = newValue}
  }

  /// Some booleans controlling execution
  public var isRegression: Bool {
    get {return _storage._isRegression}
    set {_uniqueStorage()._isRegression = newValue}
  }

  public var dropFinalClass: Bool {
    get {return _storage._dropFinalClass}
    set {_uniqueStorage()._dropFinalClass = newValue}
  }

  public var collateExamples: Bool {
    get {return _storage._collateExamples}
    set {_uniqueStorage()._collateExamples = newValue}
  }

  public var checkpointStats: Bool {
    get {return _storage._checkpointStats}
    set {_uniqueStorage()._checkpointStats = newValue}
  }

  public var useRunningStatsMethod: Bool {
    get {return _storage._useRunningStatsMethod}
    set {_uniqueStorage()._useRunningStatsMethod = newValue}
  }

  public var initializeAverageSplits: Bool {
    get {return _storage._initializeAverageSplits}
    set {_uniqueStorage()._initializeAverageSplits = newValue}
  }

  public var inferenceTreePaths: Bool {
    get {return _storage._inferenceTreePaths}
    set {_uniqueStorage()._inferenceTreePaths = newValue}
  }

  /// Number of classes (classification) or targets (regression)
  public var numOutputs: Int32 {
    get {return _storage._numOutputs}
    set {_uniqueStorage()._numOutputs = newValue}
  }

  /// --------- Parameters that could be depth-dependent --------------- //
  public var numSplitsToConsider: Tensorflow_Tensorforest_DepthDependentParam {
    get {return _storage._numSplitsToConsider ?? Tensorflow_Tensorforest_DepthDependentParam()}
    set {_uniqueStorage()._numSplitsToConsider = newValue}
  }
  /// Returns true if `numSplitsToConsider` has been explicitly set.
  public var hasNumSplitsToConsider: Bool {return _storage._numSplitsToConsider != nil}
  /// Clears the value of `numSplitsToConsider`. Subsequent reads from it will return its default value.
  public mutating func clearNumSplitsToConsider() {_storage._numSplitsToConsider = nil}

  public var splitAfterSamples: Tensorflow_Tensorforest_DepthDependentParam {
    get {return _storage._splitAfterSamples ?? Tensorflow_Tensorforest_DepthDependentParam()}
    set {_uniqueStorage()._splitAfterSamples = newValue}
  }
  /// Returns true if `splitAfterSamples` has been explicitly set.
  public var hasSplitAfterSamples: Bool {return _storage._splitAfterSamples != nil}
  /// Clears the value of `splitAfterSamples`. Subsequent reads from it will return its default value.
  public mutating func clearSplitAfterSamples() {_storage._splitAfterSamples = nil}

  public var dominateFraction: Tensorflow_Tensorforest_DepthDependentParam {
    get {return _storage._dominateFraction ?? Tensorflow_Tensorforest_DepthDependentParam()}
    set {_uniqueStorage()._dominateFraction = newValue}
  }
  /// Returns true if `dominateFraction` has been explicitly set.
  public var hasDominateFraction: Bool {return _storage._dominateFraction != nil}
  /// Clears the value of `dominateFraction`. Subsequent reads from it will return its default value.
  public mutating func clearDominateFraction() {_storage._dominateFraction = nil}

  public var minSplitSamples: Tensorflow_Tensorforest_DepthDependentParam {
    get {return _storage._minSplitSamples ?? Tensorflow_Tensorforest_DepthDependentParam()}
    set {_uniqueStorage()._minSplitSamples = newValue}
  }
  /// Returns true if `minSplitSamples` has been explicitly set.
  public var hasMinSplitSamples: Bool {return _storage._minSplitSamples != nil}
  /// Clears the value of `minSplitSamples`. Subsequent reads from it will return its default value.
  public mutating func clearMinSplitSamples() {_storage._minSplitSamples = nil}

  /// --------- Parameters for experimental features ---------------------- //
  public var graphDir: String {
    get {return _storage._graphDir}
    set {_uniqueStorage()._graphDir = newValue}
  }

  public var numSelectFeatures: Int32 {
    get {return _storage._numSelectFeatures}
    set {_uniqueStorage()._numSelectFeatures = newValue}
  }

  /// When using a FixedSizeSparseClassificationGrowStats, keep track of
  /// this many classes.
  public var numClassesToTrack: Int32 {
    get {return _storage._numClassesToTrack}
    set {_uniqueStorage()._numClassesToTrack = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._leafType)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._statsType)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._collectionType)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._pruningType)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._finishType)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._numTrees)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._maxNodes)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._isRegression)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._dropFinalClass)
        case 10: try decoder.decodeSingularBoolField(value: &_storage._collateExamples)
        case 11: try decoder.decodeSingularBoolField(value: &_storage._checkpointStats)
        case 12: try decoder.decodeSingularInt32Field(value: &_storage._numOutputs)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._numSplitsToConsider)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._splitAfterSamples)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._dominateFraction)
        case 16: try decoder.decodeSingularStringField(value: &_storage._graphDir)
        case 17: try decoder.decodeSingularInt32Field(value: &_storage._numSelectFeatures)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._minSplitSamples)
        case 19: try decoder.decodeSingularEnumField(value: &_storage._inequalityTestType)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._useRunningStatsMethod)
        case 21: try decoder.decodeSingularInt32Field(value: &_storage._numFeatures)
        case 22: try decoder.decodeSingularBoolField(value: &_storage._initializeAverageSplits)
        case 23: try decoder.decodeSingularBoolField(value: &_storage._inferenceTreePaths)
        case 24: try decoder.decodeSingularInt32Field(value: &_storage._numClassesToTrack)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._leafType != .modelDenseClassification {
        try visitor.visitSingularEnumField(value: _storage._leafType, fieldNumber: 1)
      }
      if _storage._statsType != .statsDenseGini {
        try visitor.visitSingularEnumField(value: _storage._statsType, fieldNumber: 2)
      }
      if _storage._collectionType != .collectionBasic {
        try visitor.visitSingularEnumField(value: _storage._collectionType, fieldNumber: 3)
      }
      if let v = _storage._pruningType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._finishType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._numTrees != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numTrees, fieldNumber: 6)
      }
      if _storage._maxNodes != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxNodes, fieldNumber: 7)
      }
      if _storage._isRegression != false {
        try visitor.visitSingularBoolField(value: _storage._isRegression, fieldNumber: 8)
      }
      if _storage._dropFinalClass != false {
        try visitor.visitSingularBoolField(value: _storage._dropFinalClass, fieldNumber: 9)
      }
      if _storage._collateExamples != false {
        try visitor.visitSingularBoolField(value: _storage._collateExamples, fieldNumber: 10)
      }
      if _storage._checkpointStats != false {
        try visitor.visitSingularBoolField(value: _storage._checkpointStats, fieldNumber: 11)
      }
      if _storage._numOutputs != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numOutputs, fieldNumber: 12)
      }
      if let v = _storage._numSplitsToConsider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._splitAfterSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._dominateFraction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if !_storage._graphDir.isEmpty {
        try visitor.visitSingularStringField(value: _storage._graphDir, fieldNumber: 16)
      }
      if _storage._numSelectFeatures != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numSelectFeatures, fieldNumber: 17)
      }
      if let v = _storage._minSplitSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if _storage._inequalityTestType != .lessOrEqual {
        try visitor.visitSingularEnumField(value: _storage._inequalityTestType, fieldNumber: 19)
      }
      if _storage._useRunningStatsMethod != false {
        try visitor.visitSingularBoolField(value: _storage._useRunningStatsMethod, fieldNumber: 20)
      }
      if _storage._numFeatures != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numFeatures, fieldNumber: 21)
      }
      if _storage._initializeAverageSplits != false {
        try visitor.visitSingularBoolField(value: _storage._initializeAverageSplits, fieldNumber: 22)
      }
      if _storage._inferenceTreePaths != false {
        try visitor.visitSingularBoolField(value: _storage._inferenceTreePaths, fieldNumber: 23)
      }
      if _storage._numClassesToTrack != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numClassesToTrack, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow.tensorforest"

extension Tensorflow_Tensorforest_LeafModelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODEL_DENSE_CLASSIFICATION"),
    1: .same(proto: "MODEL_SPARSE_CLASSIFICATION"),
    2: .same(proto: "MODEL_REGRESSION"),
    3: .same(proto: "MODEL_SPARSE_OR_DENSE_CLASSIFICATION"),
  ]
}

extension Tensorflow_Tensorforest_StatsModelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATS_DENSE_GINI"),
    1: .same(proto: "STATS_SPARSE_GINI"),
    2: .same(proto: "STATS_LEAST_SQUARES_REGRESSION"),
    3: .same(proto: "STATS_SPARSE_THEN_DENSE_GINI"),
    4: .same(proto: "STATS_FIXED_SIZE_SPARSE_GINI"),
  ]
}

extension Tensorflow_Tensorforest_SplitCollectionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COLLECTION_BASIC"),
    1: .same(proto: "GRAPH_RUNNER_COLLECTION"),
  ]
}

extension Tensorflow_Tensorforest_SplitPruningStrategyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPLIT_PRUNE_NONE"),
    1: .same(proto: "SPLIT_PRUNE_HALF"),
    2: .same(proto: "SPLIT_PRUNE_QUARTER"),
    3: .same(proto: "SPLIT_PRUNE_10_PERCENT"),
    4: .same(proto: "SPLIT_PRUNE_HOEFFDING"),
  ]
}

extension Tensorflow_Tensorforest_SplitFinishStrategyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPLIT_FINISH_BASIC"),
    2: .same(proto: "SPLIT_FINISH_DOMINATE_HOEFFDING"),
    3: .same(proto: "SPLIT_FINISH_DOMINATE_BOOTSTRAP"),
  ]
}

extension Tensorflow_Tensorforest_SplitPruningConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prune_every_samples"),
    2: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _pruneEverySamples: Tensorflow_Tensorforest_DepthDependentParam? = nil
    var _type: Tensorflow_Tensorforest_SplitPruningStrategyType = .splitPruneNone

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pruneEverySamples = source._pruneEverySamples
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tensorforest_SplitPruningConfig) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._pruneEverySamples != other_storage._pruneEverySamples {return false}
        if _storage._type != other_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tensorforest_SplitFinishConfig: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "check_every_steps"),
    2: .same(proto: "type"),
  ]

  fileprivate class _StorageClass {
    var _checkEverySteps: Tensorflow_Tensorforest_DepthDependentParam? = nil
    var _type: Tensorflow_Tensorforest_SplitFinishStrategyType = .splitFinishBasic

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _checkEverySteps = source._checkEverySteps
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tensorforest_SplitFinishConfig) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._checkEverySteps != other_storage._checkEverySteps {return false}
        if _storage._type != other_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tensorforest_LinearParam: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "slope"),
    2: .standard(proto: "y_intercept"),
    3: .standard(proto: "min_val"),
    4: .standard(proto: "max_val"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tensorforest_LinearParam) -> Bool {
    if self.slope != other.slope {return false}
    if self.yIntercept != other.yIntercept {return false}
    if self.minVal != other.minVal {return false}
    if self.maxVal != other.maxVal {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tensorforest_ExponentialParam: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bias"),
    2: .same(proto: "base"),
    3: .same(proto: "multiplier"),
    4: .standard(proto: "depth_multiplier"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tensorforest_ExponentialParam) -> Bool {
    if self.bias != other.bias {return false}
    if self.base != other.base {return false}
    if self.multiplier != other.multiplier {return false}
    if self.depthMultiplier != other.depthMultiplier {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tensorforest_ThresholdParam: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "on_value"),
    2: .standard(proto: "off_value"),
    3: .same(proto: "threshold"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tensorforest_ThresholdParam) -> Bool {
    if self.onValue != other.onValue {return false}
    if self.offValue != other.offValue {return false}
    if self.threshold != other.threshold {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tensorforest_DepthDependentParam: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "constant_value"),
    2: .same(proto: "linear"),
    3: .same(proto: "exponential"),
    4: .same(proto: "threshold"),
  ]

  fileprivate class _StorageClass {
    var _paramType: Tensorflow_Tensorforest_DepthDependentParam.OneOf_ParamType?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _paramType = source._paramType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tensorforest_DepthDependentParam) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._paramType != other_storage._paramType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tensorforest_TensorForestParams: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaf_type"),
    2: .standard(proto: "stats_type"),
    3: .standard(proto: "collection_type"),
    4: .standard(proto: "pruning_type"),
    5: .standard(proto: "finish_type"),
    6: .standard(proto: "num_trees"),
    7: .standard(proto: "max_nodes"),
    21: .standard(proto: "num_features"),
    19: .standard(proto: "inequality_test_type"),
    8: .standard(proto: "is_regression"),
    9: .standard(proto: "drop_final_class"),
    10: .standard(proto: "collate_examples"),
    11: .standard(proto: "checkpoint_stats"),
    20: .standard(proto: "use_running_stats_method"),
    22: .standard(proto: "initialize_average_splits"),
    23: .standard(proto: "inference_tree_paths"),
    12: .standard(proto: "num_outputs"),
    13: .standard(proto: "num_splits_to_consider"),
    14: .standard(proto: "split_after_samples"),
    15: .standard(proto: "dominate_fraction"),
    18: .standard(proto: "min_split_samples"),
    16: .standard(proto: "graph_dir"),
    17: .standard(proto: "num_select_features"),
    24: .standard(proto: "num_classes_to_track"),
  ]

  fileprivate class _StorageClass {
    var _leafType: Tensorflow_Tensorforest_LeafModelType = .modelDenseClassification
    var _statsType: Tensorflow_Tensorforest_StatsModelType = .statsDenseGini
    var _collectionType: Tensorflow_Tensorforest_SplitCollectionType = .collectionBasic
    var _pruningType: Tensorflow_Tensorforest_SplitPruningConfig? = nil
    var _finishType: Tensorflow_Tensorforest_SplitFinishConfig? = nil
    var _numTrees: Int32 = 0
    var _maxNodes: Int32 = 0
    var _numFeatures: Int32 = 0
    var _inequalityTestType: Tensorflow_DecisionTrees_InequalityTest.TypeEnum = .lessOrEqual
    var _isRegression: Bool = false
    var _dropFinalClass: Bool = false
    var _collateExamples: Bool = false
    var _checkpointStats: Bool = false
    var _useRunningStatsMethod: Bool = false
    var _initializeAverageSplits: Bool = false
    var _inferenceTreePaths: Bool = false
    var _numOutputs: Int32 = 0
    var _numSplitsToConsider: Tensorflow_Tensorforest_DepthDependentParam? = nil
    var _splitAfterSamples: Tensorflow_Tensorforest_DepthDependentParam? = nil
    var _dominateFraction: Tensorflow_Tensorforest_DepthDependentParam? = nil
    var _minSplitSamples: Tensorflow_Tensorforest_DepthDependentParam? = nil
    var _graphDir: String = String()
    var _numSelectFeatures: Int32 = 0
    var _numClassesToTrack: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _leafType = source._leafType
      _statsType = source._statsType
      _collectionType = source._collectionType
      _pruningType = source._pruningType
      _finishType = source._finishType
      _numTrees = source._numTrees
      _maxNodes = source._maxNodes
      _numFeatures = source._numFeatures
      _inequalityTestType = source._inequalityTestType
      _isRegression = source._isRegression
      _dropFinalClass = source._dropFinalClass
      _collateExamples = source._collateExamples
      _checkpointStats = source._checkpointStats
      _useRunningStatsMethod = source._useRunningStatsMethod
      _initializeAverageSplits = source._initializeAverageSplits
      _inferenceTreePaths = source._inferenceTreePaths
      _numOutputs = source._numOutputs
      _numSplitsToConsider = source._numSplitsToConsider
      _splitAfterSamples = source._splitAfterSamples
      _dominateFraction = source._dominateFraction
      _minSplitSamples = source._minSplitSamples
      _graphDir = source._graphDir
      _numSelectFeatures = source._numSelectFeatures
      _numClassesToTrack = source._numClassesToTrack
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tensorforest_TensorForestParams) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._leafType != other_storage._leafType {return false}
        if _storage._statsType != other_storage._statsType {return false}
        if _storage._collectionType != other_storage._collectionType {return false}
        if _storage._pruningType != other_storage._pruningType {return false}
        if _storage._finishType != other_storage._finishType {return false}
        if _storage._numTrees != other_storage._numTrees {return false}
        if _storage._maxNodes != other_storage._maxNodes {return false}
        if _storage._numFeatures != other_storage._numFeatures {return false}
        if _storage._inequalityTestType != other_storage._inequalityTestType {return false}
        if _storage._isRegression != other_storage._isRegression {return false}
        if _storage._dropFinalClass != other_storage._dropFinalClass {return false}
        if _storage._collateExamples != other_storage._collateExamples {return false}
        if _storage._checkpointStats != other_storage._checkpointStats {return false}
        if _storage._useRunningStatsMethod != other_storage._useRunningStatsMethod {return false}
        if _storage._initializeAverageSplits != other_storage._initializeAverageSplits {return false}
        if _storage._inferenceTreePaths != other_storage._inferenceTreePaths {return false}
        if _storage._numOutputs != other_storage._numOutputs {return false}
        if _storage._numSplitsToConsider != other_storage._numSplitsToConsider {return false}
        if _storage._splitAfterSamples != other_storage._splitAfterSamples {return false}
        if _storage._dominateFraction != other_storage._dominateFraction {return false}
        if _storage._minSplitSamples != other_storage._minSplitSamples {return false}
        if _storage._graphDir != other_storage._graphDir {return false}
        if _storage._numSelectFeatures != other_storage._numSelectFeatures {return false}
        if _storage._numClassesToTrack != other_storage._numClassesToTrack {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
