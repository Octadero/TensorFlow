// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/contrib/makefile/downloads/protobuf/src/google/protobuf/compiler/cpp/cpp_test_bad_identifiers.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Protocol Buffers - Google's data interchange format
// Copyright 2008 Google Inc.  All rights reserved.
// https://developers.google.com/protocol-buffers/
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Author: kenton@google.com (Kenton Varda)
//  Based on original Protocol Buffers design by
//  Sanjay Ghemawat, Jeff Dean, and others.
//
// This file tests that various identifiers work as field and type names even
// though the same identifiers are used internally by the C++ code generator.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// NO_PROTO3
public enum ProtobufUnittest_ConflictingEnum: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// NO_PROTO3
  case notEq // = 1

  /// NO_PROTO3
  case volatile // = 2

  /// NO_PROTO3
  case `return` // = 3

  public init() {
    self = .notEq
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .notEq
    case 2: self = .volatile
    case 3: self = .return
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .notEq: return 1
    case .volatile: return 2
    case .return: return 3
    }
  }

}

/// Test that fields can have names like "input" and "i" which are also used
/// internally by the code generator for local variables.
public struct ProtobufUnittest_TestConflictingSymbolNames: SwiftProtobuf.ExtensibleMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var input: Int32 {
    get {return _storage._input ?? 0}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  public var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  public mutating func clearInput() {_storage._input = nil}

  public var output: Int32 {
    get {return _storage._output ?? 0}
    set {_uniqueStorage()._output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return _storage._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {_storage._output = nil}

  public var length: String {
    get {return _storage._length ?? String()}
    set {_uniqueStorage()._length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  public var hasLength: Bool {return _storage._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  public mutating func clearLength() {_storage._length = nil}

  public var i: [Int32] {
    get {return _storage._i}
    set {_uniqueStorage()._i = newValue}
  }

  public var newElement: [String] {
    get {return _storage._newElement}
    set {_uniqueStorage()._newElement = newValue}
  }

  public var totalSize: Int32 {
    get {return _storage._totalSize ?? 0}
    set {_uniqueStorage()._totalSize = newValue}
  }
  /// Returns true if `totalSize` has been explicitly set.
  public var hasTotalSize: Bool {return _storage._totalSize != nil}
  /// Clears the value of `totalSize`. Subsequent reads from it will return its default value.
  public mutating func clearTotalSize() {_storage._totalSize = nil}

  public var tag: Int32 {
    get {return _storage._tag ?? 0}
    set {_uniqueStorage()._tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  public var hasTag: Bool {return _storage._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  public mutating func clearTag() {_storage._tag = nil}

  public var source: Int32 {
    get {return _storage._source ?? 0}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {_storage._source = nil}

  public var value: Int32 {
    get {return _storage._value ?? 0}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_storage._value = nil}

  public var file: Int32 {
    get {return _storage._file ?? 0}
    set {_uniqueStorage()._file = newValue}
  }
  /// Returns true if `file` has been explicitly set.
  public var hasFile: Bool {return _storage._file != nil}
  /// Clears the value of `file`. Subsequent reads from it will return its default value.
  public mutating func clearFile() {_storage._file = nil}

  public var from: Int32 {
    get {return _storage._from ?? 0}
    set {_uniqueStorage()._from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return _storage._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {_storage._from = nil}

  public var handleUninterpreted: Int32 {
    get {return _storage._handleUninterpreted ?? 0}
    set {_uniqueStorage()._handleUninterpreted = newValue}
  }
  /// Returns true if `handleUninterpreted` has been explicitly set.
  public var hasHandleUninterpreted: Bool {return _storage._handleUninterpreted != nil}
  /// Clears the value of `handleUninterpreted`. Subsequent reads from it will return its default value.
  public mutating func clearHandleUninterpreted() {_storage._handleUninterpreted = nil}

  public var index: [Int32] {
    get {return _storage._index}
    set {_uniqueStorage()._index = newValue}
  }

  public var controller: Int32 {
    get {return _storage._controller ?? 0}
    set {_uniqueStorage()._controller = newValue}
  }
  /// Returns true if `controller` has been explicitly set.
  public var hasController: Bool {return _storage._controller != nil}
  /// Clears the value of `controller`. Subsequent reads from it will return its default value.
  public mutating func clearController() {_storage._controller = nil}

  public var alreadyHere: Int32 {
    get {return _storage._alreadyHere ?? 0}
    set {_uniqueStorage()._alreadyHere = newValue}
  }
  /// Returns true if `alreadyHere` has been explicitly set.
  public var hasAlreadyHere: Bool {return _storage._alreadyHere != nil}
  /// Clears the value of `alreadyHere`. Subsequent reads from it will return its default value.
  public mutating func clearAlreadyHere() {_storage._alreadyHere = nil}

  public var uint32: UInt32 {
    get {return _storage._uint32 ?? 0}
    set {_uniqueStorage()._uint32 = newValue}
  }
  /// Returns true if `uint32` has been explicitly set.
  public var hasUint32: Bool {return _storage._uint32 != nil}
  /// Clears the value of `uint32`. Subsequent reads from it will return its default value.
  public mutating func clearUint32() {_storage._uint32 = nil}

  public var uint64: UInt64 {
    get {return _storage._uint64 ?? 0}
    set {_uniqueStorage()._uint64 = newValue}
  }
  /// Returns true if `uint64` has been explicitly set.
  public var hasUint64: Bool {return _storage._uint64 != nil}
  /// Clears the value of `uint64`. Subsequent reads from it will return its default value.
  public mutating func clearUint64() {_storage._uint64 = nil}

  public var string: String {
    get {return _storage._string ?? String()}
    set {_uniqueStorage()._string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  public var hasString: Bool {return _storage._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  public mutating func clearString() {_storage._string = nil}

  public var memset: Int32 {
    get {return _storage._memset ?? 0}
    set {_uniqueStorage()._memset = newValue}
  }
  /// Returns true if `memset` has been explicitly set.
  public var hasMemset: Bool {return _storage._memset != nil}
  /// Clears the value of `memset`. Subsequent reads from it will return its default value.
  public mutating func clearMemset() {_storage._memset = nil}

  public var int32: Int32 {
    get {return _storage._int32 ?? 0}
    set {_uniqueStorage()._int32 = newValue}
  }
  /// Returns true if `int32` has been explicitly set.
  public var hasInt32: Bool {return _storage._int32 != nil}
  /// Clears the value of `int32`. Subsequent reads from it will return its default value.
  public mutating func clearInt32() {_storage._int32 = nil}

  public var int64: Int64 {
    get {return _storage._int64 ?? 0}
    set {_uniqueStorage()._int64 = newValue}
  }
  /// Returns true if `int64` has been explicitly set.
  public var hasInt64: Bool {return _storage._int64 != nil}
  /// Clears the value of `int64`. Subsequent reads from it will return its default value.
  public mutating func clearInt64() {_storage._int64 = nil}

  public var cachedSize: UInt32 {
    get {return _storage._cachedSize ?? 0}
    set {_uniqueStorage()._cachedSize = newValue}
  }
  /// Returns true if `cachedSize` has been explicitly set.
  public var hasCachedSize: Bool {return _storage._cachedSize != nil}
  /// Clears the value of `cachedSize`. Subsequent reads from it will return its default value.
  public mutating func clearCachedSize() {_storage._cachedSize = nil}

  public var extensions: UInt32 {
    get {return _storage._extensions ?? 0}
    set {_uniqueStorage()._extensions = newValue}
  }
  /// Returns true if `extensions` has been explicitly set.
  public var hasExtensions: Bool {return _storage._extensions != nil}
  /// Clears the value of `extensions`. Subsequent reads from it will return its default value.
  public mutating func clearExtensions() {_storage._extensions = nil}

  public var bit: UInt32 {
    get {return _storage._bit ?? 0}
    set {_uniqueStorage()._bit = newValue}
  }
  /// Returns true if `bit` has been explicitly set.
  public var hasBit: Bool {return _storage._bit != nil}
  /// Clears the value of `bit`. Subsequent reads from it will return its default value.
  public mutating func clearBit() {_storage._bit = nil}

  public var bits: UInt32 {
    get {return _storage._bits ?? 0}
    set {_uniqueStorage()._bits = newValue}
  }
  /// Returns true if `bits` has been explicitly set.
  public var hasBits: Bool {return _storage._bits != nil}
  /// Clears the value of `bits`. Subsequent reads from it will return its default value.
  public mutating func clearBits() {_storage._bits = nil}

  public var offsets: UInt32 {
    get {return _storage._offsets ?? 0}
    set {_uniqueStorage()._offsets = newValue}
  }
  /// Returns true if `offsets` has been explicitly set.
  public var hasOffsets: Bool {return _storage._offsets != nil}
  /// Clears the value of `offsets`. Subsequent reads from it will return its default value.
  public mutating func clearOffsets() {_storage._offsets = nil}

  public var reflection: UInt32 {
    get {return _storage._reflection ?? 0}
    set {_uniqueStorage()._reflection = newValue}
  }
  /// Returns true if `reflection` has been explicitly set.
  public var hasReflection: Bool {return _storage._reflection != nil}
  /// Clears the value of `reflection`. Subsequent reads from it will return its default value.
  public mutating func clearReflection() {_storage._reflection = nil}

  public var someCord: String {
    get {return _storage._someCord ?? String()}
    set {_uniqueStorage()._someCord = newValue}
  }
  /// Returns true if `someCord` has been explicitly set.
  public var hasSomeCord: Bool {return _storage._someCord != nil}
  /// Clears the value of `someCord`. Subsequent reads from it will return its default value.
  public mutating func clearSomeCord() {_storage._someCord = nil}

  public var someStringPiece: String {
    get {return _storage._someStringPiece ?? String()}
    set {_uniqueStorage()._someStringPiece = newValue}
  }
  /// Returns true if `someStringPiece` has been explicitly set.
  public var hasSomeStringPiece: Bool {return _storage._someStringPiece != nil}
  /// Clears the value of `someStringPiece`. Subsequent reads from it will return its default value.
  public mutating func clearSomeStringPiece() {_storage._someStringPiece = nil}

  /// Some keywords.
  public var int: UInt32 {
    get {return _storage._int ?? 0}
    set {_uniqueStorage()._int = newValue}
  }
  /// Returns true if `int` has been explicitly set.
  public var hasInt: Bool {return _storage._int != nil}
  /// Clears the value of `int`. Subsequent reads from it will return its default value.
  public mutating func clearInt() {_storage._int = nil}

  public var friend: UInt32 {
    get {return _storage._friend ?? 0}
    set {_uniqueStorage()._friend = newValue}
  }
  /// Returns true if `friend` has been explicitly set.
  public var hasFriend: Bool {return _storage._friend != nil}
  /// Clears the value of `friend`. Subsequent reads from it will return its default value.
  public mutating func clearFriend() {_storage._friend = nil}

  public var `class`: UInt32 {
    get {return _storage._class ?? 0}
    set {_uniqueStorage()._class = newValue}
  }
  /// Returns true if ``class`` has been explicitly set.
  public var hasClass: Bool {return _storage._class != nil}
  /// Clears the value of ``class``. Subsequent reads from it will return its default value.
  public mutating func clearClass() {_storage._class = nil}

  public var typedecl: UInt32 {
    get {return _storage._typedecl ?? 0}
    set {_uniqueStorage()._typedecl = newValue}
  }
  /// Returns true if `typedecl` has been explicitly set.
  public var hasTypedecl: Bool {return _storage._typedecl != nil}
  /// Clears the value of `typedecl`. Subsequent reads from it will return its default value.
  public mutating func clearTypedecl() {_storage._typedecl = nil}

  public var auto: UInt32 {
    get {return _storage._auto ?? 0}
    set {_uniqueStorage()._auto = newValue}
  }
  /// Returns true if `auto` has been explicitly set.
  public var hasAuto: Bool {return _storage._auto != nil}
  /// Clears the value of `auto`. Subsequent reads from it will return its default value.
  public mutating func clearAuto() {_storage._auto = nil}

  public var `do`: ProtobufUnittest_TestConflictingSymbolNames.DO {
    get {return _storage._do ?? ProtobufUnittest_TestConflictingSymbolNames.DO()}
    set {_uniqueStorage()._do = newValue}
  }
  /// Returns true if ``do`` has been explicitly set.
  public var hasDo: Bool {return _storage._do != nil}
  /// Clears the value of ``do``. Subsequent reads from it will return its default value.
  public mutating func clearDo() {_storage._do = nil}

  /// Some template parameter names for extensions.
  public var fieldType: Int32 {
    get {return _storage._fieldType ?? 0}
    set {_uniqueStorage()._fieldType = newValue}
  }
  /// Returns true if `fieldType` has been explicitly set.
  public var hasFieldType: Bool {return _storage._fieldType != nil}
  /// Clears the value of `fieldType`. Subsequent reads from it will return its default value.
  public mutating func clearFieldType() {_storage._fieldType = nil}

  public var isPacked: Bool {
    get {return _storage._isPacked ?? false}
    set {_uniqueStorage()._isPacked = newValue}
  }
  /// Returns true if `isPacked` has been explicitly set.
  public var hasIsPacked: Bool {return _storage._isPacked != nil}
  /// Clears the value of `isPacked`. Subsequent reads from it will return its default value.
  public mutating func clearIsPacked() {_storage._isPacked = nil}

  /// test conflicting release_$name$. "length" and "do" field in this message
  /// must remain string or message fields to make the test valid.
  public var releaseLength: String {
    get {return _storage._releaseLength ?? String()}
    set {_uniqueStorage()._releaseLength = newValue}
  }
  /// Returns true if `releaseLength` has been explicitly set.
  public var hasReleaseLength: Bool {return _storage._releaseLength != nil}
  /// Clears the value of `releaseLength`. Subsequent reads from it will return its default value.
  public mutating func clearReleaseLength() {_storage._releaseLength = nil}

  /// A more extreme case, the field name "do" here is a keyword, which will be
  /// escaped to "do_" already. Test there is no conflict even with escaped field
  /// names.
  public var releaseDo: ProtobufUnittest_TestConflictingSymbolNames.DO {
    get {return _storage._releaseDo ?? ProtobufUnittest_TestConflictingSymbolNames.DO()}
    set {_uniqueStorage()._releaseDo = newValue}
  }
  /// Returns true if `releaseDo` has been explicitly set.
  public var hasReleaseDo: Bool {return _storage._releaseDo != nil}
  /// Clears the value of `releaseDo`. Subsequent reads from it will return its default value.
  public mutating func clearReleaseDo() {_storage._releaseDo = nil}

  /// For clashing local variables in Serialize and ByteSize calculation.
  public var target: String {
    get {return _storage._target ?? String()}
    set {_uniqueStorage()._target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return _storage._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {_storage._target = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TestEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case foo // = 0

    public init() {
      self = .foo
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .foo
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .foo: return 0
      }
    }

  }

  public struct BuildDescriptors {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TypeTraits {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Data1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: [Int32] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Data2 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: [ProtobufUnittest_TestConflictingSymbolNames.TestEnum] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Data3 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Data4 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: [ProtobufUnittest_TestConflictingSymbolNames.Data4] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Data5 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Data6 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Cord {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct StringPiece {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The generator used to #define a macro called "DO" inside the .cc file.
  public struct DO {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NO_PROTO3
public struct ProtobufUnittest_TestConflictingSymbolNamesExtension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NO_PROTO3
public struct ProtobufUnittest_TestConflictingEnumNames {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// NO_PROTO3
  public var conflictingEnum: ProtobufUnittest_TestConflictingEnumNames.NestedConflictingEnum {
    get {return _conflictingEnum ?? .and}
    set {_conflictingEnum = newValue}
  }
  /// Returns true if `conflictingEnum` has been explicitly set.
  public var hasConflictingEnum: Bool {return self._conflictingEnum != nil}
  /// Clears the value of `conflictingEnum`. Subsequent reads from it will return its default value.
  public mutating func clearConflictingEnum() {self._conflictingEnum = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// NO_PROTO3
  public enum NestedConflictingEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// NO_PROTO3
    case and // = 1

    /// NO_PROTO3
    case `class` // = 2

    /// NO_PROTO3
    case int // = 3

    /// NO_PROTO3
    case typedef // = 4

    /// NO_PROTO3
    case xor // = 5

    public init() {
      self = .and
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .and
      case 2: self = .class
      case 3: self = .int
      case 4: self = .typedef
      case 5: self = .xor
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .and: return 1
      case .class: return 2
      case .int: return 3
      case .typedef: return 4
      case .xor: return 5
      }
    }

  }

  public init() {}

  fileprivate var _conflictingEnum: ProtobufUnittest_TestConflictingEnumNames.NestedConflictingEnum? = nil
}

public struct ProtobufUnittest_DummyMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message names that could conflict.
public struct ProtobufUnittest_Shutdown {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ProtobufUnittest_TableStruct {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Extension support defined in cpp_test_bad_identifiers.proto.

extension ProtobufUnittest_TestConflictingSymbolNames {

  /// NO_PROTO3
  public var ProtobufUnittest_TestConflictingSymbolNamesExtension_repeatedInt32Ext: [Int32] {
    get {return getExtensionValue(ext: ProtobufUnittest_TestConflictingSymbolNamesExtension.Extensions.repeated_int32_ext) ?? []}
    set {setExtensionValue(ext: ProtobufUnittest_TestConflictingSymbolNamesExtension.Extensions.repeated_int32_ext, value: newValue)}
  }
  /// Returns true if extension `ProtobufUnittest_TestConflictingSymbolNamesExtension.Extensions.repeated_int32_ext`
  /// has been explicitly set.
  public var hasProtobufUnittest_TestConflictingSymbolNamesExtension_repeatedInt32Ext: Bool {
    return hasExtensionValue(ext: ProtobufUnittest_TestConflictingSymbolNamesExtension.Extensions.repeated_int32_ext)
  }
  /// Clears the value of extension `ProtobufUnittest_TestConflictingSymbolNamesExtension.Extensions.repeated_int32_ext`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearProtobufUnittest_TestConflictingSymbolNamesExtension_repeatedInt32Ext() {
    clearExtensionValue(ext: ProtobufUnittest_TestConflictingSymbolNamesExtension.Extensions.repeated_int32_ext)
  }

}

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let ProtobufUnittest_CppTestBadIdentifiers_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  ProtobufUnittest_TestConflictingSymbolNamesExtension.Extensions.repeated_int32_ext
]

extension ProtobufUnittest_TestConflictingSymbolNamesExtension {
  enum Extensions {
    /// NO_PROTO3
    static let repeated_int32_ext = SwiftProtobuf.MessageExtension<SwiftProtobuf.PackedExtensionField<SwiftProtobuf.ProtobufInt32>, ProtobufUnittest_TestConflictingSymbolNames>(
      _protobuf_fieldNumber: 20423638,
      fieldName: "protobuf_unittest.TestConflictingSymbolNamesExtension.repeated_int32_ext"
    )
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protobuf_unittest"

extension ProtobufUnittest_ConflictingEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NOT_EQ"),
    2: .same(proto: "volatile"),
    3: .same(proto: "return"),
  ]
}

extension ProtobufUnittest_TestConflictingSymbolNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestConflictingSymbolNames"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "output"),
    3: .same(proto: "length"),
    4: .same(proto: "i"),
    5: .standard(proto: "new_element"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "tag"),
    8: .same(proto: "source"),
    9: .same(proto: "value"),
    10: .same(proto: "file"),
    11: .same(proto: "from"),
    12: .standard(proto: "handle_uninterpreted"),
    13: .same(proto: "index"),
    14: .same(proto: "controller"),
    15: .standard(proto: "already_here"),
    16: .same(proto: "uint32"),
    17: .same(proto: "uint64"),
    18: .same(proto: "string"),
    19: .same(proto: "memset"),
    20: .same(proto: "int32"),
    21: .same(proto: "int64"),
    22: .standard(proto: "cached_size"),
    23: .same(proto: "extensions"),
    24: .same(proto: "bit"),
    25: .same(proto: "bits"),
    26: .same(proto: "offsets"),
    27: .same(proto: "reflection"),
    28: .standard(proto: "some_cord"),
    29: .standard(proto: "some_string_piece"),
    30: .same(proto: "int"),
    31: .same(proto: "friend"),
    37: .same(proto: "class"),
    39: .same(proto: "typedecl"),
    40: .same(proto: "auto"),
    32: .same(proto: "do"),
    33: .standard(proto: "field_type"),
    34: .standard(proto: "is_packed"),
    35: .standard(proto: "release_length"),
    36: .standard(proto: "release_do"),
    38: .same(proto: "target"),
  ]

  fileprivate class _StorageClass {
    var _input: Int32? = nil
    var _output: Int32? = nil
    var _length: String? = nil
    var _i: [Int32] = []
    var _newElement: [String] = []
    var _totalSize: Int32? = nil
    var _tag: Int32? = nil
    var _source: Int32? = nil
    var _value: Int32? = nil
    var _file: Int32? = nil
    var _from: Int32? = nil
    var _handleUninterpreted: Int32? = nil
    var _index: [Int32] = []
    var _controller: Int32? = nil
    var _alreadyHere: Int32? = nil
    var _uint32: UInt32? = nil
    var _uint64: UInt64? = nil
    var _string: String? = nil
    var _memset: Int32? = nil
    var _int32: Int32? = nil
    var _int64: Int64? = nil
    var _cachedSize: UInt32? = nil
    var _extensions: UInt32? = nil
    var _bit: UInt32? = nil
    var _bits: UInt32? = nil
    var _offsets: UInt32? = nil
    var _reflection: UInt32? = nil
    var _someCord: String? = nil
    var _someStringPiece: String? = nil
    var _int: UInt32? = nil
    var _friend: UInt32? = nil
    var _class: UInt32? = nil
    var _typedecl: UInt32? = nil
    var _auto: UInt32? = nil
    var _do: ProtobufUnittest_TestConflictingSymbolNames.DO? = nil
    var _fieldType: Int32? = nil
    var _isPacked: Bool? = nil
    var _releaseLength: String? = nil
    var _releaseDo: ProtobufUnittest_TestConflictingSymbolNames.DO? = nil
    var _target: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _input = source._input
      _output = source._output
      _length = source._length
      _i = source._i
      _newElement = source._newElement
      _totalSize = source._totalSize
      _tag = source._tag
      _source = source._source
      _value = source._value
      _file = source._file
      _from = source._from
      _handleUninterpreted = source._handleUninterpreted
      _index = source._index
      _controller = source._controller
      _alreadyHere = source._alreadyHere
      _uint32 = source._uint32
      _uint64 = source._uint64
      _string = source._string
      _memset = source._memset
      _int32 = source._int32
      _int64 = source._int64
      _cachedSize = source._cachedSize
      _extensions = source._extensions
      _bit = source._bit
      _bits = source._bits
      _offsets = source._offsets
      _reflection = source._reflection
      _someCord = source._someCord
      _someStringPiece = source._someStringPiece
      _int = source._int
      _friend = source._friend
      _class = source._class
      _typedecl = source._typedecl
      _auto = source._auto
      _do = source._do
      _fieldType = source._fieldType
      _isPacked = source._isPacked
      _releaseLength = source._releaseLength
      _releaseDo = source._releaseDo
      _target = source._target
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt32Field(value: &_storage._input)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._output)
        case 3: try decoder.decodeSingularStringField(value: &_storage._length)
        case 4: try decoder.decodeRepeatedInt32Field(value: &_storage._i)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._newElement)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._totalSize)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._tag)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._source)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._value)
        case 10: try decoder.decodeSingularInt32Field(value: &_storage._file)
        case 11: try decoder.decodeSingularInt32Field(value: &_storage._from)
        case 12: try decoder.decodeSingularInt32Field(value: &_storage._handleUninterpreted)
        case 13: try decoder.decodeRepeatedInt32Field(value: &_storage._index)
        case 14: try decoder.decodeSingularInt32Field(value: &_storage._controller)
        case 15: try decoder.decodeSingularInt32Field(value: &_storage._alreadyHere)
        case 16: try decoder.decodeSingularUInt32Field(value: &_storage._uint32)
        case 17: try decoder.decodeSingularUInt64Field(value: &_storage._uint64)
        case 18: try decoder.decodeSingularStringField(value: &_storage._string)
        case 19: try decoder.decodeSingularInt32Field(value: &_storage._memset)
        case 20: try decoder.decodeSingularInt32Field(value: &_storage._int32)
        case 21: try decoder.decodeSingularInt64Field(value: &_storage._int64)
        case 22: try decoder.decodeSingularUInt32Field(value: &_storage._cachedSize)
        case 23: try decoder.decodeSingularUInt32Field(value: &_storage._extensions)
        case 24: try decoder.decodeSingularUInt32Field(value: &_storage._bit)
        case 25: try decoder.decodeSingularUInt32Field(value: &_storage._bits)
        case 26: try decoder.decodeSingularUInt32Field(value: &_storage._offsets)
        case 27: try decoder.decodeSingularUInt32Field(value: &_storage._reflection)
        case 28: try decoder.decodeSingularStringField(value: &_storage._someCord)
        case 29: try decoder.decodeSingularStringField(value: &_storage._someStringPiece)
        case 30: try decoder.decodeSingularUInt32Field(value: &_storage._int)
        case 31: try decoder.decodeSingularUInt32Field(value: &_storage._friend)
        case 32: try decoder.decodeSingularMessageField(value: &_storage._do)
        case 33: try decoder.decodeSingularInt32Field(value: &_storage._fieldType)
        case 34: try decoder.decodeSingularBoolField(value: &_storage._isPacked)
        case 35: try decoder.decodeSingularStringField(value: &_storage._releaseLength)
        case 36: try decoder.decodeSingularMessageField(value: &_storage._releaseDo)
        case 37: try decoder.decodeSingularUInt32Field(value: &_storage._class)
        case 38: try decoder.decodeSingularStringField(value: &_storage._target)
        case 39: try decoder.decodeSingularUInt32Field(value: &_storage._typedecl)
        case 40: try decoder.decodeSingularUInt32Field(value: &_storage._auto)
        case 1000..<536870912:
          try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: ProtobufUnittest_TestConflictingSymbolNames.self, fieldNumber: fieldNumber)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._input {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      }
      if let v = _storage._output {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      }
      if let v = _storage._length {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if !_storage._i.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._i, fieldNumber: 4)
      }
      if !_storage._newElement.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._newElement, fieldNumber: 5)
      }
      if let v = _storage._totalSize {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      }
      if let v = _storage._tag {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._source {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      }
      if let v = _storage._value {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._file {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      }
      if let v = _storage._from {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      }
      if let v = _storage._handleUninterpreted {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      }
      if !_storage._index.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._index, fieldNumber: 13)
      }
      if let v = _storage._controller {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      }
      if let v = _storage._alreadyHere {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      }
      if let v = _storage._uint32 {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
      }
      if let v = _storage._uint64 {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 17)
      }
      if let v = _storage._string {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      }
      if let v = _storage._memset {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 19)
      }
      if let v = _storage._int32 {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 20)
      }
      if let v = _storage._int64 {
        try visitor.visitSingularInt64Field(value: v, fieldNumber: 21)
      }
      if let v = _storage._cachedSize {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 22)
      }
      if let v = _storage._extensions {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      }
      if let v = _storage._bit {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 24)
      }
      if let v = _storage._bits {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 25)
      }
      if let v = _storage._offsets {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 26)
      }
      if let v = _storage._reflection {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 27)
      }
      if let v = _storage._someCord {
        try visitor.visitSingularStringField(value: v, fieldNumber: 28)
      }
      if let v = _storage._someStringPiece {
        try visitor.visitSingularStringField(value: v, fieldNumber: 29)
      }
      if let v = _storage._int {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 30)
      }
      if let v = _storage._friend {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 31)
      }
      if let v = _storage._do {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._fieldType {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 33)
      }
      if let v = _storage._isPacked {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 34)
      }
      if let v = _storage._releaseLength {
        try visitor.visitSingularStringField(value: v, fieldNumber: 35)
      }
      if let v = _storage._releaseDo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }
      if let v = _storage._class {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 37)
      }
      if let v = _storage._target {
        try visitor.visitSingularStringField(value: v, fieldNumber: 38)
      }
      if let v = _storage._typedecl {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 39)
      }
      if let v = _storage._auto {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 40)
      }
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 536870912)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._input != other_storage._input {return false}
        if _storage._output != other_storage._output {return false}
        if _storage._length != other_storage._length {return false}
        if _storage._i != other_storage._i {return false}
        if _storage._newElement != other_storage._newElement {return false}
        if _storage._totalSize != other_storage._totalSize {return false}
        if _storage._tag != other_storage._tag {return false}
        if _storage._source != other_storage._source {return false}
        if _storage._value != other_storage._value {return false}
        if _storage._file != other_storage._file {return false}
        if _storage._from != other_storage._from {return false}
        if _storage._handleUninterpreted != other_storage._handleUninterpreted {return false}
        if _storage._index != other_storage._index {return false}
        if _storage._controller != other_storage._controller {return false}
        if _storage._alreadyHere != other_storage._alreadyHere {return false}
        if _storage._uint32 != other_storage._uint32 {return false}
        if _storage._uint64 != other_storage._uint64 {return false}
        if _storage._string != other_storage._string {return false}
        if _storage._memset != other_storage._memset {return false}
        if _storage._int32 != other_storage._int32 {return false}
        if _storage._int64 != other_storage._int64 {return false}
        if _storage._cachedSize != other_storage._cachedSize {return false}
        if _storage._extensions != other_storage._extensions {return false}
        if _storage._bit != other_storage._bit {return false}
        if _storage._bits != other_storage._bits {return false}
        if _storage._offsets != other_storage._offsets {return false}
        if _storage._reflection != other_storage._reflection {return false}
        if _storage._someCord != other_storage._someCord {return false}
        if _storage._someStringPiece != other_storage._someStringPiece {return false}
        if _storage._int != other_storage._int {return false}
        if _storage._friend != other_storage._friend {return false}
        if _storage._class != other_storage._class {return false}
        if _storage._typedecl != other_storage._typedecl {return false}
        if _storage._auto != other_storage._auto {return false}
        if _storage._do != other_storage._do {return false}
        if _storage._fieldType != other_storage._fieldType {return false}
        if _storage._isPacked != other_storage._isPacked {return false}
        if _storage._releaseLength != other_storage._releaseLength {return false}
        if _storage._releaseDo != other_storage._releaseDo {return false}
        if _storage._target != other_storage._target {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    if _protobuf_extensionFieldValues != other._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.TestEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FOO"),
  ]
}

extension ProtobufUnittest_TestConflictingSymbolNames.BuildDescriptors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".BuildDescriptors"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.BuildDescriptors) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.TypeTraits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".TypeTraits"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.TypeTraits) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.Data1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".Data1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt32Field(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedInt32Field(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.Data1) -> Bool {
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.Data2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".Data2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.Data2) -> Bool {
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.Data3: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".Data3"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.Data3) -> Bool {
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.Data4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".Data4"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.Data4) -> Bool {
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.Data5: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".Data5"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.Data5) -> Bool {
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.Data6: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".Data6"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.Data6) -> Bool {
    if self.data != other.data {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.Cord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".Cord"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.Cord) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.StringPiece: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".StringPiece"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.StringPiece) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNames.DO: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = ProtobufUnittest_TestConflictingSymbolNames.protoMessageName + ".DO"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNames.DO) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingSymbolNamesExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestConflictingSymbolNamesExtension"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingSymbolNamesExtension) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingEnumNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestConflictingEnumNames"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conflicting_enum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self._conflictingEnum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._conflictingEnum {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TestConflictingEnumNames) -> Bool {
    if self._conflictingEnum != other._conflictingEnum {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TestConflictingEnumNames.NestedConflictingEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "and"),
    2: .same(proto: "class"),
    3: .same(proto: "int"),
    4: .same(proto: "typedef"),
    5: .same(proto: "XOR"),
  ]
}

extension ProtobufUnittest_DummyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DummyMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_DummyMessage) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_Shutdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Shutdown"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_Shutdown) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension ProtobufUnittest_TableStruct: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TableStruct"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: ProtobufUnittest_TableStruct) -> Bool {
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
