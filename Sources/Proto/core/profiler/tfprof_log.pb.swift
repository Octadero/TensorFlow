// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/core/profiler/tfprof_log.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// It specifies the Python callstack that creates an op.
public struct Tensorflow_Tfprof_CodeDef {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var traces: [Tensorflow_Tfprof_CodeDef.Trace] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Trace {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// deprecated by file_id.
    public var file: String = String()

    public var fileID: Int64 = 0

    public var lineno: Int32 = 0

    /// deprecated by function_id.
    public var function: String = String()

    public var functionID: Int64 = 0

    /// deprecated line_id.
    public var line: String = String()

    public var lineID: Int64 = 0

    public var funcStartLine: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Tensorflow_Tfprof_OpLogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// op name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// float_ops is filled by tfprof Python API when called. It requires the
  /// op has RegisterStatistics defined. Currently, Conv2D, MatMul, etc, are
  /// implemented.
  public var floatOps: Int64 {
    get {return _storage._floatOps}
    set {_uniqueStorage()._floatOps = newValue}
  }

  /// User can define extra op type information for an op. This allows the user
  /// to select a group of ops precisely using op_type as a key.
  public var types: [String] {
    get {return _storage._types}
    set {_uniqueStorage()._types = newValue}
  }

  /// Used to support tfprof "code" view.
  public var codeDef: Tensorflow_Tfprof_CodeDef {
    get {return _storage._codeDef ?? Tensorflow_Tfprof_CodeDef()}
    set {_uniqueStorage()._codeDef = newValue}
  }
  /// Returns true if `codeDef` has been explicitly set.
  public var hasCodeDef: Bool {return _storage._codeDef != nil}
  /// Clears the value of `codeDef`. Subsequent reads from it will return its default value.
  public mutating func clearCodeDef() {_storage._codeDef = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_Tfprof_OpLogProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var logEntries: [Tensorflow_Tfprof_OpLogEntry] = []

  /// Maps from id of CodeDef file,function,line to its string
  /// In the future can also map other id of other fields to string.
  public var idToString: Dictionary<Int64,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A proto representation of the profiler's profile.
/// It allows serialization, shipping around and deserialization of the profiles.
///
/// Please don't depend on the internals of the profile proto.
public struct Tensorflow_Tfprof_ProfileProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodes: Dictionary<Int64,Tensorflow_Tfprof_ProfileNode> = [:]

  /// Whether or not has code traces.
  public var hasTrace_p: Bool = false

  /// Whether or not the TF device tracer fails to return accelerator
  /// information (which could lead to 0 accelerator execution time).
  public var missAcceleratorStream: Bool = false

  /// Traced steps.
  public var steps: [Int64] = []

  /// Maps from id of CodeDef file,function,line to its string
  /// In the future can also map other id of other fields to string.
  public var idToString: Dictionary<Int64,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_Tfprof_ProfileNode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// graph node name.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// graph operation type.
  public var op: String {
    get {return _storage._op}
    set {_uniqueStorage()._op = newValue}
  }

  /// A unique id for the node.
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var inputs: Dictionary<Int32,Int64> {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  public var inputShapes: Dictionary<Int32,Tensorflow_Tfprof_Tuple> {
    get {return _storage._inputShapes}
    set {_uniqueStorage()._inputShapes = newValue}
  }

  public var outputs: Dictionary<Int32,Int64> {
    get {return _storage._outputs}
    set {_uniqueStorage()._outputs = newValue}
  }

  public var outputShapes: Dictionary<Int32,Tensorflow_Tfprof_Tuple> {
    get {return _storage._outputShapes}
    set {_uniqueStorage()._outputShapes = newValue}
  }

  /// A map from source node id to its output index to current node.
  public var srcOutputIndex: Dictionary<Int64,Int32> {
    get {return _storage._srcOutputIndex}
    set {_uniqueStorage()._srcOutputIndex = newValue}
  }

  public var shape: [Int64] {
    get {return _storage._shape}
    set {_uniqueStorage()._shape = newValue}
  }

  public var opTypes: [String] {
    get {return _storage._opTypes}
    set {_uniqueStorage()._opTypes = newValue}
  }

  public var canonicalDevice: String {
    get {return _storage._canonicalDevice}
    set {_uniqueStorage()._canonicalDevice = newValue}
  }

  public var hostDevice: String {
    get {return _storage._hostDevice}
    set {_uniqueStorage()._hostDevice = newValue}
  }

  public var floatOps: Int64 {
    get {return _storage._floatOps}
    set {_uniqueStorage()._floatOps = newValue}
  }

  public var trace: Tensorflow_Tfprof_CodeDef {
    get {return _storage._trace ?? Tensorflow_Tfprof_CodeDef()}
    set {_uniqueStorage()._trace = newValue}
  }
  /// Returns true if `trace` has been explicitly set.
  public var hasTrace: Bool {return _storage._trace != nil}
  /// Clears the value of `trace`. Subsequent reads from it will return its default value.
  public mutating func clearTrace() {_storage._trace = nil}

  public var attrs: Dictionary<String,Tensorflow_AttrValue> {
    get {return _storage._attrs}
    set {_uniqueStorage()._attrs = newValue}
  }

  public var execs: Dictionary<Int64,Tensorflow_Tfprof_ExecProfile> {
    get {return _storage._execs}
    set {_uniqueStorage()._execs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_Tfprof_ExecProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Can be larger than 1 if run multiple times in loop.
  public var runCount: Int64 = 0

  /// The earliest/latest time including scheduling and execution.
  public var allStartMicros: Int64 = 0

  public var latestEndMicros: Int64 = 0

  /// device -> vector of {op_start_micros, op_exec_micros} pairs.
  /// accelerator_execs: gpu:id/stream:all -> {op_start_micros, op_exec_micros}
  /// For accelerator, vector size can be larger than 1, multiple kernel fires
  /// or in tf.while_loop.
  public var acceleratorExecs: Dictionary<String,Tensorflow_Tfprof_ExecTime> = [:]

  /// cpu_execs: cpu/gpu:id -> {op_start_micros, op_exec_micros}
  /// For cpu, vector size can be larger than 1 if in tf.while_loop.
  public var cpuExecs: Dictionary<String,Tensorflow_Tfprof_ExecTime> = [:]

  /// Each entry to memory information of a scheduling of the node.
  /// Normally, there will be multiple entries in while_loop.
  public var memoryExecs: [Tensorflow_Tfprof_ExecMemory] = []

  /// The allocation and deallocation times and sizes throughout execution.
  public var allocations: [Tensorflow_AllocationRecord] = []

  /// The devices related to this execution.
  public var devices: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_Tfprof_ExecTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var times: [Tensorflow_Tfprof_Tuple] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_Tfprof_ExecMemory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the timestamp when the memory information was tracked.
  public var memoryMicros: Int64 = 0

  /// NOTE: Please don't depend on the following 4 fields yet. Due to
  /// TensorFlow internal tracing issues, the numbers can be quite wrong.
  /// TODO(xpan): Fix the TensorFlow internal tracing.
  public var hostTempBytes: Int64 = 0

  public var hostPersistentBytes: Int64 = 0

  public var acceleratorTempBytes: Int64 = 0

  public var acceleratorPersistentBytes: Int64 = 0

  /// Total bytes requested by the op.
  public var requestedBytes: Int64 = 0

  /// Total bytes requested by the op and released before op end.
  public var peakBytes: Int64 = 0

  /// Total bytes requested by the op and not released after op end.
  public var residualBytes: Int64 = 0

  /// Total bytes output by the op (not necessarily requested by the op).
  public var outputBytes: Int64 = 0

  /// The total number of bytes currently allocated by the allocator if >0.
  public var allocatorBytesInUse: Int64 = 0

  /// The memory of each output of the operation.
  public var outputMemory: Dictionary<Int32,Tensorflow_Tfprof_Memory> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_Tfprof_Tuple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var int64Values: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_Tfprof_Memory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var bytes: Int64 = 0

  public var ptr: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow.tfprof"

extension Tensorflow_Tfprof_CodeDef: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CodeDef"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "traces"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.traces)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traces, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_CodeDef) -> Bool {
    if self.traces != other.traces {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_CodeDef.Trace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tensorflow_Tfprof_CodeDef.protoMessageName + ".Trace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    6: .standard(proto: "file_id"),
    2: .same(proto: "lineno"),
    3: .same(proto: "function"),
    7: .standard(proto: "function_id"),
    4: .same(proto: "line"),
    8: .standard(proto: "line_id"),
    5: .standard(proto: "func_start_line"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.file)
      case 2: try decoder.decodeSingularInt32Field(value: &self.lineno)
      case 3: try decoder.decodeSingularStringField(value: &self.function)
      case 4: try decoder.decodeSingularStringField(value: &self.line)
      case 5: try decoder.decodeSingularInt32Field(value: &self.funcStartLine)
      case 6: try decoder.decodeSingularInt64Field(value: &self.fileID)
      case 7: try decoder.decodeSingularInt64Field(value: &self.functionID)
      case 8: try decoder.decodeSingularInt64Field(value: &self.lineID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 1)
    }
    if self.lineno != 0 {
      try visitor.visitSingularInt32Field(value: self.lineno, fieldNumber: 2)
    }
    if !self.function.isEmpty {
      try visitor.visitSingularStringField(value: self.function, fieldNumber: 3)
    }
    if !self.line.isEmpty {
      try visitor.visitSingularStringField(value: self.line, fieldNumber: 4)
    }
    if self.funcStartLine != 0 {
      try visitor.visitSingularInt32Field(value: self.funcStartLine, fieldNumber: 5)
    }
    if self.fileID != 0 {
      try visitor.visitSingularInt64Field(value: self.fileID, fieldNumber: 6)
    }
    if self.functionID != 0 {
      try visitor.visitSingularInt64Field(value: self.functionID, fieldNumber: 7)
    }
    if self.lineID != 0 {
      try visitor.visitSingularInt64Field(value: self.lineID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_CodeDef.Trace) -> Bool {
    if self.file != other.file {return false}
    if self.fileID != other.fileID {return false}
    if self.lineno != other.lineno {return false}
    if self.function != other.function {return false}
    if self.functionID != other.functionID {return false}
    if self.line != other.line {return false}
    if self.lineID != other.lineID {return false}
    if self.funcStartLine != other.funcStartLine {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_OpLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpLogEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "float_ops"),
    3: .same(proto: "types"),
    4: .standard(proto: "code_def"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _floatOps: Int64 = 0
    var _types: [String] = []
    var _codeDef: Tensorflow_Tfprof_CodeDef? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _floatOps = source._floatOps
      _types = source._types
      _codeDef = source._codeDef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._floatOps)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._types)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._codeDef)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._floatOps != 0 {
        try visitor.visitSingularInt64Field(value: _storage._floatOps, fieldNumber: 2)
      }
      if !_storage._types.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._types, fieldNumber: 3)
      }
      if let v = _storage._codeDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_OpLogEntry) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._floatOps != other_storage._floatOps {return false}
        if _storage._types != other_storage._types {return false}
        if _storage._codeDef != other_storage._codeDef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_OpLogProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpLogProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "log_entries"),
    2: .standard(proto: "id_to_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.logEntries)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: &self.idToString)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logEntries, fieldNumber: 1)
    }
    if !self.idToString.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: self.idToString, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_OpLogProto) -> Bool {
    if self.logEntries != other.logEntries {return false}
    if self.idToString != other.idToString {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_ProfileProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .standard(proto: "has_trace"),
    5: .standard(proto: "miss_accelerator_stream"),
    3: .same(proto: "steps"),
    4: .standard(proto: "id_to_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorflow_Tfprof_ProfileNode>.self, value: &self.nodes)
      case 2: try decoder.decodeSingularBoolField(value: &self.hasTrace_p)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.steps)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: &self.idToString)
      case 5: try decoder.decodeSingularBoolField(value: &self.missAcceleratorStream)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorflow_Tfprof_ProfileNode>.self, value: self.nodes, fieldNumber: 1)
    }
    if self.hasTrace_p != false {
      try visitor.visitSingularBoolField(value: self.hasTrace_p, fieldNumber: 2)
    }
    if !self.steps.isEmpty {
      try visitor.visitPackedInt64Field(value: self.steps, fieldNumber: 3)
    }
    if !self.idToString.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufString>.self, value: self.idToString, fieldNumber: 4)
    }
    if self.missAcceleratorStream != false {
      try visitor.visitSingularBoolField(value: self.missAcceleratorStream, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_ProfileProto) -> Bool {
    if self.nodes != other.nodes {return false}
    if self.hasTrace_p != other.hasTrace_p {return false}
    if self.missAcceleratorStream != other.missAcceleratorStream {return false}
    if self.steps != other.steps {return false}
    if self.idToString != other.idToString {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_ProfileNode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileNode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    9: .same(proto: "op"),
    13: .same(proto: "id"),
    2: .same(proto: "inputs"),
    16: .standard(proto: "input_shapes"),
    3: .same(proto: "outputs"),
    15: .standard(proto: "output_shapes"),
    14: .standard(proto: "src_output_index"),
    4: .same(proto: "shape"),
    5: .standard(proto: "op_types"),
    6: .standard(proto: "canonical_device"),
    7: .standard(proto: "host_device"),
    8: .standard(proto: "float_ops"),
    10: .same(proto: "trace"),
    11: .same(proto: "attrs"),
    12: .same(proto: "execs"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _op: String = String()
    var _id: Int64 = 0
    var _inputs: Dictionary<Int32,Int64> = [:]
    var _inputShapes: Dictionary<Int32,Tensorflow_Tfprof_Tuple> = [:]
    var _outputs: Dictionary<Int32,Int64> = [:]
    var _outputShapes: Dictionary<Int32,Tensorflow_Tfprof_Tuple> = [:]
    var _srcOutputIndex: Dictionary<Int64,Int32> = [:]
    var _shape: [Int64] = []
    var _opTypes: [String] = []
    var _canonicalDevice: String = String()
    var _hostDevice: String = String()
    var _floatOps: Int64 = 0
    var _trace: Tensorflow_Tfprof_CodeDef? = nil
    var _attrs: Dictionary<String,Tensorflow_AttrValue> = [:]
    var _execs: Dictionary<Int64,Tensorflow_Tfprof_ExecProfile> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _op = source._op
      _id = source._id
      _inputs = source._inputs
      _inputShapes = source._inputShapes
      _outputs = source._outputs
      _outputShapes = source._outputShapes
      _srcOutputIndex = source._srcOutputIndex
      _shape = source._shape
      _opTypes = source._opTypes
      _canonicalDevice = source._canonicalDevice
      _hostDevice = source._hostDevice
      _floatOps = source._floatOps
      _trace = source._trace
      _attrs = source._attrs
      _execs = source._execs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._inputs)
        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._outputs)
        case 4: try decoder.decodeRepeatedInt64Field(value: &_storage._shape)
        case 5: try decoder.decodeRepeatedStringField(value: &_storage._opTypes)
        case 6: try decoder.decodeSingularStringField(value: &_storage._canonicalDevice)
        case 7: try decoder.decodeSingularStringField(value: &_storage._hostDevice)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._floatOps)
        case 9: try decoder.decodeSingularStringField(value: &_storage._op)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._trace)
        case 11: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_AttrValue>.self, value: &_storage._attrs)
        case 12: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorflow_Tfprof_ExecProfile>.self, value: &_storage._execs)
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 14: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: &_storage._srcOutputIndex)
        case 15: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorflow_Tfprof_Tuple>.self, value: &_storage._outputShapes)
        case 16: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorflow_Tfprof_Tuple>.self, value: &_storage._inputShapes)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._inputs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: _storage._inputs, fieldNumber: 2)
      }
      if !_storage._outputs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: _storage._outputs, fieldNumber: 3)
      }
      if !_storage._shape.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._shape, fieldNumber: 4)
      }
      if !_storage._opTypes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._opTypes, fieldNumber: 5)
      }
      if !_storage._canonicalDevice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._canonicalDevice, fieldNumber: 6)
      }
      if !_storage._hostDevice.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hostDevice, fieldNumber: 7)
      }
      if _storage._floatOps != 0 {
        try visitor.visitSingularInt64Field(value: _storage._floatOps, fieldNumber: 8)
      }
      if !_storage._op.isEmpty {
        try visitor.visitSingularStringField(value: _storage._op, fieldNumber: 9)
      }
      if let v = _storage._trace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._attrs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_AttrValue>.self, value: _storage._attrs, fieldNumber: 11)
      }
      if !_storage._execs.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt64,Tensorflow_Tfprof_ExecProfile>.self, value: _storage._execs, fieldNumber: 12)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 13)
      }
      if !_storage._srcOutputIndex.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt32>.self, value: _storage._srcOutputIndex, fieldNumber: 14)
      }
      if !_storage._outputShapes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorflow_Tfprof_Tuple>.self, value: _storage._outputShapes, fieldNumber: 15)
      }
      if !_storage._inputShapes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorflow_Tfprof_Tuple>.self, value: _storage._inputShapes, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_ProfileNode) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._op != other_storage._op {return false}
        if _storage._id != other_storage._id {return false}
        if _storage._inputs != other_storage._inputs {return false}
        if _storage._inputShapes != other_storage._inputShapes {return false}
        if _storage._outputs != other_storage._outputs {return false}
        if _storage._outputShapes != other_storage._outputShapes {return false}
        if _storage._srcOutputIndex != other_storage._srcOutputIndex {return false}
        if _storage._shape != other_storage._shape {return false}
        if _storage._opTypes != other_storage._opTypes {return false}
        if _storage._canonicalDevice != other_storage._canonicalDevice {return false}
        if _storage._hostDevice != other_storage._hostDevice {return false}
        if _storage._floatOps != other_storage._floatOps {return false}
        if _storage._trace != other_storage._trace {return false}
        if _storage._attrs != other_storage._attrs {return false}
        if _storage._execs != other_storage._execs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_ExecProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "run_count"),
    2: .standard(proto: "all_start_micros"),
    3: .standard(proto: "latest_end_micros"),
    4: .standard(proto: "accelerator_execs"),
    5: .standard(proto: "cpu_execs"),
    7: .standard(proto: "memory_execs"),
    11: .same(proto: "allocations"),
    6: .same(proto: "devices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.runCount)
      case 2: try decoder.decodeSingularInt64Field(value: &self.allStartMicros)
      case 3: try decoder.decodeSingularInt64Field(value: &self.latestEndMicros)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_Tfprof_ExecTime>.self, value: &self.acceleratorExecs)
      case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_Tfprof_ExecTime>.self, value: &self.cpuExecs)
      case 6: try decoder.decodeRepeatedStringField(value: &self.devices)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.memoryExecs)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.allocations)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.runCount != 0 {
      try visitor.visitSingularInt64Field(value: self.runCount, fieldNumber: 1)
    }
    if self.allStartMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.allStartMicros, fieldNumber: 2)
    }
    if self.latestEndMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.latestEndMicros, fieldNumber: 3)
    }
    if !self.acceleratorExecs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_Tfprof_ExecTime>.self, value: self.acceleratorExecs, fieldNumber: 4)
    }
    if !self.cpuExecs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_Tfprof_ExecTime>.self, value: self.cpuExecs, fieldNumber: 5)
    }
    if !self.devices.isEmpty {
      try visitor.visitRepeatedStringField(value: self.devices, fieldNumber: 6)
    }
    if !self.memoryExecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memoryExecs, fieldNumber: 7)
    }
    if !self.allocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allocations, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_ExecProfile) -> Bool {
    if self.runCount != other.runCount {return false}
    if self.allStartMicros != other.allStartMicros {return false}
    if self.latestEndMicros != other.latestEndMicros {return false}
    if self.acceleratorExecs != other.acceleratorExecs {return false}
    if self.cpuExecs != other.cpuExecs {return false}
    if self.memoryExecs != other.memoryExecs {return false}
    if self.allocations != other.allocations {return false}
    if self.devices != other.devices {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_ExecTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "times"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.times)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.times.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.times, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_ExecTime) -> Bool {
    if self.times != other.times {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_ExecMemory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecMemory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "memory_micros"),
    2: .standard(proto: "host_temp_bytes"),
    3: .standard(proto: "host_persistent_bytes"),
    4: .standard(proto: "accelerator_temp_bytes"),
    5: .standard(proto: "accelerator_persistent_bytes"),
    6: .standard(proto: "requested_bytes"),
    7: .standard(proto: "peak_bytes"),
    8: .standard(proto: "residual_bytes"),
    9: .standard(proto: "output_bytes"),
    10: .standard(proto: "allocator_bytes_in_use"),
    11: .standard(proto: "output_memory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.memoryMicros)
      case 2: try decoder.decodeSingularInt64Field(value: &self.hostTempBytes)
      case 3: try decoder.decodeSingularInt64Field(value: &self.hostPersistentBytes)
      case 4: try decoder.decodeSingularInt64Field(value: &self.acceleratorTempBytes)
      case 5: try decoder.decodeSingularInt64Field(value: &self.acceleratorPersistentBytes)
      case 6: try decoder.decodeSingularInt64Field(value: &self.requestedBytes)
      case 7: try decoder.decodeSingularInt64Field(value: &self.peakBytes)
      case 8: try decoder.decodeSingularInt64Field(value: &self.residualBytes)
      case 9: try decoder.decodeSingularInt64Field(value: &self.outputBytes)
      case 10: try decoder.decodeSingularInt64Field(value: &self.allocatorBytesInUse)
      case 11: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorflow_Tfprof_Memory>.self, value: &self.outputMemory)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memoryMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.memoryMicros, fieldNumber: 1)
    }
    if self.hostTempBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.hostTempBytes, fieldNumber: 2)
    }
    if self.hostPersistentBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.hostPersistentBytes, fieldNumber: 3)
    }
    if self.acceleratorTempBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.acceleratorTempBytes, fieldNumber: 4)
    }
    if self.acceleratorPersistentBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.acceleratorPersistentBytes, fieldNumber: 5)
    }
    if self.requestedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.requestedBytes, fieldNumber: 6)
    }
    if self.peakBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.peakBytes, fieldNumber: 7)
    }
    if self.residualBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.residualBytes, fieldNumber: 8)
    }
    if self.outputBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.outputBytes, fieldNumber: 9)
    }
    if self.allocatorBytesInUse != 0 {
      try visitor.visitSingularInt64Field(value: self.allocatorBytesInUse, fieldNumber: 10)
    }
    if !self.outputMemory.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Tensorflow_Tfprof_Memory>.self, value: self.outputMemory, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_ExecMemory) -> Bool {
    if self.memoryMicros != other.memoryMicros {return false}
    if self.hostTempBytes != other.hostTempBytes {return false}
    if self.hostPersistentBytes != other.hostPersistentBytes {return false}
    if self.acceleratorTempBytes != other.acceleratorTempBytes {return false}
    if self.acceleratorPersistentBytes != other.acceleratorPersistentBytes {return false}
    if self.requestedBytes != other.requestedBytes {return false}
    if self.peakBytes != other.peakBytes {return false}
    if self.residualBytes != other.residualBytes {return false}
    if self.outputBytes != other.outputBytes {return false}
    if self.allocatorBytesInUse != other.allocatorBytesInUse {return false}
    if self.outputMemory != other.outputMemory {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_Tuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tuple"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "int64_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.int64Values)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.int64Values.isEmpty {
      try visitor.visitPackedInt64Field(value: self.int64Values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_Tuple) -> Bool {
    if self.int64Values != other.int64Values {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_Tfprof_Memory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Memory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
    2: .same(proto: "ptr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.bytes)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.ptr)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytes != 0 {
      try visitor.visitSingularInt64Field(value: self.bytes, fieldNumber: 1)
    }
    if self.ptr != 0 {
      try visitor.visitSingularUInt64Field(value: self.ptr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_Tfprof_Memory) -> Bool {
    if self.bytes != other.bytes {return false}
    if self.ptr != other.ptr {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
