// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/core/protobuf/meta_graph.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// NOTE: This protocol buffer is evolving, and will go through revisions in the
/// coming months.
///
/// Protocol buffer containing the following which are necessary to restart
/// training, run inference. It can be used to serialize/de-serialize memory
/// objects necessary for running computation in a graph when crossing the
/// process boundary. It can be used for long term storage of graphs,
/// cross-language execution of graphs, etc.
///   MetaInfoDef
///   GraphDef
///   SaverDef
///   CollectionDef
///   TensorInfo
///   SignatureDef
public struct Tensorflow_MetaGraphDef: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".MetaGraphDef"

  public var metaInfoDef: Tensorflow_MetaGraphDef.MetaInfoDef {
    get {return _storage._metaInfoDef ?? Tensorflow_MetaGraphDef.MetaInfoDef()}
    set {_uniqueStorage()._metaInfoDef = newValue}
  }
  /// Returns true if `metaInfoDef` has been explicitly set.
  public var hasMetaInfoDef: Bool {return _storage._metaInfoDef != nil}
  /// Clears the value of `metaInfoDef`. Subsequent reads from it will return its default value.
  public mutating func clearMetaInfoDef() {_storage._metaInfoDef = nil}

  /// GraphDef.
  public var graphDef: Tensorflow_GraphDef {
    get {return _storage._graphDef ?? Tensorflow_GraphDef()}
    set {_uniqueStorage()._graphDef = newValue}
  }
  /// Returns true if `graphDef` has been explicitly set.
  public var hasGraphDef: Bool {return _storage._graphDef != nil}
  /// Clears the value of `graphDef`. Subsequent reads from it will return its default value.
  public mutating func clearGraphDef() {_storage._graphDef = nil}

  /// SaverDef.
  public var saverDef: Tensorflow_SaverDef {
    get {return _storage._saverDef ?? Tensorflow_SaverDef()}
    set {_uniqueStorage()._saverDef = newValue}
  }
  /// Returns true if `saverDef` has been explicitly set.
  public var hasSaverDef: Bool {return _storage._saverDef != nil}
  /// Clears the value of `saverDef`. Subsequent reads from it will return its default value.
  public mutating func clearSaverDef() {_storage._saverDef = nil}

  /// collection_def: Map from collection name to collections.
  /// See CollectionDef section for details.
  public var collectionDef: Dictionary<String,Tensorflow_CollectionDef> {
    get {return _storage._collectionDef}
    set {_uniqueStorage()._collectionDef = newValue}
  }

  /// signature_def: Map from user supplied key for a signature to a single
  /// SignatureDef.
  public var signatureDef: Dictionary<String,Tensorflow_SignatureDef> {
    get {return _storage._signatureDef}
    set {_uniqueStorage()._signatureDef = newValue}
  }

  /// Asset file def to be used with the defined graph.
  public var assetFileDef: [Tensorflow_AssetFileDef] {
    get {return _storage._assetFileDef}
    set {_uniqueStorage()._assetFileDef = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Meta information regarding the graph to be exported.  To be used by users
  /// of this protocol buffer to encode information regarding their meta graph.
  public struct MetaInfoDef: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_MetaGraphDef.protoMessageName + ".MetaInfoDef"

    /// User specified Version string. Can be the name of the model and revision,
    /// steps this model has been trained to, etc.
    public var metaGraphVersion: String {
      get {return _storage._metaGraphVersion}
      set {_uniqueStorage()._metaGraphVersion = newValue}
    }

    /// A copy of the OpDefs used by the producer of this graph_def.
    /// Descriptions and Ops not used in graph_def are stripped out.
    public var strippedOpList: Tensorflow_OpList {
      get {return _storage._strippedOpList ?? Tensorflow_OpList()}
      set {_uniqueStorage()._strippedOpList = newValue}
    }
    /// Returns true if `strippedOpList` has been explicitly set.
    public var hasStrippedOpList: Bool {return _storage._strippedOpList != nil}
    /// Clears the value of `strippedOpList`. Subsequent reads from it will return its default value.
    public mutating func clearStrippedOpList() {_storage._strippedOpList = nil}

    /// A serialized protobuf. Can be the time this meta graph is created, or
    /// modified, or name of the model.
    public var anyInfo: SwiftProtobuf.Google_Protobuf_Any {
      get {return _storage._anyInfo ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_uniqueStorage()._anyInfo = newValue}
    }
    /// Returns true if `anyInfo` has been explicitly set.
    public var hasAnyInfo: Bool {return _storage._anyInfo != nil}
    /// Clears the value of `anyInfo`. Subsequent reads from it will return its default value.
    public mutating func clearAnyInfo() {_storage._anyInfo = nil}

    /// User supplied tag(s) on the meta_graph and included graph_def.
    ///
    /// MetaGraphDefs should be tagged with their capabilities or use-cases.
    /// Examples: "train", "serve", "gpu", "tpu", etc.
    /// These tags enable loaders to access the MetaGraph(s) appropriate for a
    /// specific use-case or runtime environment.
    public var tags: [String] {
      get {return _storage._tags}
      set {_uniqueStorage()._tags = newValue}
    }

    /// The __version__ string of the tensorflow build used to write this graph.
    /// This will be populated by the framework, which will overwrite any user
    /// supplied value.
    public var tensorflowVersion: String {
      get {return _storage._tensorflowVersion}
      set {_uniqueStorage()._tensorflowVersion = newValue}
    }

    /// The __git_version__ string of the tensorflow build used to write this
    /// graph. This will be populated by the framework, which will overwrite any
    /// user supplied value.
    public var tensorflowGitVersion: String {
      get {return _storage._tensorflowGitVersion}
      set {_uniqueStorage()._tensorflowGitVersion = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      _ = _uniqueStorage()
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        while let fieldNumber = try decoder.nextFieldNumber() {
          switch fieldNumber {
          case 1: try decoder.decodeSingularStringField(value: &_storage._metaGraphVersion)
          case 2: try decoder.decodeSingularMessageField(value: &_storage._strippedOpList)
          case 3: try decoder.decodeSingularMessageField(value: &_storage._anyInfo)
          case 4: try decoder.decodeRepeatedStringField(value: &_storage._tags)
          case 5: try decoder.decodeSingularStringField(value: &_storage._tensorflowVersion)
          case 6: try decoder.decodeSingularStringField(value: &_storage._tensorflowGitVersion)
          default: break
          }
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
        if !_storage._metaGraphVersion.isEmpty {
          try visitor.visitSingularStringField(value: _storage._metaGraphVersion, fieldNumber: 1)
        }
        if let v = _storage._strippedOpList {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
        if let v = _storage._anyInfo {
          try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
        }
        if !_storage._tags.isEmpty {
          try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 4)
        }
        if !_storage._tensorflowVersion.isEmpty {
          try visitor.visitSingularStringField(value: _storage._tensorflowVersion, fieldNumber: 5)
        }
        if !_storage._tensorflowGitVersion.isEmpty {
          try visitor.visitSingularStringField(value: _storage._tensorflowGitVersion, fieldNumber: 6)
        }
      }
      try unknownFields.traverse(visitor: &visitor)
    }

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._metaInfoDef)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._graphDef)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._saverDef)
        case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_CollectionDef>.self, value: &_storage._collectionDef)
        case 5: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_SignatureDef>.self, value: &_storage._signatureDef)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._assetFileDef)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._metaInfoDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._graphDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._saverDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._collectionDef.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_CollectionDef>.self, value: _storage._collectionDef, fieldNumber: 4)
      }
      if !_storage._signatureDef.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_SignatureDef>.self, value: _storage._signatureDef, fieldNumber: 5)
      }
      if !_storage._assetFileDef.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._assetFileDef, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CollectionDef should cover most collections.
/// To add a user-defined collection, do one of the following:
/// 1. For simple data types, such as string, int, float:
///      tf.add_to_collection("your_collection_name", your_simple_value)
///    strings will be stored as bytes_list.
///
/// 2. For Protobuf types, there are three ways to add them:
///    1) tf.add_to_collection("your_collection_name",
///         your_proto.SerializeToString())
///
///       collection_def {
///         key: "user_defined_bytes_collection"
///         value {
///           bytes_list {
///             value: "queue_name: \"test_queue\"\n"
///           }
///         }
///       }
///
///  or
///
///    2) tf.add_to_collection("your_collection_name", str(your_proto))
///
///       collection_def {
///         key: "user_defined_string_collection"
///         value {
///          bytes_list {
///             value: "\n\ntest_queue"
///           }
///         }
///       }
///
///  or
///
///    3) any_buf = any_pb2.Any()
///       tf.add_to_collection("your_collection_name",
///         any_buf.Pack(your_proto))
///
///       collection_def {
///         key: "user_defined_any_collection"
///         value {
///           any_list {
///             value {
///               type_url: "type.googleapis.com/tensorflow.QueueRunnerDef"
///               value: "\n\ntest_queue"
///             }
///           }
///         }
///       }
///
/// 3. For Python objects, implement to_proto() and from_proto(), and register
///    them in the following manner:
///    ops.register_proto_function("your_collection_name",
///                                proto_type,
///                                to_proto=YourPythonObject.to_proto,
///                                from_proto=YourPythonObject.from_proto)
///    These functions will be invoked to serialize and de-serialize the
///    collection. For example,
///    ops.register_proto_function(ops.GraphKeys.GLOBAL_VARIABLES,
///                                proto_type=variable_pb2.VariableDef,
///                                to_proto=Variable.to_proto,
///                                from_proto=Variable.from_proto)
public struct Tensorflow_CollectionDef: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".CollectionDef"

  public var kind: OneOf_Kind? {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  public var nodeList: Tensorflow_CollectionDef.NodeList {
    get {
      if case .nodeList(let v)? = _storage._kind {return v}
      return Tensorflow_CollectionDef.NodeList()
    }
    set {_uniqueStorage()._kind = .nodeList(newValue)}
  }

  public var bytesList: Tensorflow_CollectionDef.BytesList {
    get {
      if case .bytesList(let v)? = _storage._kind {return v}
      return Tensorflow_CollectionDef.BytesList()
    }
    set {_uniqueStorage()._kind = .bytesList(newValue)}
  }

  public var int64List: Tensorflow_CollectionDef.Int64List {
    get {
      if case .int64List(let v)? = _storage._kind {return v}
      return Tensorflow_CollectionDef.Int64List()
    }
    set {_uniqueStorage()._kind = .int64List(newValue)}
  }

  public var floatList: Tensorflow_CollectionDef.FloatList {
    get {
      if case .floatList(let v)? = _storage._kind {return v}
      return Tensorflow_CollectionDef.FloatList()
    }
    set {_uniqueStorage()._kind = .floatList(newValue)}
  }

  public var anyList: Tensorflow_CollectionDef.AnyList {
    get {
      if case .anyList(let v)? = _storage._kind {return v}
      return Tensorflow_CollectionDef.AnyList()
    }
    set {_uniqueStorage()._kind = .anyList(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    case nodeList(Tensorflow_CollectionDef.NodeList)
    case bytesList(Tensorflow_CollectionDef.BytesList)
    case int64List(Tensorflow_CollectionDef.Int64List)
    case floatList(Tensorflow_CollectionDef.FloatList)
    case anyList(Tensorflow_CollectionDef.AnyList)

    public static func ==(lhs: Tensorflow_CollectionDef.OneOf_Kind, rhs: Tensorflow_CollectionDef.OneOf_Kind) -> Bool {
      switch (lhs, rhs) {
      case (.nodeList(let l), .nodeList(let r)): return l == r
      case (.bytesList(let l), .bytesList(let r)): return l == r
      case (.int64List(let l), .int64List(let r)): return l == r
      case (.floatList(let l), .floatList(let r)): return l == r
      case (.anyList(let l), .anyList(let r)): return l == r
      default: return false
      }
    }
  }

  /// NodeList is used for collecting nodes in graph. For example
  /// collection_def {
  ///   key: "summaries"
  ///   value {
  ///     node_list {
  ///       value: "input_producer/ScalarSummary:0"
  ///       value: "shuffle_batch/ScalarSummary:0"
  ///       value: "ImageSummary:0"
  ///     }
  ///   }
  public struct NodeList: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_CollectionDef.protoMessageName + ".NodeList"

    public var value: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedStringField(value: &self.value)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.value.isEmpty {
        try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// BytesList is used for collecting strings and serialized protobufs. For
  /// example:
  /// collection_def {
  ///   key: "trainable_variables"
  ///   value {
  ///     bytes_list {
  ///       value: "\n\017conv1/weights:0\022\024conv1/weights/Assign
  ///              \032\024conv1/weights/read:0"
  ///       value: "\n\016conv1/biases:0\022\023conv1/biases/Assign\032
  ///              \023conv1/biases/read:0"
  ///     }
  ///   }
  /// }
  public struct BytesList: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_CollectionDef.protoMessageName + ".BytesList"

    public var value: [Data] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedBytesField(value: &self.value)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.value.isEmpty {
        try visitor.visitRepeatedBytesField(value: self.value, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// Int64List is used for collecting int, int64 and long values.
  public struct Int64List: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_CollectionDef.protoMessageName + ".Int64List"

    public var value: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedInt64Field(value: &self.value)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.value.isEmpty {
        try visitor.visitPackedInt64Field(value: self.value, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// FloatList is used for collecting float values.
  public struct FloatList: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_CollectionDef.protoMessageName + ".FloatList"

    public var value: [Float] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedFloatField(value: &self.value)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.value.isEmpty {
        try visitor.visitPackedFloatField(value: self.value, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  /// AnyList is used for collecting Any protos.
  public struct AnyList: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_CollectionDef.protoMessageName + ".AnyList"

    public var value: [SwiftProtobuf.Google_Protobuf_Any] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &self.value)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.value.isEmpty {
        try visitor.visitRepeatedMessageField(value: self.value, fieldNumber: 1)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: Tensorflow_CollectionDef.NodeList?
          if let current = _storage._kind {
            try decoder.handleConflictingOneOf()
            if case .nodeList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kind = .nodeList(v)}
        case 2:
          var v: Tensorflow_CollectionDef.BytesList?
          if let current = _storage._kind {
            try decoder.handleConflictingOneOf()
            if case .bytesList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kind = .bytesList(v)}
        case 3:
          var v: Tensorflow_CollectionDef.Int64List?
          if let current = _storage._kind {
            try decoder.handleConflictingOneOf()
            if case .int64List(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kind = .int64List(v)}
        case 4:
          var v: Tensorflow_CollectionDef.FloatList?
          if let current = _storage._kind {
            try decoder.handleConflictingOneOf()
            if case .floatList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kind = .floatList(v)}
        case 5:
          var v: Tensorflow_CollectionDef.AnyList?
          if let current = _storage._kind {
            try decoder.handleConflictingOneOf()
            if case .anyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._kind = .anyList(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._kind {
      case .nodeList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .bytesList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .int64List(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .floatList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .anyList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information about a Tensor necessary for feeding or retrieval.
public struct Tensorflow_TensorInfo: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".TensorInfo"

  public var encoding: OneOf_Encoding? {
    get {return _storage._encoding}
    set {_uniqueStorage()._encoding = newValue}
  }

  /// For dense `Tensor`s, the name of the tensor in the graph.
  public var name: String {
    get {
      if case .name(let v)? = _storage._encoding {return v}
      return String()
    }
    set {_uniqueStorage()._encoding = .name(newValue)}
  }

  /// There are many possible encodings of sparse matrices
  /// (https://en.wikipedia.org/wiki/Sparse_matrix).  Currently, TensorFlow
  /// uses only the COO encoding.  This is supported and documented in the
  /// SparseTensor Python class.
  public var cooSparse: Tensorflow_TensorInfo.CooSparse {
    get {
      if case .cooSparse(let v)? = _storage._encoding {return v}
      return Tensorflow_TensorInfo.CooSparse()
    }
    set {_uniqueStorage()._encoding = .cooSparse(newValue)}
  }

  public var dtype: Tensorflow_DataType {
    get {return _storage._dtype}
    set {_uniqueStorage()._dtype = newValue}
  }

  /// The static shape should be recorded here, to the extent that it can
  /// be known in advance.  In the case of a SparseTensor, this field describes
  /// the logical shape of the represented tensor (aka dense_shape).
  public var tensorShape: Tensorflow_TensorShapeProto {
    get {return _storage._tensorShape ?? Tensorflow_TensorShapeProto()}
    set {_uniqueStorage()._tensorShape = newValue}
  }
  /// Returns true if `tensorShape` has been explicitly set.
  public var hasTensorShape: Bool {return _storage._tensorShape != nil}
  /// Clears the value of `tensorShape`. Subsequent reads from it will return its default value.
  public mutating func clearTensorShape() {_storage._tensorShape = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Encoding: Equatable {
    /// For dense `Tensor`s, the name of the tensor in the graph.
    case name(String)
    /// There are many possible encodings of sparse matrices
    /// (https://en.wikipedia.org/wiki/Sparse_matrix).  Currently, TensorFlow
    /// uses only the COO encoding.  This is supported and documented in the
    /// SparseTensor Python class.
    case cooSparse(Tensorflow_TensorInfo.CooSparse)

    public static func ==(lhs: Tensorflow_TensorInfo.OneOf_Encoding, rhs: Tensorflow_TensorInfo.OneOf_Encoding) -> Bool {
      switch (lhs, rhs) {
      case (.name(let l), .name(let r)): return l == r
      case (.cooSparse(let l), .cooSparse(let r)): return l == r
      default: return false
      }
    }
  }

  /// For sparse tensors, The COO encoding stores a triple of values, indices,
  /// and shape.
  public struct CooSparse: SwiftProtobuf.Message {
    public static let protoMessageName: String = Tensorflow_TensorInfo.protoMessageName + ".CooSparse"

    /// The shape of the values Tensor is [?].  Its dtype must be the dtype of
    /// the SparseTensor as a whole, given in the enclosing TensorInfo.
    public var valuesTensorName: String = String()

    /// The indices Tensor must have dtype int64 and shape [?, ?].
    public var indicesTensorName: String = String()

    /// The dynamic logical shape represented by the SparseTensor is recorded in
    /// the Tensor referenced here.  It must have dtype int64 and shape [?].
    public var denseShapeTensorName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    /// Used by the decoding initializers in the SwiftProtobuf library, not generally
    /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
    /// initializers are defined in the SwiftProtobuf library. See the Message and
    /// Message+*Additions` files.
    public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &self.valuesTensorName)
        case 2: try decoder.decodeSingularStringField(value: &self.indicesTensorName)
        case 3: try decoder.decodeSingularStringField(value: &self.denseShapeTensorName)
        default: break
        }
      }
    }

    /// Used by the encoding methods of the SwiftProtobuf library, not generally
    /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
    /// other serializer methods are defined in the SwiftProtobuf library. See the
    /// `Message` and `Message+*Additions` files.
    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
      if !self.valuesTensorName.isEmpty {
        try visitor.visitSingularStringField(value: self.valuesTensorName, fieldNumber: 1)
      }
      if !self.indicesTensorName.isEmpty {
        try visitor.visitSingularStringField(value: self.indicesTensorName, fieldNumber: 2)
      }
      if !self.denseShapeTensorName.isEmpty {
        try visitor.visitSingularStringField(value: self.denseShapeTensorName, fieldNumber: 3)
      }
      try unknownFields.traverse(visitor: &visitor)
    }
  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._encoding != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._encoding = .name(v)}
        case 2: try decoder.decodeSingularEnumField(value: &_storage._dtype)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._tensorShape)
        case 4:
          var v: Tensorflow_TensorInfo.CooSparse?
          if let current = _storage._encoding {
            try decoder.handleConflictingOneOf()
            if case .cooSparse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._encoding = .cooSparse(v)}
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .name(let v)? = _storage._encoding {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if _storage._dtype != .dtInvalid {
        try visitor.visitSingularEnumField(value: _storage._dtype, fieldNumber: 2)
      }
      if let v = _storage._tensorShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if case .cooSparse(let v)? = _storage._encoding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// SignatureDef defines the signature of a computation supported by a TensorFlow
/// graph.
///
/// For example, a model with two loss computations, sharing a single input,
/// might have the following signature_def map.
///
/// Note that across the two SignatureDefs "loss_A" and "loss_B", the input key,
/// output key, and method_name are identical, and will be used by system(s) that
/// implement or rely upon this particular loss method. The output tensor names
/// differ, demonstrating how different outputs can exist for the same method.
///
/// signature_def {
///   key: "loss_A"
///   value {
///     inputs {
///       key: "input"
///       value {
///         name: "input:0"
///         dtype: DT_STRING
///         tensor_shape: ...
///       }
///     }
///     outputs {
///       key: "loss_output"
///       value {
///         name: "loss_output_A:0"
///         dtype: DT_FLOAT
///         tensor_shape: ...
///       }
///     }
///   }
///   ...
///   method_name: "some/package/compute_loss"
/// }
/// signature_def {
///   key: "loss_B"
///   value {
///     inputs {
///       key: "input"
///       value {
///         name: "input:0"
///         dtype: DT_STRING
///         tensor_shape: ...
///       }
///     }
///     outputs {
///       key: "loss_output"
///       value {
///         name: "loss_output_B:0"
///         dtype: DT_FLOAT
///         tensor_shape: ...
///       }
///     }
///   }
///   ...
///   method_name: "some/package/compute_loss"
/// }
public struct Tensorflow_SignatureDef: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".SignatureDef"

  /// Named input parameters.
  public var inputs: Dictionary<String,Tensorflow_TensorInfo> = [:]

  /// Named output parameters.
  public var outputs: Dictionary<String,Tensorflow_TensorInfo> = [:]

  /// Extensible method_name information enabling third-party users to mark a
  /// SignatureDef as supporting a particular method. This enables producers and
  /// consumers of SignatureDefs, e.g. a model definition library and a serving
  /// library to have a clear hand-off regarding the semantics of a computation.
  ///
  /// Note that multiple SignatureDefs in a single MetaGraphDef may have the same
  /// method_name. This is commonly used to support multi-headed computation,
  /// where a single graph computation may return multiple results.
  public var methodName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_TensorInfo>.self, value: &self.inputs)
      case 2: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_TensorInfo>.self, value: &self.outputs)
      case 3: try decoder.decodeSingularStringField(value: &self.methodName)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_TensorInfo>.self, value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Tensorflow_TensorInfo>.self, value: self.outputs, fieldNumber: 2)
    }
    if !self.methodName.isEmpty {
      try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// An asset file def for a single file or a set of sharded files with the same
/// name.
public struct Tensorflow_AssetFileDef: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".AssetFileDef"

  /// The tensor to bind the asset filename to.
  public var tensorInfo: Tensorflow_TensorInfo {
    get {return _storage._tensorInfo ?? Tensorflow_TensorInfo()}
    set {_uniqueStorage()._tensorInfo = newValue}
  }
  /// Returns true if `tensorInfo` has been explicitly set.
  public var hasTensorInfo: Bool {return _storage._tensorInfo != nil}
  /// Clears the value of `tensorInfo`. Subsequent reads from it will return its default value.
  public mutating func clearTensorInfo() {_storage._tensorInfo = nil}

  /// The filename within an assets directory. Note: does not include the path
  /// prefix, i.e. directories. For an asset at /tmp/path/vocab.txt, the filename
  /// would be "vocab.txt".
  public var filename: String {
    get {return _storage._filename}
    set {_uniqueStorage()._filename = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._tensorInfo)
        case 2: try decoder.decodeSingularStringField(value: &_storage._filename)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tensorInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._filename.isEmpty {
        try visitor.visitSingularStringField(value: _storage._filename, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow"

extension Tensorflow_MetaGraphDef: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meta_info_def"),
    2: .standard(proto: "graph_def"),
    3: .standard(proto: "saver_def"),
    4: .standard(proto: "collection_def"),
    5: .standard(proto: "signature_def"),
    6: .standard(proto: "asset_file_def"),
  ]

  fileprivate class _StorageClass {
    var _metaInfoDef: Tensorflow_MetaGraphDef.MetaInfoDef? = nil
    var _graphDef: Tensorflow_GraphDef? = nil
    var _saverDef: Tensorflow_SaverDef? = nil
    var _collectionDef: Dictionary<String,Tensorflow_CollectionDef> = [:]
    var _signatureDef: Dictionary<String,Tensorflow_SignatureDef> = [:]
    var _assetFileDef: [Tensorflow_AssetFileDef] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metaInfoDef = source._metaInfoDef
      _graphDef = source._graphDef
      _saverDef = source._saverDef
      _collectionDef = source._collectionDef
      _signatureDef = source._signatureDef
      _assetFileDef = source._assetFileDef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_MetaGraphDef) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._metaInfoDef != other_storage._metaInfoDef {return false}
        if _storage._graphDef != other_storage._graphDef {return false}
        if _storage._saverDef != other_storage._saverDef {return false}
        if _storage._collectionDef != other_storage._collectionDef {return false}
        if _storage._signatureDef != other_storage._signatureDef {return false}
        if _storage._assetFileDef != other_storage._assetFileDef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_MetaGraphDef.MetaInfoDef: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meta_graph_version"),
    2: .standard(proto: "stripped_op_list"),
    3: .standard(proto: "any_info"),
    4: .same(proto: "tags"),
    5: .standard(proto: "tensorflow_version"),
    6: .standard(proto: "tensorflow_git_version"),
  ]

  fileprivate class _StorageClass {
    var _metaGraphVersion: String = String()
    var _strippedOpList: Tensorflow_OpList? = nil
    var _anyInfo: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _tags: [String] = []
    var _tensorflowVersion: String = String()
    var _tensorflowGitVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _metaGraphVersion = source._metaGraphVersion
      _strippedOpList = source._strippedOpList
      _anyInfo = source._anyInfo
      _tags = source._tags
      _tensorflowVersion = source._tensorflowVersion
      _tensorflowGitVersion = source._tensorflowGitVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_MetaGraphDef.MetaInfoDef) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._metaGraphVersion != other_storage._metaGraphVersion {return false}
        if _storage._strippedOpList != other_storage._strippedOpList {return false}
        if _storage._anyInfo != other_storage._anyInfo {return false}
        if _storage._tags != other_storage._tags {return false}
        if _storage._tensorflowVersion != other_storage._tensorflowVersion {return false}
        if _storage._tensorflowGitVersion != other_storage._tensorflowGitVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_CollectionDef: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_list"),
    2: .standard(proto: "bytes_list"),
    3: .standard(proto: "int64_list"),
    4: .standard(proto: "float_list"),
    5: .standard(proto: "any_list"),
  ]

  fileprivate class _StorageClass {
    var _kind: Tensorflow_CollectionDef.OneOf_Kind?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _kind = source._kind
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_CollectionDef) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._kind != other_storage._kind {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_CollectionDef.NodeList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_CollectionDef.NodeList) -> Bool {
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_CollectionDef.BytesList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_CollectionDef.BytesList) -> Bool {
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_CollectionDef.Int64List: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_CollectionDef.Int64List) -> Bool {
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_CollectionDef.FloatList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_CollectionDef.FloatList) -> Bool {
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_CollectionDef.AnyList: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_CollectionDef.AnyList) -> Bool {
    if self.value != other.value {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_TensorInfo: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .standard(proto: "coo_sparse"),
    2: .same(proto: "dtype"),
    3: .standard(proto: "tensor_shape"),
  ]

  fileprivate class _StorageClass {
    var _encoding: Tensorflow_TensorInfo.OneOf_Encoding?
    var _dtype: Tensorflow_DataType = .dtInvalid
    var _tensorShape: Tensorflow_TensorShapeProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _encoding = source._encoding
      _dtype = source._dtype
      _tensorShape = source._tensorShape
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_TensorInfo) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._encoding != other_storage._encoding {return false}
        if _storage._dtype != other_storage._dtype {return false}
        if _storage._tensorShape != other_storage._tensorShape {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_TensorInfo.CooSparse: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "values_tensor_name"),
    2: .standard(proto: "indices_tensor_name"),
    3: .standard(proto: "dense_shape_tensor_name"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_TensorInfo.CooSparse) -> Bool {
    if self.valuesTensorName != other.valuesTensorName {return false}
    if self.indicesTensorName != other.indicesTensorName {return false}
    if self.denseShapeTensorName != other.denseShapeTensorName {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_SignatureDef: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
    3: .standard(proto: "method_name"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_SignatureDef) -> Bool {
    if self.inputs != other.inputs {return false}
    if self.outputs != other.outputs {return false}
    if self.methodName != other.methodName {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_AssetFileDef: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tensor_info"),
    2: .same(proto: "filename"),
  ]

  fileprivate class _StorageClass {
    var _tensorInfo: Tensorflow_TensorInfo? = nil
    var _filename: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tensorInfo = source._tensorInfo
      _filename = source._filename
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_AssetFileDef) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._tensorInfo != other_storage._tensorInfo {return false}
        if _storage._filename != other_storage._filename {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
