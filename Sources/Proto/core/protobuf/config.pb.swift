// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/core/protobuf/config.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Tensorflow_GPUOptions: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".GPUOptions"

  /// A value between 0 and 1 that indicates what fraction of the
  /// available GPU memory to pre-allocate for each process.  1 means
  /// to pre-allocate all of the GPU memory, 0.5 means the process
  /// allocates ~50% of the available GPU memory.
  public var perProcessGpuMemoryFraction: Double = 0

  /// The type of GPU allocation strategy to use.
  ///
  /// Allowed values:
  /// "": The empty string (default) uses a system-chosen default
  ///     which may change over time.
  ///
  /// "BFC": A "Best-fit with coalescing" algorithm, simplified from a
  ///        version of dlmalloc.
  public var allocatorType: String = String()

  /// Delay deletion of up to this many bytes to reduce the number of
  /// interactions with gpu driver code.  If 0, the system chooses
  /// a reasonable default (several MBs).
  public var deferredDeletionBytes: Int64 = 0

  /// If true, the allocator does not pre-allocate the entire specified
  /// GPU memory region, instead starting small and growing as needed.
  public var allowGrowth: Bool = false

  /// A comma-separated list of GPU ids that determines the 'visible'
  /// to 'virtual' mapping of GPU devices.  For example, if TensorFlow
  /// can see 8 GPU devices in the process, and one wanted to map
  /// visible GPU devices 5 and 3 as "/device:GPU:0", and "/device:GPU:1", then one
  /// would specify this field as "5,3".  This field is similar in
  /// spirit to the CUDA_VISIBLE_DEVICES environment variable, except
  /// it applies to the visible GPU devices in the process.
  ///
  /// NOTE: The GPU driver provides the process with the visible GPUs
  /// in an order which is not guaranteed to have any correlation to
  /// the *physical* GPU id in the machine.  This field is used for
  /// remapping "visible" to "virtual", which means this operates only
  /// after the process starts.  Users are required to use vendor
  /// specific mechanisms (e.g., CUDA_VISIBLE_DEVICES) to control the
  /// physical to visible device mapping prior to invoking TensorFlow.
  public var visibleDeviceList: String = String()

  /// In the event polling loop sleep this many microseconds between
  /// PollEvents calls, when the queue is not empty.  If value is not
  /// set or set to 0, gets set to a non-zero default.
  public var pollingActiveDelayUsecs: Int32 = 0

  /// In the event polling loop sleep this many millisconds between
  /// PollEvents calls, when the queue is empty.  If value is not
  /// set or set to 0, gets set to a non-zero default.
  public var pollingInactiveDelayMsecs: Int32 = 0

  /// Force all tensors to be gpu_compatible. On a GPU-enabled TensorFlow,
  /// enabling this option forces all CPU tensors to be allocated with Cuda
  /// pinned memory. Normally, TensorFlow will infer which tensors should be
  /// allocated as the pinned memory. But in case where the inference is
  /// incomplete, this option can significantly speed up the cross-device memory
  /// copy performance as long as it fits the memory.
  /// Note that this option is not something that should be
  /// enabled by default for unknown or very large models, since all Cuda pinned
  /// memory is unpageable, having too much pinned memory might negatively impact
  /// the overall host system performance.
  public var forceGpuCompatible: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.perProcessGpuMemoryFraction)
      case 2: try decoder.decodeSingularStringField(value: &self.allocatorType)
      case 3: try decoder.decodeSingularInt64Field(value: &self.deferredDeletionBytes)
      case 4: try decoder.decodeSingularBoolField(value: &self.allowGrowth)
      case 5: try decoder.decodeSingularStringField(value: &self.visibleDeviceList)
      case 6: try decoder.decodeSingularInt32Field(value: &self.pollingActiveDelayUsecs)
      case 7: try decoder.decodeSingularInt32Field(value: &self.pollingInactiveDelayMsecs)
      case 8: try decoder.decodeSingularBoolField(value: &self.forceGpuCompatible)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.perProcessGpuMemoryFraction != 0 {
      try visitor.visitSingularDoubleField(value: self.perProcessGpuMemoryFraction, fieldNumber: 1)
    }
    if !self.allocatorType.isEmpty {
      try visitor.visitSingularStringField(value: self.allocatorType, fieldNumber: 2)
    }
    if self.deferredDeletionBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.deferredDeletionBytes, fieldNumber: 3)
    }
    if self.allowGrowth != false {
      try visitor.visitSingularBoolField(value: self.allowGrowth, fieldNumber: 4)
    }
    if !self.visibleDeviceList.isEmpty {
      try visitor.visitSingularStringField(value: self.visibleDeviceList, fieldNumber: 5)
    }
    if self.pollingActiveDelayUsecs != 0 {
      try visitor.visitSingularInt32Field(value: self.pollingActiveDelayUsecs, fieldNumber: 6)
    }
    if self.pollingInactiveDelayMsecs != 0 {
      try visitor.visitSingularInt32Field(value: self.pollingInactiveDelayMsecs, fieldNumber: 7)
    }
    if self.forceGpuCompatible != false {
      try visitor.visitSingularBoolField(value: self.forceGpuCompatible, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Options passed to the graph optimizer
public struct Tensorflow_OptimizerOptions: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".OptimizerOptions"

  /// If true, optimize the graph using common subexpression elimination.
  public var doCommonSubexpressionElimination: Bool = false

  /// If true, perform constant folding optimization on the graph.
  public var doConstantFolding: Bool = false

  /// If true, perform function inlining on the graph.
  public var doFunctionInlining: Bool = false

  /// Overall optimization level. The actual optimizations applied will be the
  /// logical OR of the flags that this level implies and any flags already set.
  public var optLevel: Tensorflow_OptimizerOptions.Level = .l1

  public var globalJitLevel: Tensorflow_OptimizerOptions.GlobalJitLevel = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Optimization level
  public enum Level: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// L1 is the default level.
    /// Optimization performed at L1 :
    /// 1. Common subexpression elimination
    /// 2. Constant folding
    case l1 // = 0

    /// No optimizations
    case l0 // = -1
    case UNRECOGNIZED(Int)

    public init() {
      self = .l1
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case -1: self = .l0
      case 0: self = .l1
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .l0: return -1
      case .l1: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Control the use of the compiler/jit.  Experimental.
  public enum GlobalJitLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default setting ("off" now, but later expected to be "on")
    case `default` // = 0
    case off // = -1

    /// The following settings turn on compilation, with higher values being
    /// more aggressive.  Higher values may reduce opportunities for parallelism
    /// and may use more memory.  (At present, there is no distinction, but this
    /// is expected to change.)
    case on1 // = 1
    case on2 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case -1: self = .off
      case 0: self = .default
      case 1: self = .on1
      case 2: self = .on2
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .off: return -1
      case .default: return 0
      case .on1: return 1
      case .on2: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.doCommonSubexpressionElimination)
      case 2: try decoder.decodeSingularBoolField(value: &self.doConstantFolding)
      case 3: try decoder.decodeSingularEnumField(value: &self.optLevel)
      case 4: try decoder.decodeSingularBoolField(value: &self.doFunctionInlining)
      case 5: try decoder.decodeSingularEnumField(value: &self.globalJitLevel)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.doCommonSubexpressionElimination != false {
      try visitor.visitSingularBoolField(value: self.doCommonSubexpressionElimination, fieldNumber: 1)
    }
    if self.doConstantFolding != false {
      try visitor.visitSingularBoolField(value: self.doConstantFolding, fieldNumber: 2)
    }
    if self.optLevel != .l1 {
      try visitor.visitSingularEnumField(value: self.optLevel, fieldNumber: 3)
    }
    if self.doFunctionInlining != false {
      try visitor.visitSingularBoolField(value: self.doFunctionInlining, fieldNumber: 4)
    }
    if self.globalJitLevel != .default {
      try visitor.visitSingularEnumField(value: self.globalJitLevel, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_GraphOptions: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".GraphOptions"

  /// If true, use control flow to schedule the activation of Recv nodes.
  /// (Currently ignored.)
  public var enableRecvScheduling: Bool {
    get {return _storage._enableRecvScheduling}
    set {_uniqueStorage()._enableRecvScheduling = newValue}
  }

  /// Options controlling how graph is optimized.
  public var optimizerOptions: Tensorflow_OptimizerOptions {
    get {return _storage._optimizerOptions ?? Tensorflow_OptimizerOptions()}
    set {_uniqueStorage()._optimizerOptions = newValue}
  }
  /// Returns true if `optimizerOptions` has been explicitly set.
  public var hasOptimizerOptions: Bool {return _storage._optimizerOptions != nil}
  /// Clears the value of `optimizerOptions`. Subsequent reads from it will return its default value.
  public mutating func clearOptimizerOptions() {_storage._optimizerOptions = nil}

  /// The number of steps to run before returning a cost model detailing
  /// the memory usage and performance of each node of the graph. 0 means
  /// no cost model.
  public var buildCostModel: Int64 {
    get {return _storage._buildCostModel}
    set {_uniqueStorage()._buildCostModel = newValue}
  }

  /// The number of steps to skip before collecting statistics for the
  /// cost model.
  public var buildCostModelAfter: Int64 {
    get {return _storage._buildCostModelAfter}
    set {_uniqueStorage()._buildCostModelAfter = newValue}
  }

  /// Annotate each Node with Op output shape data, to the extent it can
  /// be statically inferred.
  public var inferShapes: Bool {
    get {return _storage._inferShapes}
    set {_uniqueStorage()._inferShapes = newValue}
  }

  /// Only place the subgraphs that are run, rather than the entire graph.
  ///
  /// This is useful for interactive graph building, where one might
  /// produce graphs that cannot be placed during the debugging
  /// process.  In particular, it allows the client to continue work in
  /// a session after adding a node to a graph whose placement
  /// constraints are unsatisfiable.
  public var placePrunedGraph: Bool {
    get {return _storage._placePrunedGraph}
    set {_uniqueStorage()._placePrunedGraph = newValue}
  }

  /// If true, transfer float values between processes as bfloat16.
  public var enableBfloat16Sendrecv: Bool {
    get {return _storage._enableBfloat16Sendrecv}
    set {_uniqueStorage()._enableBfloat16Sendrecv = newValue}
  }

  /// If > 0, record a timeline every this many steps.
  /// EXPERIMENTAL: This currently has no effect in MasterSession.
  public var timelineStep: Int32 {
    get {return _storage._timelineStep}
    set {_uniqueStorage()._timelineStep = newValue}
  }

  /// Options that control the type and amount of graph rewriting.
  /// Not currently configurable via the public Python API (i.e. there is no API
  /// stability guarantee if you import RewriterConfig explicitly).
  public var rewriteOptions: Tensorflow_RewriterConfig {
    get {return _storage._rewriteOptions ?? Tensorflow_RewriterConfig()}
    set {_uniqueStorage()._rewriteOptions = newValue}
  }
  /// Returns true if `rewriteOptions` has been explicitly set.
  public var hasRewriteOptions: Bool {return _storage._rewriteOptions != nil}
  /// Clears the value of `rewriteOptions`. Subsequent reads from it will return its default value.
  public mutating func clearRewriteOptions() {_storage._rewriteOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularBoolField(value: &_storage._enableRecvScheduling)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._optimizerOptions)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._buildCostModel)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._inferShapes)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._placePrunedGraph)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._enableBfloat16Sendrecv)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._timelineStep)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._buildCostModelAfter)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._rewriteOptions)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._enableRecvScheduling != false {
        try visitor.visitSingularBoolField(value: _storage._enableRecvScheduling, fieldNumber: 2)
      }
      if let v = _storage._optimizerOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._buildCostModel != 0 {
        try visitor.visitSingularInt64Field(value: _storage._buildCostModel, fieldNumber: 4)
      }
      if _storage._inferShapes != false {
        try visitor.visitSingularBoolField(value: _storage._inferShapes, fieldNumber: 5)
      }
      if _storage._placePrunedGraph != false {
        try visitor.visitSingularBoolField(value: _storage._placePrunedGraph, fieldNumber: 6)
      }
      if _storage._enableBfloat16Sendrecv != false {
        try visitor.visitSingularBoolField(value: _storage._enableBfloat16Sendrecv, fieldNumber: 7)
      }
      if _storage._timelineStep != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timelineStep, fieldNumber: 8)
      }
      if _storage._buildCostModelAfter != 0 {
        try visitor.visitSingularInt64Field(value: _storage._buildCostModelAfter, fieldNumber: 9)
      }
      if let v = _storage._rewriteOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tensorflow_ThreadPoolOptionProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ThreadPoolOptionProto"

  /// The number of threads in the pool.
  ///
  /// 0 means the system picks a value based on where this option proto is used
  /// (see the declaration of the specific field for more info).
  public var numThreads: Int32 = 0

  /// The global name of the threadpool.
  ///
  /// If empty, then the threadpool is made and used according to the scope it's
  /// in - e.g., for a session threadpool, it is used by that session only.
  ///
  /// If non-empty, then:
  /// - a global threadpool associated with this name is looked
  ///   up or created. This allows, for example, sharing one threadpool across
  ///   many sessions (e.g., like the default behavior, if
  ///   inter_op_parallelism_threads is not configured), but still partitioning
  ///   into a large and small pool.
  /// - if the threadpool for this global_name already exists, then it is an
  ///   error if the existing pool was created using a different num_threads
  ///   value as is specified on this call.
  /// - threadpools created this way are never garbage collected.
  public var globalName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.numThreads)
      case 2: try decoder.decodeSingularStringField(value: &self.globalName)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numThreads != 0 {
      try visitor.visitSingularInt32Field(value: self.numThreads, fieldNumber: 1)
    }
    if !self.globalName.isEmpty {
      try visitor.visitSingularStringField(value: self.globalName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

public struct Tensorflow_RPCOptions: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".RPCOptions"

  /// If true, always use RPC to contact the session target.
  ///
  /// If false (the default option), TensorFlow may use an optimized
  /// transport for client-master communication that avoids the RPC
  /// stack. This option is primarily for used testing the RPC stack.
  public var useRpcForInprocessMaster: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.useRpcForInprocessMaster)
      default: break
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useRpcForInprocessMaster != false {
      try visitor.visitSingularBoolField(value: self.useRpcForInprocessMaster, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

/// Session configuration parameters.
/// The system picks appropriate values for fields that are not set.
public struct Tensorflow_ConfigProto: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".ConfigProto"

  /// Map from device type name (e.g., "CPU" or "GPU" ) to maximum
  /// number of devices of that type to use.  If a particular device
  /// type is not found in the map, the system picks an appropriate
  /// number.
  public var deviceCount: Dictionary<String,Int32> {
    get {return _storage._deviceCount}
    set {_uniqueStorage()._deviceCount = newValue}
  }

  /// The execution of an individual op (for some op types) can be
  /// parallelized on a pool of intra_op_parallelism_threads.
  /// 0 means the system picks an appropriate number.
  public var intraOpParallelismThreads: Int32 {
    get {return _storage._intraOpParallelismThreads}
    set {_uniqueStorage()._intraOpParallelismThreads = newValue}
  }

  /// Nodes that perform blocking operations are enqueued on a pool of
  /// inter_op_parallelism_threads available in each process.
  ///
  /// 0 means the system picks an appropriate number.
  ///
  /// Note that the first Session created in the process sets the
  /// number of threads for all future sessions unless use_per_session_threads is
  /// true or session_inter_op_thread_pool is configured.
  public var interOpParallelismThreads: Int32 {
    get {return _storage._interOpParallelismThreads}
    set {_uniqueStorage()._interOpParallelismThreads = newValue}
  }

  /// If true, use a new set of threads for this session rather than the global
  /// pool of threads. Only supported by direct sessions.
  ///
  /// If false, use the global threads created by the first session, or the
  /// per-session thread pools configured by session_inter_op_thread_pool.
  ///
  /// This option is deprecated. The same effect can be achieved by setting
  /// session_inter_op_thread_pool to have one element, whose num_threads equals
  /// inter_op_parallelism_threads.
  public var usePerSessionThreads: Bool {
    get {return _storage._usePerSessionThreads}
    set {_uniqueStorage()._usePerSessionThreads = newValue}
  }

  /// This option is experimental - it may be replaced with a different mechanism
  /// in the future.
  ///
  /// Configures session thread pools. If this is configured, then RunOptions for
  /// a Run call can select the thread pool to use.
  ///
  /// The intended use is for when some session invocations need to run in a
  /// background pool limited to a small number of threads:
  /// - For example, a session may be configured to have one large pool (for
  /// regular compute) and one small pool (for periodic, low priority work);
  /// using the small pool is currently the mechanism for limiting the inter-op
  /// parallelism of the low priority work.  Note that it does not limit the
  /// parallelism of work spawned by a single op kernel implementation.
  /// - Using this setting is normally not needed in training, but may help some
  /// serving use cases.
  /// - It is also generally recommended to set the global_name field of this
  /// proto, to avoid creating multiple large pools. It is typically better to
  /// run the non-low-priority work, even across sessions, in a single large
  /// pool.
  public var sessionInterOpThreadPool: [Tensorflow_ThreadPoolOptionProto] {
    get {return _storage._sessionInterOpThreadPool}
    set {_uniqueStorage()._sessionInterOpThreadPool = newValue}
  }

  /// Assignment of Nodes to Devices is recomputed every placement_period
  /// steps until the system warms up (at which point the recomputation
  /// typically slows down automatically).
  public var placementPeriod: Int32 {
    get {return _storage._placementPeriod}
    set {_uniqueStorage()._placementPeriod = newValue}
  }

  /// When any filters are present sessions will ignore all devices which do not
  /// match the filters. Each filter can be partially specified, e.g. "/job:ps"
  /// "/job:worker/replica:3", etc.
  public var deviceFilters: [String] {
    get {return _storage._deviceFilters}
    set {_uniqueStorage()._deviceFilters = newValue}
  }

  /// Options that apply to all GPUs.
  public var gpuOptions: Tensorflow_GPUOptions {
    get {return _storage._gpuOptions ?? Tensorflow_GPUOptions()}
    set {_uniqueStorage()._gpuOptions = newValue}
  }
  /// Returns true if `gpuOptions` has been explicitly set.
  public var hasGpuOptions: Bool {return _storage._gpuOptions != nil}
  /// Clears the value of `gpuOptions`. Subsequent reads from it will return its default value.
  public mutating func clearGpuOptions() {_storage._gpuOptions = nil}

  /// Whether soft placement is allowed. If allow_soft_placement is true,
  /// an op will be placed on CPU if
  ///   1. there's no GPU implementation for the OP
  /// or
  ///   2. no GPU devices are known or registered
  /// or
  ///   3. need to co-locate with reftype input(s) which are from CPU.
  public var allowSoftPlacement: Bool {
    get {return _storage._allowSoftPlacement}
    set {_uniqueStorage()._allowSoftPlacement = newValue}
  }

  /// Whether device placements should be logged.
  public var logDevicePlacement: Bool {
    get {return _storage._logDevicePlacement}
    set {_uniqueStorage()._logDevicePlacement = newValue}
  }

  /// Options that apply to all graphs.
  public var graphOptions: Tensorflow_GraphOptions {
    get {return _storage._graphOptions ?? Tensorflow_GraphOptions()}
    set {_uniqueStorage()._graphOptions = newValue}
  }
  /// Returns true if `graphOptions` has been explicitly set.
  public var hasGraphOptions: Bool {return _storage._graphOptions != nil}
  /// Clears the value of `graphOptions`. Subsequent reads from it will return its default value.
  public mutating func clearGraphOptions() {_storage._graphOptions = nil}

  /// Global timeout for all blocking operations in this session.  If non-zero,
  /// and not overridden on a per-operation basis, this value will be used as the
  /// deadline for all blocking operations.
  public var operationTimeoutInMs: Int64 {
    get {return _storage._operationTimeoutInMs}
    set {_uniqueStorage()._operationTimeoutInMs = newValue}
  }

  /// Options that apply when this session uses the distributed runtime.
  public var rpcOptions: Tensorflow_RPCOptions {
    get {return _storage._rpcOptions ?? Tensorflow_RPCOptions()}
    set {_uniqueStorage()._rpcOptions = newValue}
  }
  /// Returns true if `rpcOptions` has been explicitly set.
  public var hasRpcOptions: Bool {return _storage._rpcOptions != nil}
  /// Clears the value of `rpcOptions`. Subsequent reads from it will return its default value.
  public mutating func clearRpcOptions() {_storage._rpcOptions = nil}

  /// Optional list of all workers to use in this session.
  public var clusterDef: Tensorflow_ClusterDef {
    get {return _storage._clusterDef ?? Tensorflow_ClusterDef()}
    set {_uniqueStorage()._clusterDef = newValue}
  }
  /// Returns true if `clusterDef` has been explicitly set.
  public var hasClusterDef: Bool {return _storage._clusterDef != nil}
  /// Clears the value of `clusterDef`. Subsequent reads from it will return its default value.
  public mutating func clearClusterDef() {_storage._clusterDef = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &_storage._deviceCount)
        case 2: try decoder.decodeSingularInt32Field(value: &_storage._intraOpParallelismThreads)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._placementPeriod)
        case 4: try decoder.decodeRepeatedStringField(value: &_storage._deviceFilters)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._interOpParallelismThreads)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._gpuOptions)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._allowSoftPlacement)
        case 8: try decoder.decodeSingularBoolField(value: &_storage._logDevicePlacement)
        case 9: try decoder.decodeSingularBoolField(value: &_storage._usePerSessionThreads)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._graphOptions)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._operationTimeoutInMs)
        case 12: try decoder.decodeRepeatedMessageField(value: &_storage._sessionInterOpThreadPool)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._rpcOptions)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._clusterDef)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._deviceCount.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: _storage._deviceCount, fieldNumber: 1)
      }
      if _storage._intraOpParallelismThreads != 0 {
        try visitor.visitSingularInt32Field(value: _storage._intraOpParallelismThreads, fieldNumber: 2)
      }
      if _storage._placementPeriod != 0 {
        try visitor.visitSingularInt32Field(value: _storage._placementPeriod, fieldNumber: 3)
      }
      if !_storage._deviceFilters.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._deviceFilters, fieldNumber: 4)
      }
      if _storage._interOpParallelismThreads != 0 {
        try visitor.visitSingularInt32Field(value: _storage._interOpParallelismThreads, fieldNumber: 5)
      }
      if let v = _storage._gpuOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._allowSoftPlacement != false {
        try visitor.visitSingularBoolField(value: _storage._allowSoftPlacement, fieldNumber: 7)
      }
      if _storage._logDevicePlacement != false {
        try visitor.visitSingularBoolField(value: _storage._logDevicePlacement, fieldNumber: 8)
      }
      if _storage._usePerSessionThreads != false {
        try visitor.visitSingularBoolField(value: _storage._usePerSessionThreads, fieldNumber: 9)
      }
      if let v = _storage._graphOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._operationTimeoutInMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._operationTimeoutInMs, fieldNumber: 11)
      }
      if !_storage._sessionInterOpThreadPool.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sessionInterOpThreadPool, fieldNumber: 12)
      }
      if let v = _storage._rpcOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._clusterDef {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Options for a single Run() call.
public struct Tensorflow_RunOptions: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".RunOptions"

  public var traceLevel: Tensorflow_RunOptions.TraceLevel {
    get {return _storage._traceLevel}
    set {_uniqueStorage()._traceLevel = newValue}
  }

  /// Time to wait for operation to complete in milliseconds.
  public var timeoutInMs: Int64 {
    get {return _storage._timeoutInMs}
    set {_uniqueStorage()._timeoutInMs = newValue}
  }

  /// The thread pool to use, if session_inter_op_thread_pool is configured.
  public var interOpThreadPool: Int32 {
    get {return _storage._interOpThreadPool}
    set {_uniqueStorage()._interOpThreadPool = newValue}
  }

  /// Whether the partition graph(s) executed by the executor(s) should be
  /// outputted via RunMetadata.
  public var outputPartitionGraphs: Bool {
    get {return _storage._outputPartitionGraphs}
    set {_uniqueStorage()._outputPartitionGraphs = newValue}
  }

  /// EXPERIMENTAL.  Options used to initialize DebuggerState, if enabled.
  public var debugOptions: Tensorflow_DebugOptions {
    get {return _storage._debugOptions ?? Tensorflow_DebugOptions()}
    set {_uniqueStorage()._debugOptions = newValue}
  }
  /// Returns true if `debugOptions` has been explicitly set.
  public var hasDebugOptions: Bool {return _storage._debugOptions != nil}
  /// Clears the value of `debugOptions`. Subsequent reads from it will return its default value.
  public mutating func clearDebugOptions() {_storage._debugOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// TODO(pbar) Turn this into a TraceOptions proto which allows
  /// tracing to be controlled in a more orthogonal manner?
  public enum TraceLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case noTrace // = 0
    case softwareTrace // = 1
    case hardwareTrace // = 2
    case fullTrace // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .noTrace
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .noTrace
      case 1: self = .softwareTrace
      case 2: self = .hardwareTrace
      case 3: self = .fullTrace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .noTrace: return 0
      case .softwareTrace: return 1
      case .hardwareTrace: return 2
      case .fullTrace: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._traceLevel)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._timeoutInMs)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._interOpThreadPool)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._outputPartitionGraphs)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._debugOptions)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._traceLevel != .noTrace {
        try visitor.visitSingularEnumField(value: _storage._traceLevel, fieldNumber: 1)
      }
      if _storage._timeoutInMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timeoutInMs, fieldNumber: 2)
      }
      if _storage._interOpThreadPool != 0 {
        try visitor.visitSingularInt32Field(value: _storage._interOpThreadPool, fieldNumber: 3)
      }
      if _storage._outputPartitionGraphs != false {
        try visitor.visitSingularBoolField(value: _storage._outputPartitionGraphs, fieldNumber: 5)
      }
      if let v = _storage._debugOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Metadata output (i.e., non-Tensor) for a single Run() call.
public struct Tensorflow_RunMetadata: SwiftProtobuf.Message {
  public static let protoMessageName: String = _protobuf_package + ".RunMetadata"

  /// Statistics traced for this step. Populated if tracing is turned on via the
  /// "RunOptions" proto.
  /// EXPERIMENTAL: The format and set of events may change in future versions.
  public var stepStats: Tensorflow_StepStats {
    get {return _storage._stepStats ?? Tensorflow_StepStats()}
    set {_uniqueStorage()._stepStats = newValue}
  }
  /// Returns true if `stepStats` has been explicitly set.
  public var hasStepStats: Bool {return _storage._stepStats != nil}
  /// Clears the value of `stepStats`. Subsequent reads from it will return its default value.
  public mutating func clearStepStats() {_storage._stepStats = nil}

  /// The cost graph for the computation defined by the run call.
  public var costGraph: Tensorflow_CostGraphDef {
    get {return _storage._costGraph ?? Tensorflow_CostGraphDef()}
    set {_uniqueStorage()._costGraph = newValue}
  }
  /// Returns true if `costGraph` has been explicitly set.
  public var hasCostGraph: Bool {return _storage._costGraph != nil}
  /// Clears the value of `costGraph`. Subsequent reads from it will return its default value.
  public mutating func clearCostGraph() {_storage._costGraph = nil}

  /// Graphs of the partitions executed by executors.
  public var partitionGraphs: [Tensorflow_GraphDef] {
    get {return _storage._partitionGraphs}
    set {_uniqueStorage()._partitionGraphs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  /// Used by the decoding initializers in the SwiftProtobuf library, not generally
  /// used directly. `init(serializedData:)`, `init(jsonUTF8Data:)`, and other decoding
  /// initializers are defined in the SwiftProtobuf library. See the Message and
  /// Message+*Additions` files.
  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._stepStats)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._costGraph)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._partitionGraphs)
        default: break
        }
      }
    }
  }

  /// Used by the encoding methods of the SwiftProtobuf library, not generally
  /// used directly. `Message.serializedData()`, `Message.jsonUTF8Data()`, and
  /// other serializer methods are defined in the SwiftProtobuf library. See the
  /// `Message` and `Message+*Additions` files.
  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._stepStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._costGraph {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._partitionGraphs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._partitionGraphs, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow"

extension Tensorflow_GPUOptions: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "per_process_gpu_memory_fraction"),
    2: .standard(proto: "allocator_type"),
    3: .standard(proto: "deferred_deletion_bytes"),
    4: .standard(proto: "allow_growth"),
    5: .standard(proto: "visible_device_list"),
    6: .standard(proto: "polling_active_delay_usecs"),
    7: .standard(proto: "polling_inactive_delay_msecs"),
    8: .standard(proto: "force_gpu_compatible"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_GPUOptions) -> Bool {
    if self.perProcessGpuMemoryFraction != other.perProcessGpuMemoryFraction {return false}
    if self.allocatorType != other.allocatorType {return false}
    if self.deferredDeletionBytes != other.deferredDeletionBytes {return false}
    if self.allowGrowth != other.allowGrowth {return false}
    if self.visibleDeviceList != other.visibleDeviceList {return false}
    if self.pollingActiveDelayUsecs != other.pollingActiveDelayUsecs {return false}
    if self.pollingInactiveDelayMsecs != other.pollingInactiveDelayMsecs {return false}
    if self.forceGpuCompatible != other.forceGpuCompatible {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_OptimizerOptions: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "do_common_subexpression_elimination"),
    2: .standard(proto: "do_constant_folding"),
    4: .standard(proto: "do_function_inlining"),
    3: .standard(proto: "opt_level"),
    5: .standard(proto: "global_jit_level"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_OptimizerOptions) -> Bool {
    if self.doCommonSubexpressionElimination != other.doCommonSubexpressionElimination {return false}
    if self.doConstantFolding != other.doConstantFolding {return false}
    if self.doFunctionInlining != other.doFunctionInlining {return false}
    if self.optLevel != other.optLevel {return false}
    if self.globalJitLevel != other.globalJitLevel {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_OptimizerOptions.Level: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "L0"),
    0: .same(proto: "L1"),
  ]
}

extension Tensorflow_OptimizerOptions.GlobalJitLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    -1: .same(proto: "OFF"),
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "ON_1"),
    2: .same(proto: "ON_2"),
  ]
}

extension Tensorflow_GraphOptions: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "enable_recv_scheduling"),
    3: .standard(proto: "optimizer_options"),
    4: .standard(proto: "build_cost_model"),
    9: .standard(proto: "build_cost_model_after"),
    5: .standard(proto: "infer_shapes"),
    6: .standard(proto: "place_pruned_graph"),
    7: .standard(proto: "enable_bfloat16_sendrecv"),
    8: .standard(proto: "timeline_step"),
    10: .standard(proto: "rewrite_options"),
  ]

  fileprivate class _StorageClass {
    var _enableRecvScheduling: Bool = false
    var _optimizerOptions: Tensorflow_OptimizerOptions? = nil
    var _buildCostModel: Int64 = 0
    var _buildCostModelAfter: Int64 = 0
    var _inferShapes: Bool = false
    var _placePrunedGraph: Bool = false
    var _enableBfloat16Sendrecv: Bool = false
    var _timelineStep: Int32 = 0
    var _rewriteOptions: Tensorflow_RewriterConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _enableRecvScheduling = source._enableRecvScheduling
      _optimizerOptions = source._optimizerOptions
      _buildCostModel = source._buildCostModel
      _buildCostModelAfter = source._buildCostModelAfter
      _inferShapes = source._inferShapes
      _placePrunedGraph = source._placePrunedGraph
      _enableBfloat16Sendrecv = source._enableBfloat16Sendrecv
      _timelineStep = source._timelineStep
      _rewriteOptions = source._rewriteOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_GraphOptions) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._enableRecvScheduling != other_storage._enableRecvScheduling {return false}
        if _storage._optimizerOptions != other_storage._optimizerOptions {return false}
        if _storage._buildCostModel != other_storage._buildCostModel {return false}
        if _storage._buildCostModelAfter != other_storage._buildCostModelAfter {return false}
        if _storage._inferShapes != other_storage._inferShapes {return false}
        if _storage._placePrunedGraph != other_storage._placePrunedGraph {return false}
        if _storage._enableBfloat16Sendrecv != other_storage._enableBfloat16Sendrecv {return false}
        if _storage._timelineStep != other_storage._timelineStep {return false}
        if _storage._rewriteOptions != other_storage._rewriteOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_ThreadPoolOptionProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_threads"),
    2: .standard(proto: "global_name"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_ThreadPoolOptionProto) -> Bool {
    if self.numThreads != other.numThreads {return false}
    if self.globalName != other.globalName {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_RPCOptions: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_rpc_for_inprocess_master"),
  ]

  public func _protobuf_generated_isEqualTo(other: Tensorflow_RPCOptions) -> Bool {
    if self.useRpcForInprocessMaster != other.useRpcForInprocessMaster {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_ConfigProto: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_count"),
    2: .standard(proto: "intra_op_parallelism_threads"),
    5: .standard(proto: "inter_op_parallelism_threads"),
    9: .standard(proto: "use_per_session_threads"),
    12: .standard(proto: "session_inter_op_thread_pool"),
    3: .standard(proto: "placement_period"),
    4: .standard(proto: "device_filters"),
    6: .standard(proto: "gpu_options"),
    7: .standard(proto: "allow_soft_placement"),
    8: .standard(proto: "log_device_placement"),
    10: .standard(proto: "graph_options"),
    11: .standard(proto: "operation_timeout_in_ms"),
    13: .standard(proto: "rpc_options"),
    14: .standard(proto: "cluster_def"),
  ]

  fileprivate class _StorageClass {
    var _deviceCount: Dictionary<String,Int32> = [:]
    var _intraOpParallelismThreads: Int32 = 0
    var _interOpParallelismThreads: Int32 = 0
    var _usePerSessionThreads: Bool = false
    var _sessionInterOpThreadPool: [Tensorflow_ThreadPoolOptionProto] = []
    var _placementPeriod: Int32 = 0
    var _deviceFilters: [String] = []
    var _gpuOptions: Tensorflow_GPUOptions? = nil
    var _allowSoftPlacement: Bool = false
    var _logDevicePlacement: Bool = false
    var _graphOptions: Tensorflow_GraphOptions? = nil
    var _operationTimeoutInMs: Int64 = 0
    var _rpcOptions: Tensorflow_RPCOptions? = nil
    var _clusterDef: Tensorflow_ClusterDef? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _deviceCount = source._deviceCount
      _intraOpParallelismThreads = source._intraOpParallelismThreads
      _interOpParallelismThreads = source._interOpParallelismThreads
      _usePerSessionThreads = source._usePerSessionThreads
      _sessionInterOpThreadPool = source._sessionInterOpThreadPool
      _placementPeriod = source._placementPeriod
      _deviceFilters = source._deviceFilters
      _gpuOptions = source._gpuOptions
      _allowSoftPlacement = source._allowSoftPlacement
      _logDevicePlacement = source._logDevicePlacement
      _graphOptions = source._graphOptions
      _operationTimeoutInMs = source._operationTimeoutInMs
      _rpcOptions = source._rpcOptions
      _clusterDef = source._clusterDef
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_ConfigProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._deviceCount != other_storage._deviceCount {return false}
        if _storage._intraOpParallelismThreads != other_storage._intraOpParallelismThreads {return false}
        if _storage._interOpParallelismThreads != other_storage._interOpParallelismThreads {return false}
        if _storage._usePerSessionThreads != other_storage._usePerSessionThreads {return false}
        if _storage._sessionInterOpThreadPool != other_storage._sessionInterOpThreadPool {return false}
        if _storage._placementPeriod != other_storage._placementPeriod {return false}
        if _storage._deviceFilters != other_storage._deviceFilters {return false}
        if _storage._gpuOptions != other_storage._gpuOptions {return false}
        if _storage._allowSoftPlacement != other_storage._allowSoftPlacement {return false}
        if _storage._logDevicePlacement != other_storage._logDevicePlacement {return false}
        if _storage._graphOptions != other_storage._graphOptions {return false}
        if _storage._operationTimeoutInMs != other_storage._operationTimeoutInMs {return false}
        if _storage._rpcOptions != other_storage._rpcOptions {return false}
        if _storage._clusterDef != other_storage._clusterDef {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_RunOptions: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_level"),
    2: .standard(proto: "timeout_in_ms"),
    3: .standard(proto: "inter_op_thread_pool"),
    5: .standard(proto: "output_partition_graphs"),
    6: .standard(proto: "debug_options"),
  ]

  fileprivate class _StorageClass {
    var _traceLevel: Tensorflow_RunOptions.TraceLevel = .noTrace
    var _timeoutInMs: Int64 = 0
    var _interOpThreadPool: Int32 = 0
    var _outputPartitionGraphs: Bool = false
    var _debugOptions: Tensorflow_DebugOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _traceLevel = source._traceLevel
      _timeoutInMs = source._timeoutInMs
      _interOpThreadPool = source._interOpThreadPool
      _outputPartitionGraphs = source._outputPartitionGraphs
      _debugOptions = source._debugOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_RunOptions) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._traceLevel != other_storage._traceLevel {return false}
        if _storage._timeoutInMs != other_storage._timeoutInMs {return false}
        if _storage._interOpThreadPool != other_storage._interOpThreadPool {return false}
        if _storage._outputPartitionGraphs != other_storage._outputPartitionGraphs {return false}
        if _storage._debugOptions != other_storage._debugOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_RunOptions.TraceLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_TRACE"),
    1: .same(proto: "SOFTWARE_TRACE"),
    2: .same(proto: "HARDWARE_TRACE"),
    3: .same(proto: "FULL_TRACE"),
  ]
}

extension Tensorflow_RunMetadata: SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_stats"),
    2: .standard(proto: "cost_graph"),
    3: .standard(proto: "partition_graphs"),
  ]

  fileprivate class _StorageClass {
    var _stepStats: Tensorflow_StepStats? = nil
    var _costGraph: Tensorflow_CostGraphDef? = nil
    var _partitionGraphs: [Tensorflow_GraphDef] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stepStats = source._stepStats
      _costGraph = source._costGraph
      _partitionGraphs = source._partitionGraphs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_RunMetadata) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._stepStats != other_storage._stepStats {return false}
        if _storage._costGraph != other_storage._costGraph {return false}
        if _storage._partitionGraphs != other_storage._partitionGraphs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
