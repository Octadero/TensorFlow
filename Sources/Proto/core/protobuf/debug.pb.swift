// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/core/protobuf/debug.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// EXPERIMENTAL. Option for watching a node.
public struct Tensorflow_DebugTensorWatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the node to watch.
  public var nodeName: String = String()

  /// Output slot to watch.
  /// The semantics of output_slot == -1 is that the node is only watched for
  /// completion, but not for any output tensors. See NodeCompletionCallback
  /// in debug_gateway.h.
  /// TODO(cais): Implement this semantics.
  public var outputSlot: Int32 = 0

  /// Name(s) of the debugging op(s).
  /// One or more than one probes on a tensor.
  /// e.g., {"DebugIdentity", "DebugNanCount"}
  public var debugOps: [String] = []

  /// URL(s) for debug targets(s).
  ///
  /// Supported URL formats are:
  ///   - file:///foo/tfdbg_dump: Writes out Event content to file
  ///     /foo/tfdbg_dump.  Assumes all directories can be created if they don't
  ///     already exist.
  ///   - grpc://localhost:11011: Sends an RPC request to an EventListener
  ///     service running at localhost:11011 with the event.
  ///   - memcbk:///event_key: Routes tensors to clients using the
  ///     callback registered with the DebugCallbackRegistry for event_key.
  ///
  /// Each debug op listed in debug_ops will publish its output tensor (debug
  /// signal) to all URLs in debug_urls.
  ///
  /// N.B. Session::Run() supports concurrent invocations of the same inputs
  /// (feed keys), outputs and target nodes. If such concurrent invocations
  /// are to be debugged, the callers of Session::Run() must use distinct
  /// debug_urls to make sure that the streamed or dumped events do not overlap
  /// among the invocations.
  /// TODO(cais): More visible documentation of this in g3docs.
  public var debugUrls: [String] = []

  /// Do not error out if debug op creation fails (e.g., due to dtype
  /// incompatibility). Instead, just log the failure.
  public var tolerateDebugOpCreationFailures: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// EXPERIMENTAL. Options for initializing DebuggerState.
public struct Tensorflow_DebugOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Debugging options
  public var debugTensorWatchOpts: [Tensorflow_DebugTensorWatch] = []

  /// Caller-specified global step count.
  /// Note that this is distinct from the session run count and the executor
  /// step count.
  public var globalStep: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_DebuggedSourceFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The host name on which a source code file is located.
  public var host: String = String()

  /// Path to the source code file.
  public var filePath: String = String()

  /// The timestamp at which the source code file is last modified.
  public var lastModified: Int64 = 0

  /// Byte size of the file.
  public var bytes: Int64 = 0

  /// Line-by-line content of the source code file.
  public var lines: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tensorflow_DebuggedSourceFiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of source code files.
  public var sourceFiles: [Tensorflow_DebuggedSourceFile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tensorflow"

extension Tensorflow_DebugTensorWatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DebugTensorWatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_name"),
    2: .standard(proto: "output_slot"),
    3: .standard(proto: "debug_ops"),
    4: .standard(proto: "debug_urls"),
    5: .standard(proto: "tolerate_debug_op_creation_failures"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.nodeName)
      case 2: try decoder.decodeSingularInt32Field(value: &self.outputSlot)
      case 3: try decoder.decodeRepeatedStringField(value: &self.debugOps)
      case 4: try decoder.decodeRepeatedStringField(value: &self.debugUrls)
      case 5: try decoder.decodeSingularBoolField(value: &self.tolerateDebugOpCreationFailures)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeName.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeName, fieldNumber: 1)
    }
    if self.outputSlot != 0 {
      try visitor.visitSingularInt32Field(value: self.outputSlot, fieldNumber: 2)
    }
    if !self.debugOps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.debugOps, fieldNumber: 3)
    }
    if !self.debugUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.debugUrls, fieldNumber: 4)
    }
    if self.tolerateDebugOpCreationFailures != false {
      try visitor.visitSingularBoolField(value: self.tolerateDebugOpCreationFailures, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DebugTensorWatch) -> Bool {
    if self.nodeName != other.nodeName {return false}
    if self.outputSlot != other.outputSlot {return false}
    if self.debugOps != other.debugOps {return false}
    if self.debugUrls != other.debugUrls {return false}
    if self.tolerateDebugOpCreationFailures != other.tolerateDebugOpCreationFailures {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DebugOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DebugOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "debug_tensor_watch_opts"),
    10: .standard(proto: "global_step"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 4: try decoder.decodeRepeatedMessageField(value: &self.debugTensorWatchOpts)
      case 10: try decoder.decodeSingularInt64Field(value: &self.globalStep)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debugTensorWatchOpts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.debugTensorWatchOpts, fieldNumber: 4)
    }
    if self.globalStep != 0 {
      try visitor.visitSingularInt64Field(value: self.globalStep, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DebugOptions) -> Bool {
    if self.debugTensorWatchOpts != other.debugTensorWatchOpts {return false}
    if self.globalStep != other.globalStep {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DebuggedSourceFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DebuggedSourceFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .standard(proto: "file_path"),
    3: .standard(proto: "last_modified"),
    4: .same(proto: "bytes"),
    5: .same(proto: "lines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.host)
      case 2: try decoder.decodeSingularStringField(value: &self.filePath)
      case 3: try decoder.decodeSingularInt64Field(value: &self.lastModified)
      case 4: try decoder.decodeSingularInt64Field(value: &self.bytes)
      case 5: try decoder.decodeRepeatedStringField(value: &self.lines)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 2)
    }
    if self.lastModified != 0 {
      try visitor.visitSingularInt64Field(value: self.lastModified, fieldNumber: 3)
    }
    if self.bytes != 0 {
      try visitor.visitSingularInt64Field(value: self.bytes, fieldNumber: 4)
    }
    if !self.lines.isEmpty {
      try visitor.visitRepeatedStringField(value: self.lines, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DebuggedSourceFile) -> Bool {
    if self.host != other.host {return false}
    if self.filePath != other.filePath {return false}
    if self.lastModified != other.lastModified {return false}
    if self.bytes != other.bytes {return false}
    if self.lines != other.lines {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Tensorflow_DebuggedSourceFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DebuggedSourceFiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sourceFiles)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sourceFiles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Tensorflow_DebuggedSourceFiles) -> Bool {
    if self.sourceFiles != other.sourceFiles {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
