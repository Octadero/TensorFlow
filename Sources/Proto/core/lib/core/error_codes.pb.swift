// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/core/lib/core/error_codes.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The canonical error codes for TensorFlow APIs.
///
/// Warnings:
///
/// -   Do not change any numeric assignments.
/// -   Changes to this list should only be made if there is a compelling
///     need that can't be satisfied in another way.  Such changes
///     must be approved by at least two OWNERS.
///
/// Sometimes multiple error codes may apply.  Services should return
/// the most specific error code that applies.  For example, prefer
/// OUT_OF_RANGE over FAILED_PRECONDITION if both codes apply.
/// Similarly prefer NOT_FOUND or ALREADY_EXISTS over FAILED_PRECONDITION.
public enum Tensorflow_Error_Code: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not an error; returned on success
  case ok // = 0

  /// The operation was cancelled (typically by the caller).
  case cancelled // = 1

  /// Unknown error.  An example of where this error may be returned is
  /// if a Status value received from another address space belongs to
  /// an error-space that is not known in this address space.  Also
  /// errors raised by APIs that do not return enough error information
  /// may be converted to this error.
  case unknown // = 2

  /// Client specified an invalid argument.  Note that this differs
  /// from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
  /// that are problematic regardless of the state of the system
  /// (e.g., a malformed file name).
  case invalidArgument // = 3

  /// Deadline expired before operation could complete.  For operations
  /// that change the state of the system, this error may be returned
  /// even if the operation has completed successfully.  For example, a
  /// successful response from a server could have been delayed long
  /// enough for the deadline to expire.
  case deadlineExceeded // = 4

  /// Some requested entity (e.g., file or directory) was not found.
  /// For privacy reasons, this code *may* be returned when the client
  /// does not have the access right to the entity.
  case notFound // = 5

  /// Some entity that we attempted to create (e.g., file or directory)
  /// already exists.
  case alreadyExists // = 6

  /// The caller does not have permission to execute the specified
  /// operation.  PERMISSION_DENIED must not be used for rejections
  /// caused by exhausting some resource (use RESOURCE_EXHAUSTED
  /// instead for those errors).  PERMISSION_DENIED must not be
  /// used if the caller can not be identified (use UNAUTHENTICATED
  /// instead for those errors).
  case permissionDenied // = 7

  /// The request does not have valid authentication credentials for the
  /// operation.
  case unauthenticated // = 16

  /// Some resource has been exhausted, perhaps a per-user quota, or
  /// perhaps the entire file system is out of space.
  case resourceExhausted // = 8

  /// Operation was rejected because the system is not in a state
  /// required for the operation's execution.  For example, directory
  /// to be deleted may be non-empty, an rmdir operation is applied to
  /// a non-directory, etc.
  ///
  /// A litmus test that may help a service implementor in deciding
  /// between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
  ///  (a) Use UNAVAILABLE if the client can retry just the failing call.
  ///  (b) Use ABORTED if the client should retry at a higher-level
  ///      (e.g., restarting a read-modify-write sequence).
  ///  (c) Use FAILED_PRECONDITION if the client should not retry until
  ///      the system state has been explicitly fixed.  E.g., if an "rmdir"
  ///      fails because the directory is non-empty, FAILED_PRECONDITION
  ///      should be returned since the client should not retry unless
  ///      they have first fixed up the directory by deleting files from it.
  ///  (d) Use FAILED_PRECONDITION if the client performs conditional
  ///      REST Get/Update/Delete on a resource and the resource on the
  ///      server does not match the condition. E.g., conflicting
  ///      read-modify-write on the same resource.
  case failedPrecondition // = 9

  /// The operation was aborted, typically due to a concurrency issue
  /// like sequencer check failures, transaction aborts, etc.
  ///
  /// See litmus test above for deciding between FAILED_PRECONDITION,
  /// ABORTED, and UNAVAILABLE.
  case aborted // = 10

  /// Operation tried to iterate past the valid input range.  E.g., seeking or
  /// reading past end of file.
  ///
  /// Unlike INVALID_ARGUMENT, this error indicates a problem that may
  /// be fixed if the system state changes. For example, a 32-bit file
  /// system will generate INVALID_ARGUMENT if asked to read at an
  /// offset that is not in the range [0,2^32-1], but it will generate
  /// OUT_OF_RANGE if asked to read from an offset past the current
  /// file size.
  ///
  /// There is a fair bit of overlap between FAILED_PRECONDITION and
  /// OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
  /// error) when it applies so that callers who are iterating through
  /// a space can easily look for an OUT_OF_RANGE error to detect when
  /// they are done.
  case outOfRange // = 11

  /// Operation is not implemented or not supported/enabled in this service.
  case unimplemented // = 12

  /// Internal errors.  Means some invariants expected by underlying
  /// system has been broken.  If you see one of these errors,
  /// something is very broken.
  case `internal` // = 13

  /// The service is currently unavailable.  This is a most likely a
  /// transient condition and may be corrected by retrying with
  /// a backoff.
  ///
  /// See litmus test above for deciding between FAILED_PRECONDITION,
  /// ABORTED, and UNAVAILABLE.
  case unavailable // = 14

  /// Unrecoverable data loss or corruption.
  case dataLoss // = 15

  /// An extra enum entry to prevent people from writing code that
  /// fails to compile when a new code is added.
  ///
  /// Nobody should ever reference this enumeration entry. In particular,
  /// if you write C++ code that switches on this enumeration, add a default:
  /// case instead of a case that mentions this enumeration entry.
  ///
  /// Nobody should rely on the value (currently 20) listed here.  It
  /// may change in the future.
  case doNotUseReservedForFutureExpansionUseDefaultInSwitchInstead_ // = 20
  case UNRECOGNIZED(Int)

  public init() {
    self = .ok
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .cancelled
    case 2: self = .unknown
    case 3: self = .invalidArgument
    case 4: self = .deadlineExceeded
    case 5: self = .notFound
    case 6: self = .alreadyExists
    case 7: self = .permissionDenied
    case 8: self = .resourceExhausted
    case 9: self = .failedPrecondition
    case 10: self = .aborted
    case 11: self = .outOfRange
    case 12: self = .unimplemented
    case 13: self = .internal
    case 14: self = .unavailable
    case 15: self = .dataLoss
    case 16: self = .unauthenticated
    case 20: self = .doNotUseReservedForFutureExpansionUseDefaultInSwitchInstead_
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ok: return 0
    case .cancelled: return 1
    case .unknown: return 2
    case .invalidArgument: return 3
    case .deadlineExceeded: return 4
    case .notFound: return 5
    case .alreadyExists: return 6
    case .permissionDenied: return 7
    case .resourceExhausted: return 8
    case .failedPrecondition: return 9
    case .aborted: return 10
    case .outOfRange: return 11
    case .unimplemented: return 12
    case .internal: return 13
    case .unavailable: return 14
    case .dataLoss: return 15
    case .unauthenticated: return 16
    case .doNotUseReservedForFutureExpansionUseDefaultInSwitchInstead_: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Tensorflow_Error_Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "CANCELLED"),
    2: .same(proto: "UNKNOWN"),
    3: .same(proto: "INVALID_ARGUMENT"),
    4: .same(proto: "DEADLINE_EXCEEDED"),
    5: .same(proto: "NOT_FOUND"),
    6: .same(proto: "ALREADY_EXISTS"),
    7: .same(proto: "PERMISSION_DENIED"),
    8: .same(proto: "RESOURCE_EXHAUSTED"),
    9: .same(proto: "FAILED_PRECONDITION"),
    10: .same(proto: "ABORTED"),
    11: .same(proto: "OUT_OF_RANGE"),
    12: .same(proto: "UNIMPLEMENTED"),
    13: .same(proto: "INTERNAL"),
    14: .same(proto: "UNAVAILABLE"),
    15: .same(proto: "DATA_LOSS"),
    16: .same(proto: "UNAUTHENTICATED"),
    20: .same(proto: "DO_NOT_USE_RESERVED_FOR_FUTURE_EXPANSION_USE_DEFAULT_IN_SWITCH_INSTEAD_"),
  ]
}
