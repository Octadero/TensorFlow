// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/compiler/xla/xla_data.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//==============================================================================

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Primitive types are the individual values that can be held in rectangular
/// multidimensional arrays. A description of the rectangular multidimensional
/// array dimensions / primitive type is given by Shape, below.
public enum Xla_PrimitiveType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Invalid primitive type to serve as default.
  case invalid // = 0

  /// Predicates are two-state booleans.
  case pred // = 1

  /// Signed integral values of fixed width.
  case s8 // = 2
  case s16 // = 3
  case s32 // = 4
  case s64 // = 5

  /// Unsigned integral values of fixed width.
  case u8 // = 6
  case u16 // = 7
  case u32 // = 8
  case u64 // = 9

  /// Floating-point values of fixed width.
  ///
  /// Note: if f16s are not natively supported on the device, they will be
  /// converted to f16 from f32 at arbirary points in the computation.
  case f16 // = 10
  case f32 // = 11

  /// Truncated 16 bit floating-point format. This is similar to IEEE's 16 bit
  /// floating-point format, but uses 1 bit for the sign, 8 bits for the exponent
  /// and 7 bits for the mantissa.
  case bf16 // = 16
  case f64 // = 12

  /// Complex values of fixed width.
  case c64 // = 15

  /// A tuple is a polymorphic sequence; e.g. a shape that holds different
  /// sub-shapes. They are used for things like returning multiple values from a
  /// computation; e.g. a computation that returns weights and biases may have a
  /// signature that results in a tuple like (f32[784x2000], f32[2000])
  ///
  /// If a shape proto has the tuple element type, it may not have any entries
  /// in the dimensions field.
  case tuple // = 13

  /// An opaque type used for passing context-specific data to a custom
  /// operation. Shapes of this primitive type will have empty dimensions and
  /// tuple_shapes fields.
  case opaque // = 14

  /// A token type threaded between side-effecting operations. Shapes of this
  /// primitive type will have empty dimensions and tuple_shapes fields.
  case token // = 17
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .pred
    case 2: self = .s8
    case 3: self = .s16
    case 4: self = .s32
    case 5: self = .s64
    case 6: self = .u8
    case 7: self = .u16
    case 8: self = .u32
    case 9: self = .u64
    case 10: self = .f16
    case 11: self = .f32
    case 12: self = .f64
    case 13: self = .tuple
    case 14: self = .opaque
    case 15: self = .c64
    case 16: self = .bf16
    case 17: self = .token
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .pred: return 1
    case .s8: return 2
    case .s16: return 3
    case .s32: return 4
    case .s64: return 5
    case .u8: return 6
    case .u16: return 7
    case .u32: return 8
    case .u64: return 9
    case .f16: return 10
    case .f32: return 11
    case .f64: return 12
    case .tuple: return 13
    case .opaque: return 14
    case .c64: return 15
    case .bf16: return 16
    case .token: return 17
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Describes the value held inside padding elements.
public enum Xla_PaddingValue: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalidPad // = 0

  /// Zero padding must be 0-values that correspond to the shape's element type.
  case zeroPad // = 1

  /// One padding must be 1-values that correspond to the shape's element type.
  case onePad // = 2

  /// "Lowest" padding must be the lowest values in the shape's element type,
  /// used as padding for operations like max-accumulation.
  case lowestPad // = 3

  /// "Highest" padding must be the largest values in the shape's element type,
  /// used as padding for operations like min-accumulation.
  case highestPad // = 4

  /// Unknown padding could be anything; e.g. floating NaNs!
  case unknownPad // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidPad
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidPad
    case 1: self = .zeroPad
    case 2: self = .onePad
    case 3: self = .lowestPad
    case 4: self = .highestPad
    case 5: self = .unknownPad
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidPad: return 0
    case .zeroPad: return 1
    case .onePad: return 2
    case .lowestPad: return 3
    case .highestPad: return 4
    case .unknownPad: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// A format specifies the method used by a layout to store an array in memory.
public enum Xla_Format: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case invalidFormat // = 0

  /// The default layout, with exactly one storage location per element (ignoring
  /// padding).
  case dense // = 1

  /// A sparsely encoded layout, providing only the index/value pairs of non-zero
  /// elements.
  case sparse // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .invalidFormat
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalidFormat
    case 1: self = .dense
    case 2: self = .sparse
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .invalidFormat: return 0
    case .dense: return 1
    case .sparse: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

public enum Xla_FftType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Forward FFT; complex in, complex out.
  case fft // = 0

  /// Inverse FFT; complex in, complex out.
  case ifft // = 1

  /// Forward real FFT; real in, fft_length / 2 + 1 complex out
  case rfft // = 2

  /// Inverse real FFT; fft_length / 2 + 1 complex in,
  case irfft // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .fft
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .fft
    case 1: self = .ifft
    case 2: self = .rfft
    case 3: self = .irfft
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .fft: return 0
    case .ifft: return 1
    case .rfft: return 2
    case .irfft: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

public enum Xla_RandomDistribution: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case rngInvalid // = 0

  /// Creates a uniform-distribution-generated random number on the semi-open
  /// interval [parameter[0], parameter[1]).
  case rngUniform // = 1

  /// Creates a normal-distribution-generated random number with mean
  /// parameter[0] and standard deviation parameter[1].
  case rngNormal // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .rngInvalid
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rngInvalid
    case 1: self = .rngUniform
    case 2: self = .rngNormal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .rngInvalid: return 0
    case .rngUniform: return 1
    case .rngNormal: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

/// Describes the padding configuration for Pad operation. The padding amount on
/// both edges as well as between the elements are specified for each dimension.
public struct Xla_PaddingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The padding configuration for all dimensions.
  public var dimensions: [Xla_PaddingConfig.PaddingConfigDimension] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the padding configuration for a dimension.
  public struct PaddingConfigDimension {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Padding amount on the low-end (next to the index 0).
    public var edgePaddingLow: Int64 = 0

    /// Padding amount on the high-end (next to the highest index).
    public var edgePaddingHigh: Int64 = 0

    /// Padding amount between the elements.
    public var interiorPadding: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A layout describes how the array is placed in (1D) memory space.  This
/// includes the minor-to-major ordering of dimensions within a shape, as well as
/// any padding present in those dimensions.
///
/// Clients must specify the layouts of input Literals to the
/// computation. Layouts specified in interior operations which take Shapes (for
/// example, Convert) are ignored.
///
/// See the XLA documentation for more information on shapes and layouts.
///
/// LINT.IfChange
public struct Xla_Layout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The method used to store the data in memory. The format determines which of
  /// the other fields are used by the layout.
  public var format: Xla_Format = .invalidFormat

  /// Sequence of dimension numbers, from minor (fastest varying index) to major
  /// (slowest varying index). This field is required.
  public var minorToMajor: [Int64] = []

  /// The width to which the layout of each dimension is padded up to. If
  /// present, the size of the padded_dimensions must equal the rank of the
  /// shape. The padding appears at the end of a dimension, not at the
  /// beginning. This kind of padding, unlike padding in e.g. convolution, is not
  /// part of the shape. This field must be unset unless the format is DENSE.
  public var paddedDimensions: [Int64] = []

  /// Describes the values in the padding specified by padded_dimensions. This
  /// field must be unset unless the format is DENSE.
  public var paddingValue: Xla_PaddingValue = .invalidPad

  /// The maximum number of elements that can be stored for SPARSE formats.  This
  /// can be used to determine the maximum size in bytes of arrays stored in
  /// memory.  This field must be unset unless the format is SPARSE.
  public var maxSparseElements: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A shape describes the number of dimensions in the array, the size of each
/// dimension, and the primitive component type.
///
/// Tuples are a special case in that they have rank zero and have tuple_shapes
/// defined.
///
/// See the XLA documentation for more information on shapes and layouts.
///
/// LINT.IfChange
public struct Xla_Shape {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The element type for this shape.
  public var elementType: Xla_PrimitiveType {
    get {return _storage._elementType}
    set {_uniqueStorage()._elementType = newValue}
  }

  /// The size (number of elements) for each dimension.
  /// In XLA, dimensions are numbered from 0 to N-1 for an
  /// N-dimensional array. The first element of 'dimensions' is the size of
  /// dimension 0, the second element is the size of dimension 1, and so forth.
  /// Empty list indicates a scalar.
  public var dimensions: [Int64] {
    get {return _storage._dimensions}
    set {_uniqueStorage()._dimensions = newValue}
  }

  /// For tuples only, the shapes of constitutent shapes in the tuple sequence.
  public var tupleShapes: [Xla_Shape] {
    get {return _storage._tupleShapes}
    set {_uniqueStorage()._tupleShapes = newValue}
  }

  /// The layout used to back this shape.
  public var layout: Xla_Layout {
    get {return _storage._layout ?? Xla_Layout()}
    set {_uniqueStorage()._layout = newValue}
  }
  /// Returns true if `layout` has been explicitly set.
  public var hasLayout: Bool {return _storage._layout != nil}
  /// Clears the value of `layout`. Subsequent reads from it will return its default value.
  public mutating func clearLayout() {_storage._layout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Shape of the parameters and output of a computation (like a traditional
/// function signature).
public struct Xla_ProgramShape {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parameters: [Xla_Shape] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  public var result: Xla_Shape {
    get {return _storage._result ?? Xla_Shape()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {_storage._result = nil}

  public var parameterNames: [String] {
    get {return _storage._parameterNames}
    set {_uniqueStorage()._parameterNames = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Statistics of a computation.
public struct Xla_ComputationStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of floating point operations in the computation.
  public var flopCount: Double = 0

  /// The number of transcendental operations (e.g., exp) in the computation.
  public var transcendentalCount: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Symbolization metadata for HLO Instructions.
///
/// This metadata is used for debugging XLA code generation, as well as
/// performance profiling of XLA-generated executables.
public struct Xla_OpMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The framework op name that generated this XLA op.
  ///
  /// Frameworks that build on top of XLA should mirror the names of their ops
  /// back to users by specifying the op_type. In this way, even if the
  /// framework's "ops" are implemented as multiple XLA HLO Ops, they can be
  /// grouped appropriately. (e.g. if a SoftMax layer is emitted into XLA as
  /// multiple ops, then each op should have the op_type be "SoftMax".)
  public var opType: String = String()

  /// The user-specified name of the op.
  ///
  /// This name is often unique within a computation. Note: some frameworks
  /// add auto-generated names if the user does not provide one.
  public var opName: String = String()

  /// Indicate a file and line that this op is associated to in a user's program.
  ///
  /// e.g. it could be the file and line of user code that generated the op.
  public var sourceFile: String = String()

  public var sourceLine: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Profile data from the execution of a computation.
public struct Xla_ExecutionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the executable was read from the compilation cache.
  public var compilationCacheHit: Bool = false

  /// The time in milliseconds spent to compile the computation. This only set if
  /// the executable was not read from the compilation cache
  /// (compilation_cache_hit == false).
  public var compileTimeMs: Int64 = 0

  /// The number of cycles spent for the computation. This does not include the
  /// time taken for the data transfers between the host and the device. This is
  /// a target-dependent field and only used for debugging purposes.
  public var computeCycleCount: Int64 = 0

  /// The time in nanoseconds spent for the computation, without data transfer.
  public var computeTimeNs: Int64 = 0

  /// The time in nanoseconds spent for the entire computation, including the
  /// result data transfer time. Current implementation does not spend any cycles
  /// for the input data transfer since the memory is initialized with the proper
  /// values before the execution.
  public var computeAndTransferTimeNs: Int64 = 0

  /// The size of the binary code in the executable.
  public var executableSizeInBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Handle given to a user that represents an execution that the user launched
/// asynchronously on the device.
public struct Xla_ExecutionHandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handle: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Handle given to a user that represents a globally accessible allocation.
/// Contrast this against a ComputationDataHandle, which is not globally
/// accessible, since it only exists within a specific computation.
public struct Xla_GlobalDataHandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handle: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Handle given to a user that represents a replicated virtual device. Each
/// replicated device represents N physical devices for execution where N is the
/// number of replicas.
public struct Xla_DeviceHandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handle: Int64 = 0

  /// The number of model-parallel virtual devices that communicate via XLA
  /// Send/Recv instructions.
  public var deviceCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Handle given to a user to represent a channel between two computations
/// via a Send and Recv instruction pair. Channels are unbuffered, so Send
/// Send instructions will be blocked until the data is transferred.
public struct Xla_ChannelHandle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var handle: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DeviceAssignmentProto is a serialized form of DeviceAssignment class, which
/// represents the device ids assigned to a set of replicated computations.
/// See xla::DeviceAssignment class comment for more details.
public struct Xla_DeviceAssignmentProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var replicaCount: Int32 = 0

  public var computationCount: Int32 = 0

  public var computationDevices: [Xla_DeviceAssignmentProto.ComputationDevice] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Each logical computation runs on replica_count physical devices.
  /// ComputationDevice represents the device ids assinged to the replicas.
  public struct ComputationDevice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var replicaDeviceIds: [Int32] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Literals are used when the server and client need to exchange materialized
/// data / results. Literals are also used to describe constants used in
/// computations.
///
/// Transfers to/from the client are encoded in literal form, and the structure
/// of the repeated fields is implied by the shape.
public struct Xla_LiteralProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shape: Xla_Shape {
    get {return _storage._shape ?? Xla_Shape()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_storage._shape = nil}

  public var preds: [Bool] {
    get {return _storage._preds}
    set {_uniqueStorage()._preds = newValue}
  }

  public var u8S: Data {
    get {return _storage._u8S}
    set {_uniqueStorage()._u8S = newValue}
  }

  public var s32S: [Int32] {
    get {return _storage._s32S}
    set {_uniqueStorage()._s32S = newValue}
  }

  public var s64S: [Int64] {
    get {return _storage._s64S}
    set {_uniqueStorage()._s64S = newValue}
  }

  public var u32S: [UInt32] {
    get {return _storage._u32S}
    set {_uniqueStorage()._u32S = newValue}
  }

  public var u64S: [UInt64] {
    get {return _storage._u64S}
    set {_uniqueStorage()._u64S = newValue}
  }

  public var f32S: [Float] {
    get {return _storage._f32S}
    set {_uniqueStorage()._f32S = newValue}
  }

  public var f64S: [Double] {
    get {return _storage._f64S}
    set {_uniqueStorage()._f64S = newValue}
  }

  /// Stored as interleaved real, imag floats.
  public var c64S: [Float] {
    get {return _storage._c64S}
    set {_uniqueStorage()._c64S = newValue}
  }

  public var tupleLiterals: [Xla_LiteralProto] {
    get {return _storage._tupleLiterals}
    set {_uniqueStorage()._tupleLiterals = newValue}
  }

  /// The F16s and BF16s are encoded in little endian byte order
  public var f16S: Data {
    get {return _storage._f16S}
    set {_uniqueStorage()._f16S = newValue}
  }

  public var bf16S: Data {
    get {return _storage._bf16S}
    set {_uniqueStorage()._bf16S = newValue}
  }

  /// Next = 15
  public var sparseIndices: [Int64] {
    get {return _storage._sparseIndices}
    set {_uniqueStorage()._sparseIndices = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Xla_WindowDimension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The size of the window in this dimension. For a rectangle, this would be
  /// the width or height.
  public var size: Int64 = 0

  /// The stride at which the window moves across the base area in this
  /// dimension. In other words, this is the spacing between different
  /// positions of the window in this dimension.
  public var stride: Int64 = 0

  /// If positive, means the amount of padding to add to the base area at the low
  /// end of this dimension; if negative, its negative means the number of
  /// elements removed from the low end of this dimension. For example, in the
  /// horizontal dimension of a rectangle, this would be the number of padding
  /// values to pad on the left, given that indices increase when going right.
  /// The actual padding value depends upon the context. Convolution pads with
  /// zeros. ReduceWindow and SelectAndScatter pads with the reduce function's
  /// init value.
  public var paddingLow: Int64 = 0

  /// As padding_low, but on the high end of this dimension. For example, in the
  /// horizontal dimension of a rectangle, this would be the number of values to
  /// pad on the right, given that indices increase when going right.
  public var paddingHigh: Int64 = 0

  /// Dilation factor of the sliding window in this dimension. A dilation factor
  /// of 1 means no dilation. window_dilation - 1 no-op entries ("holes") are
  /// implicitly placed between each kernel element. See documentation for
  /// convolution.
  public var windowDilation: Int64 = 0

  /// Dilation factor of the base area in this dimension. A dilation factor of 1
  /// means no dilation. base_dilation - 1 no-op entries ("holes") are implicitly
  /// placed between each base area element. See documentation for convolution.
  public var baseDilation: Int64 = 0

  /// Window reversal means that this dimension was logically reversed before the
  /// operation.
  public var windowReversal: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the windowing in an operation such as convolution.
///
/// The window is moved across a base area and for each position of the
/// window a computation is performed. The field below describes the
/// window and the movement of the window across a base area.
public struct Xla_Window {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dimensions: [Xla_WindowDimension] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the dimension numbers for a gather operation.
///
/// See https://www.tensorflow.org/performance/xla/operation_semantics#gather for
/// more details.
public struct Xla_GatherDimensionNumbers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "Window indices" is a term for a set of indices that index into the
  /// interior of a dynamic-slice from the input tensor, the starting indices for
  /// which were computed from output_gather_dims (see the operation semantic for
  /// how this is defined) and the gather_indices tensor.
  ///
  /// The window indices for a specific output index Out is computed as:
  ///
  ///  i = 0
  ///  for (k : [0, input_tensor_shape.rank))
  ///    window_indices[k] =
  ///      if k in elided_window_dims
  ///      then 0
  ///      else Out[output_window_dims[i++]]
  public var outputWindowDims: [Int64] = []

  public var elidedWindowDims: [Int64] = []

  /// This is interpreted as a map from i to gather_dims_to_operand_dims[i]. It
  /// transforms the gather index looked up from the gather_indices tensor into
  /// the starting index in the input space.
  public var gatherDimsToOperandDims: [Int64] = []

  /// The dimension in the gather_indices input that contains the starting
  /// indices.
  public var indexVectorDim: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xla_ConvolutionDimensionNumbers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of the dimension that represents batch in the input.
  public var inputBatchDimension: Int64 = 0

  /// The number of the dimension that represents features in the input.
  public var inputFeatureDimension: Int64 = 0

  /// The dimension numbers for the spatial dimensions that the window
  /// moves through in the input.
  public var inputSpatialDimensions: [Int64] = []

  /// The number of the dimension that represents input features in the
  /// convolutional kernel (rhs).
  public var kernelInputFeatureDimension: Int64 = 0

  /// The number of the dimension that represents output features in
  /// the convolutional kernel (rhs).
  public var kernelOutputFeatureDimension: Int64 = 0

  /// The dimension numbers for the spatial dimensions that the window
  /// moves through in the kernel (rhs). window.strides(0) is the
  /// stride in the kernel_spatial_dimensions(0) dimension.
  public var kernelSpatialDimensions: [Int64] = []

  /// The number of the dimension that represents batch in the output.
  public var outputBatchDimension: Int64 = 0

  /// The number of the dimension that represents features in the output.
  public var outputFeatureDimension: Int64 = 0

  /// The dimension numbers for the spatial dimensions that the window
  /// moves through in the output.
  public var outputSpatialDimensions: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xla_DotDimensionNumbers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The dimension numbers that represent the 'lhs' contracting dimensions.
  public var lhsContractingDimensions: [Int64] = []

  /// The dimension numbers that represent the 'rhs' contracting dimensions.
  public var rhsContractingDimensions: [Int64] = []

  /// The dimension numbers that represent the 'lhs' batch dimensions.
  public var lhsBatchDimensions: [Int64] = []

  /// The dimension numbers that represent the 'rhs' batch dimensions.
  public var rhsBatchDimensions: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xla_OpSharding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Xla_OpSharding.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// The shape of the sharded tile.
  public var tileShape: Xla_Shape {
    get {return _storage._tileShape ?? Xla_Shape()}
    set {_uniqueStorage()._tileShape = newValue}
  }
  /// Returns true if `tileShape` has been explicitly set.
  public var hasTileShape: Bool {return _storage._tileShape != nil}
  /// Clears the value of `tileShape`. Subsequent reads from it will return its default value.
  public mutating func clearTileShape() {_storage._tileShape = nil}

  /// The shape of the tile assignment tensor - this must be the same rank as
  /// tile_shape and the product of its dimensions must equal
  /// tile_assignment_devices.size().
  public var tileAssignmentDimensions: [Int64] {
    get {return _storage._tileAssignmentDimensions}
    set {_uniqueStorage()._tileAssignmentDimensions = newValue}
  }

  /// Flattened list of device IDs. The order of flattening is the same as used
  /// by IndexUtil::MultiToLinearIndex(tile_assignment_shape).
  public var tileAssignmentDevices: [Int64] {
    get {return _storage._tileAssignmentDevices}
    set {_uniqueStorage()._tileAssignmentDevices = newValue}
  }

  /// If type == TUPLE, the sub-shardings, one per leaf node in the tuple shape,
  /// in pre-order. The tuple shape could be nested; here we store just a
  /// flattened list of all leaves in the tuple shape. Note that the tuple shape
  /// is not stored here; shardings do not store the shapes to which they are
  /// applied, this is inferred from the instruction this sharding gets attached
  /// to.
  public var tupleShardings: [Xla_OpSharding] {
    get {return _storage._tupleShardings}
    set {_uniqueStorage()._tupleShardings = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// This sharding is replicated across all devices (implies maximal,
    /// all other fields are unused).
    case replicated // = 0

    /// This sharding is maximal - one device runs the entire operation.
    case maximal // = 1

    /// This sharding is a tuple - only the tuple_shardings field is valid.
    case tuple // = 2

    /// None of the above; tile_shape and tile_assignment are both used.
    case other // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .replicated
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .replicated
      case 1: self = .maximal
      case 2: self = .tuple
      case 3: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .replicated: return 0
      case .maximal: return 1
      case .tuple: return 2
      case .other: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xla"

extension Xla_PrimitiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIMITIVE_TYPE_INVALID"),
    1: .same(proto: "PRED"),
    2: .same(proto: "S8"),
    3: .same(proto: "S16"),
    4: .same(proto: "S32"),
    5: .same(proto: "S64"),
    6: .same(proto: "U8"),
    7: .same(proto: "U16"),
    8: .same(proto: "U32"),
    9: .same(proto: "U64"),
    10: .same(proto: "F16"),
    11: .same(proto: "F32"),
    12: .same(proto: "F64"),
    13: .same(proto: "TUPLE"),
    14: .same(proto: "OPAQUE"),
    15: .same(proto: "C64"),
    16: .same(proto: "BF16"),
    17: .same(proto: "TOKEN"),
  ]
}

extension Xla_PaddingValue: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_PAD"),
    1: .same(proto: "ZERO_PAD"),
    2: .same(proto: "ONE_PAD"),
    3: .same(proto: "LOWEST_PAD"),
    4: .same(proto: "HIGHEST_PAD"),
    5: .same(proto: "UNKNOWN_PAD"),
  ]
}

extension Xla_Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_FORMAT"),
    1: .same(proto: "DENSE"),
    2: .same(proto: "SPARSE"),
  ]
}

extension Xla_FftType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FFT"),
    1: .same(proto: "IFFT"),
    2: .same(proto: "RFFT"),
    3: .same(proto: "IRFFT"),
  ]
}

extension Xla_RandomDistribution: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RNG_INVALID"),
    1: .same(proto: "RNG_UNIFORM"),
    2: .same(proto: "RNG_NORMAL"),
  ]
}

extension Xla_PaddingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaddingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dimensions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dimensions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dimensions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_PaddingConfig) -> Bool {
    if self.dimensions != other.dimensions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_PaddingConfig.PaddingConfigDimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_PaddingConfig.protoMessageName + ".PaddingConfigDimension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "edge_padding_low"),
    2: .standard(proto: "edge_padding_high"),
    3: .standard(proto: "interior_padding"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.edgePaddingLow)
      case 2: try decoder.decodeSingularInt64Field(value: &self.edgePaddingHigh)
      case 3: try decoder.decodeSingularInt64Field(value: &self.interiorPadding)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.edgePaddingLow != 0 {
      try visitor.visitSingularInt64Field(value: self.edgePaddingLow, fieldNumber: 1)
    }
    if self.edgePaddingHigh != 0 {
      try visitor.visitSingularInt64Field(value: self.edgePaddingHigh, fieldNumber: 2)
    }
    if self.interiorPadding != 0 {
      try visitor.visitSingularInt64Field(value: self.interiorPadding, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_PaddingConfig.PaddingConfigDimension) -> Bool {
    if self.edgePaddingLow != other.edgePaddingLow {return false}
    if self.edgePaddingHigh != other.edgePaddingHigh {return false}
    if self.interiorPadding != other.interiorPadding {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_Layout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Layout"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "format"),
    1: .standard(proto: "minor_to_major"),
    2: .standard(proto: "padded_dimensions"),
    3: .standard(proto: "padding_value"),
    5: .standard(proto: "max_sparse_elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.minorToMajor)
      case 2: try decoder.decodeRepeatedInt64Field(value: &self.paddedDimensions)
      case 3: try decoder.decodeSingularEnumField(value: &self.paddingValue)
      case 4: try decoder.decodeSingularEnumField(value: &self.format)
      case 5: try decoder.decodeSingularInt64Field(value: &self.maxSparseElements)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.minorToMajor.isEmpty {
      try visitor.visitPackedInt64Field(value: self.minorToMajor, fieldNumber: 1)
    }
    if !self.paddedDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.paddedDimensions, fieldNumber: 2)
    }
    if self.paddingValue != .invalidPad {
      try visitor.visitSingularEnumField(value: self.paddingValue, fieldNumber: 3)
    }
    if self.format != .invalidFormat {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 4)
    }
    if self.maxSparseElements != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSparseElements, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_Layout) -> Bool {
    if self.format != other.format {return false}
    if self.minorToMajor != other.minorToMajor {return false}
    if self.paddedDimensions != other.paddedDimensions {return false}
    if self.paddingValue != other.paddingValue {return false}
    if self.maxSparseElements != other.maxSparseElements {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_Shape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Shape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "element_type"),
    3: .same(proto: "dimensions"),
    4: .standard(proto: "tuple_shapes"),
    5: .same(proto: "layout"),
  ]

  fileprivate class _StorageClass {
    var _elementType: Xla_PrimitiveType = .invalid
    var _dimensions: [Int64] = []
    var _tupleShapes: [Xla_Shape] = []
    var _layout: Xla_Layout? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _elementType = source._elementType
      _dimensions = source._dimensions
      _tupleShapes = source._tupleShapes
      _layout = source._layout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 2: try decoder.decodeSingularEnumField(value: &_storage._elementType)
        case 3: try decoder.decodeRepeatedInt64Field(value: &_storage._dimensions)
        case 4: try decoder.decodeRepeatedMessageField(value: &_storage._tupleShapes)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._layout)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._elementType != .invalid {
        try visitor.visitSingularEnumField(value: _storage._elementType, fieldNumber: 2)
      }
      if !_storage._dimensions.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dimensions, fieldNumber: 3)
      }
      if !_storage._tupleShapes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tupleShapes, fieldNumber: 4)
      }
      if let v = _storage._layout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_Shape) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._elementType != other_storage._elementType {return false}
        if _storage._dimensions != other_storage._dimensions {return false}
        if _storage._tupleShapes != other_storage._tupleShapes {return false}
        if _storage._layout != other_storage._layout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_ProgramShape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProgramShape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "result"),
    3: .standard(proto: "parameter_names"),
  ]

  fileprivate class _StorageClass {
    var _parameters: [Xla_Shape] = []
    var _result: Xla_Shape? = nil
    var _parameterNames: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parameters = source._parameters
      _result = source._result
      _parameterNames = source._parameterNames
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeRepeatedMessageField(value: &_storage._parameters)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._result)
        case 3: try decoder.decodeRepeatedStringField(value: &_storage._parameterNames)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parameters, fieldNumber: 1)
      }
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._parameterNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._parameterNames, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_ProgramShape) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._parameters != other_storage._parameters {return false}
        if _storage._result != other_storage._result {return false}
        if _storage._parameterNames != other_storage._parameterNames {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_ComputationStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputationStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "flop_count"),
    2: .standard(proto: "transcendental_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.flopCount)
      case 2: try decoder.decodeSingularDoubleField(value: &self.transcendentalCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.flopCount != 0 {
      try visitor.visitSingularDoubleField(value: self.flopCount, fieldNumber: 1)
    }
    if self.transcendentalCount != 0 {
      try visitor.visitSingularDoubleField(value: self.transcendentalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_ComputationStats) -> Bool {
    if self.flopCount != other.flopCount {return false}
    if self.transcendentalCount != other.transcendentalCount {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_OpMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "op_type"),
    2: .standard(proto: "op_name"),
    3: .standard(proto: "source_file"),
    4: .standard(proto: "source_line"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.opType)
      case 2: try decoder.decodeSingularStringField(value: &self.opName)
      case 3: try decoder.decodeSingularStringField(value: &self.sourceFile)
      case 4: try decoder.decodeSingularInt32Field(value: &self.sourceLine)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.opType.isEmpty {
      try visitor.visitSingularStringField(value: self.opType, fieldNumber: 1)
    }
    if !self.opName.isEmpty {
      try visitor.visitSingularStringField(value: self.opName, fieldNumber: 2)
    }
    if !self.sourceFile.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceFile, fieldNumber: 3)
    }
    if self.sourceLine != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceLine, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_OpMetadata) -> Bool {
    if self.opType != other.opType {return false}
    if self.opName != other.opName {return false}
    if self.sourceFile != other.sourceFile {return false}
    if self.sourceLine != other.sourceLine {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_ExecutionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "compilation_cache_hit"),
    2: .standard(proto: "compile_time_ms"),
    3: .standard(proto: "compute_cycle_count"),
    4: .standard(proto: "compute_time_ns"),
    5: .standard(proto: "compute_and_transfer_time_ns"),
    6: .standard(proto: "executable_size_in_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.compilationCacheHit)
      case 2: try decoder.decodeSingularInt64Field(value: &self.compileTimeMs)
      case 3: try decoder.decodeSingularInt64Field(value: &self.computeCycleCount)
      case 4: try decoder.decodeSingularInt64Field(value: &self.computeTimeNs)
      case 5: try decoder.decodeSingularInt64Field(value: &self.computeAndTransferTimeNs)
      case 6: try decoder.decodeSingularInt64Field(value: &self.executableSizeInBytes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.compilationCacheHit != false {
      try visitor.visitSingularBoolField(value: self.compilationCacheHit, fieldNumber: 1)
    }
    if self.compileTimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.compileTimeMs, fieldNumber: 2)
    }
    if self.computeCycleCount != 0 {
      try visitor.visitSingularInt64Field(value: self.computeCycleCount, fieldNumber: 3)
    }
    if self.computeTimeNs != 0 {
      try visitor.visitSingularInt64Field(value: self.computeTimeNs, fieldNumber: 4)
    }
    if self.computeAndTransferTimeNs != 0 {
      try visitor.visitSingularInt64Field(value: self.computeAndTransferTimeNs, fieldNumber: 5)
    }
    if self.executableSizeInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.executableSizeInBytes, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_ExecutionProfile) -> Bool {
    if self.compilationCacheHit != other.compilationCacheHit {return false}
    if self.compileTimeMs != other.compileTimeMs {return false}
    if self.computeCycleCount != other.computeCycleCount {return false}
    if self.computeTimeNs != other.computeTimeNs {return false}
    if self.computeAndTransferTimeNs != other.computeAndTransferTimeNs {return false}
    if self.executableSizeInBytes != other.executableSizeInBytes {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_ExecutionHandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionHandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.handle)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.handle != 0 {
      try visitor.visitSingularInt64Field(value: self.handle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_ExecutionHandle) -> Bool {
    if self.handle != other.handle {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_GlobalDataHandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GlobalDataHandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.handle)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.handle != 0 {
      try visitor.visitSingularInt64Field(value: self.handle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_GlobalDataHandle) -> Bool {
    if self.handle != other.handle {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_DeviceHandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceHandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handle"),
    2: .standard(proto: "device_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.handle)
      case 2: try decoder.decodeSingularInt64Field(value: &self.deviceCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.handle != 0 {
      try visitor.visitSingularInt64Field(value: self.handle, fieldNumber: 1)
    }
    if self.deviceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.deviceCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_DeviceHandle) -> Bool {
    if self.handle != other.handle {return false}
    if self.deviceCount != other.deviceCount {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_ChannelHandle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChannelHandle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handle"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.handle)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.handle != 0 {
      try visitor.visitSingularInt64Field(value: self.handle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_ChannelHandle) -> Bool {
    if self.handle != other.handle {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_DeviceAssignmentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceAssignmentProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replica_count"),
    2: .standard(proto: "computation_count"),
    3: .standard(proto: "computation_devices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.replicaCount)
      case 2: try decoder.decodeSingularInt32Field(value: &self.computationCount)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.computationDevices)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.replicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.replicaCount, fieldNumber: 1)
    }
    if self.computationCount != 0 {
      try visitor.visitSingularInt32Field(value: self.computationCount, fieldNumber: 2)
    }
    if !self.computationDevices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.computationDevices, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_DeviceAssignmentProto) -> Bool {
    if self.replicaCount != other.replicaCount {return false}
    if self.computationCount != other.computationCount {return false}
    if self.computationDevices != other.computationDevices {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_DeviceAssignmentProto.ComputationDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_DeviceAssignmentProto.protoMessageName + ".ComputationDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replica_device_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt32Field(value: &self.replicaDeviceIds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.replicaDeviceIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.replicaDeviceIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_DeviceAssignmentProto.ComputationDevice) -> Bool {
    if self.replicaDeviceIds != other.replicaDeviceIds {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_LiteralProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LiteralProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shape"),
    2: .same(proto: "preds"),
    3: .same(proto: "u8s"),
    4: .same(proto: "s32s"),
    5: .same(proto: "s64s"),
    6: .same(proto: "u32s"),
    7: .same(proto: "u64s"),
    8: .same(proto: "f32s"),
    9: .same(proto: "f64s"),
    12: .same(proto: "c64s"),
    10: .standard(proto: "tuple_literals"),
    11: .same(proto: "f16s"),
    13: .same(proto: "bf16s"),
    14: .standard(proto: "sparse_indices"),
  ]

  fileprivate class _StorageClass {
    var _shape: Xla_Shape? = nil
    var _preds: [Bool] = []
    var _u8S: Data = SwiftProtobuf.Internal.emptyData
    var _s32S: [Int32] = []
    var _s64S: [Int64] = []
    var _u32S: [UInt32] = []
    var _u64S: [UInt64] = []
    var _f32S: [Float] = []
    var _f64S: [Double] = []
    var _c64S: [Float] = []
    var _tupleLiterals: [Xla_LiteralProto] = []
    var _f16S: Data = SwiftProtobuf.Internal.emptyData
    var _bf16S: Data = SwiftProtobuf.Internal.emptyData
    var _sparseIndices: [Int64] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _shape = source._shape
      _preds = source._preds
      _u8S = source._u8S
      _s32S = source._s32S
      _s64S = source._s64S
      _u32S = source._u32S
      _u64S = source._u64S
      _f32S = source._f32S
      _f64S = source._f64S
      _c64S = source._c64S
      _tupleLiterals = source._tupleLiterals
      _f16S = source._f16S
      _bf16S = source._bf16S
      _sparseIndices = source._sparseIndices
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._shape)
        case 2: try decoder.decodeRepeatedBoolField(value: &_storage._preds)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._u8S)
        case 4: try decoder.decodeRepeatedInt32Field(value: &_storage._s32S)
        case 5: try decoder.decodeRepeatedInt64Field(value: &_storage._s64S)
        case 6: try decoder.decodeRepeatedUInt32Field(value: &_storage._u32S)
        case 7: try decoder.decodeRepeatedUInt64Field(value: &_storage._u64S)
        case 8: try decoder.decodeRepeatedFloatField(value: &_storage._f32S)
        case 9: try decoder.decodeRepeatedDoubleField(value: &_storage._f64S)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._tupleLiterals)
        case 11: try decoder.decodeSingularBytesField(value: &_storage._f16S)
        case 12: try decoder.decodeRepeatedFloatField(value: &_storage._c64S)
        case 13: try decoder.decodeSingularBytesField(value: &_storage._bf16S)
        case 14: try decoder.decodeRepeatedInt64Field(value: &_storage._sparseIndices)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._preds.isEmpty {
        try visitor.visitPackedBoolField(value: _storage._preds, fieldNumber: 2)
      }
      if !_storage._u8S.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._u8S, fieldNumber: 3)
      }
      if !_storage._s32S.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._s32S, fieldNumber: 4)
      }
      if !_storage._s64S.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._s64S, fieldNumber: 5)
      }
      if !_storage._u32S.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._u32S, fieldNumber: 6)
      }
      if !_storage._u64S.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._u64S, fieldNumber: 7)
      }
      if !_storage._f32S.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._f32S, fieldNumber: 8)
      }
      if !_storage._f64S.isEmpty {
        try visitor.visitPackedDoubleField(value: _storage._f64S, fieldNumber: 9)
      }
      if !_storage._tupleLiterals.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tupleLiterals, fieldNumber: 10)
      }
      if !_storage._f16S.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._f16S, fieldNumber: 11)
      }
      if !_storage._c64S.isEmpty {
        try visitor.visitPackedFloatField(value: _storage._c64S, fieldNumber: 12)
      }
      if !_storage._bf16S.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._bf16S, fieldNumber: 13)
      }
      if !_storage._sparseIndices.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._sparseIndices, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_LiteralProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._shape != other_storage._shape {return false}
        if _storage._preds != other_storage._preds {return false}
        if _storage._u8S != other_storage._u8S {return false}
        if _storage._s32S != other_storage._s32S {return false}
        if _storage._s64S != other_storage._s64S {return false}
        if _storage._u32S != other_storage._u32S {return false}
        if _storage._u64S != other_storage._u64S {return false}
        if _storage._f32S != other_storage._f32S {return false}
        if _storage._f64S != other_storage._f64S {return false}
        if _storage._c64S != other_storage._c64S {return false}
        if _storage._tupleLiterals != other_storage._tupleLiterals {return false}
        if _storage._f16S != other_storage._f16S {return false}
        if _storage._bf16S != other_storage._bf16S {return false}
        if _storage._sparseIndices != other_storage._sparseIndices {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_WindowDimension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WindowDimension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "stride"),
    3: .standard(proto: "padding_low"),
    4: .standard(proto: "padding_high"),
    5: .standard(proto: "window_dilation"),
    6: .standard(proto: "base_dilation"),
    7: .standard(proto: "window_reversal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.size)
      case 2: try decoder.decodeSingularInt64Field(value: &self.stride)
      case 3: try decoder.decodeSingularInt64Field(value: &self.paddingLow)
      case 4: try decoder.decodeSingularInt64Field(value: &self.paddingHigh)
      case 5: try decoder.decodeSingularInt64Field(value: &self.windowDilation)
      case 6: try decoder.decodeSingularInt64Field(value: &self.baseDilation)
      case 7: try decoder.decodeSingularBoolField(value: &self.windowReversal)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 1)
    }
    if self.stride != 0 {
      try visitor.visitSingularInt64Field(value: self.stride, fieldNumber: 2)
    }
    if self.paddingLow != 0 {
      try visitor.visitSingularInt64Field(value: self.paddingLow, fieldNumber: 3)
    }
    if self.paddingHigh != 0 {
      try visitor.visitSingularInt64Field(value: self.paddingHigh, fieldNumber: 4)
    }
    if self.windowDilation != 0 {
      try visitor.visitSingularInt64Field(value: self.windowDilation, fieldNumber: 5)
    }
    if self.baseDilation != 0 {
      try visitor.visitSingularInt64Field(value: self.baseDilation, fieldNumber: 6)
    }
    if self.windowReversal != false {
      try visitor.visitSingularBoolField(value: self.windowReversal, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_WindowDimension) -> Bool {
    if self.size != other.size {return false}
    if self.stride != other.stride {return false}
    if self.paddingLow != other.paddingLow {return false}
    if self.paddingHigh != other.paddingHigh {return false}
    if self.windowDilation != other.windowDilation {return false}
    if self.baseDilation != other.baseDilation {return false}
    if self.windowReversal != other.windowReversal {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_Window: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Window"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dimensions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dimensions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dimensions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dimensions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_Window) -> Bool {
    if self.dimensions != other.dimensions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_GatherDimensionNumbers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatherDimensionNumbers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_window_dims"),
    2: .standard(proto: "elided_window_dims"),
    3: .standard(proto: "gather_dims_to_operand_dims"),
    4: .standard(proto: "index_vector_dim"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.outputWindowDims)
      case 2: try decoder.decodeRepeatedInt64Field(value: &self.elidedWindowDims)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.gatherDimsToOperandDims)
      case 4: try decoder.decodeSingularInt64Field(value: &self.indexVectorDim)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputWindowDims.isEmpty {
      try visitor.visitPackedInt64Field(value: self.outputWindowDims, fieldNumber: 1)
    }
    if !self.elidedWindowDims.isEmpty {
      try visitor.visitPackedInt64Field(value: self.elidedWindowDims, fieldNumber: 2)
    }
    if !self.gatherDimsToOperandDims.isEmpty {
      try visitor.visitPackedInt64Field(value: self.gatherDimsToOperandDims, fieldNumber: 3)
    }
    if self.indexVectorDim != 0 {
      try visitor.visitSingularInt64Field(value: self.indexVectorDim, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_GatherDimensionNumbers) -> Bool {
    if self.outputWindowDims != other.outputWindowDims {return false}
    if self.elidedWindowDims != other.elidedWindowDims {return false}
    if self.gatherDimsToOperandDims != other.gatherDimsToOperandDims {return false}
    if self.indexVectorDim != other.indexVectorDim {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_ConvolutionDimensionNumbers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvolutionDimensionNumbers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .standard(proto: "input_batch_dimension"),
    8: .standard(proto: "input_feature_dimension"),
    11: .standard(proto: "input_spatial_dimensions"),
    3: .standard(proto: "kernel_input_feature_dimension"),
    4: .standard(proto: "kernel_output_feature_dimension"),
    6: .standard(proto: "kernel_spatial_dimensions"),
    9: .standard(proto: "output_batch_dimension"),
    10: .standard(proto: "output_feature_dimension"),
    12: .standard(proto: "output_spatial_dimensions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeSingularInt64Field(value: &self.kernelInputFeatureDimension)
      case 4: try decoder.decodeSingularInt64Field(value: &self.kernelOutputFeatureDimension)
      case 6: try decoder.decodeRepeatedInt64Field(value: &self.kernelSpatialDimensions)
      case 7: try decoder.decodeSingularInt64Field(value: &self.inputBatchDimension)
      case 8: try decoder.decodeSingularInt64Field(value: &self.inputFeatureDimension)
      case 9: try decoder.decodeSingularInt64Field(value: &self.outputBatchDimension)
      case 10: try decoder.decodeSingularInt64Field(value: &self.outputFeatureDimension)
      case 11: try decoder.decodeRepeatedInt64Field(value: &self.inputSpatialDimensions)
      case 12: try decoder.decodeRepeatedInt64Field(value: &self.outputSpatialDimensions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kernelInputFeatureDimension != 0 {
      try visitor.visitSingularInt64Field(value: self.kernelInputFeatureDimension, fieldNumber: 3)
    }
    if self.kernelOutputFeatureDimension != 0 {
      try visitor.visitSingularInt64Field(value: self.kernelOutputFeatureDimension, fieldNumber: 4)
    }
    if !self.kernelSpatialDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.kernelSpatialDimensions, fieldNumber: 6)
    }
    if self.inputBatchDimension != 0 {
      try visitor.visitSingularInt64Field(value: self.inputBatchDimension, fieldNumber: 7)
    }
    if self.inputFeatureDimension != 0 {
      try visitor.visitSingularInt64Field(value: self.inputFeatureDimension, fieldNumber: 8)
    }
    if self.outputBatchDimension != 0 {
      try visitor.visitSingularInt64Field(value: self.outputBatchDimension, fieldNumber: 9)
    }
    if self.outputFeatureDimension != 0 {
      try visitor.visitSingularInt64Field(value: self.outputFeatureDimension, fieldNumber: 10)
    }
    if !self.inputSpatialDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.inputSpatialDimensions, fieldNumber: 11)
    }
    if !self.outputSpatialDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.outputSpatialDimensions, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_ConvolutionDimensionNumbers) -> Bool {
    if self.inputBatchDimension != other.inputBatchDimension {return false}
    if self.inputFeatureDimension != other.inputFeatureDimension {return false}
    if self.inputSpatialDimensions != other.inputSpatialDimensions {return false}
    if self.kernelInputFeatureDimension != other.kernelInputFeatureDimension {return false}
    if self.kernelOutputFeatureDimension != other.kernelOutputFeatureDimension {return false}
    if self.kernelSpatialDimensions != other.kernelSpatialDimensions {return false}
    if self.outputBatchDimension != other.outputBatchDimension {return false}
    if self.outputFeatureDimension != other.outputFeatureDimension {return false}
    if self.outputSpatialDimensions != other.outputSpatialDimensions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_DotDimensionNumbers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DotDimensionNumbers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lhs_contracting_dimensions"),
    2: .standard(proto: "rhs_contracting_dimensions"),
    3: .standard(proto: "lhs_batch_dimensions"),
    4: .standard(proto: "rhs_batch_dimensions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt64Field(value: &self.lhsContractingDimensions)
      case 2: try decoder.decodeRepeatedInt64Field(value: &self.rhsContractingDimensions)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.lhsBatchDimensions)
      case 4: try decoder.decodeRepeatedInt64Field(value: &self.rhsBatchDimensions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lhsContractingDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.lhsContractingDimensions, fieldNumber: 1)
    }
    if !self.rhsContractingDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.rhsContractingDimensions, fieldNumber: 2)
    }
    if !self.lhsBatchDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.lhsBatchDimensions, fieldNumber: 3)
    }
    if !self.rhsBatchDimensions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.rhsBatchDimensions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_DotDimensionNumbers) -> Bool {
    if self.lhsContractingDimensions != other.lhsContractingDimensions {return false}
    if self.rhsContractingDimensions != other.rhsContractingDimensions {return false}
    if self.lhsBatchDimensions != other.lhsBatchDimensions {return false}
    if self.rhsBatchDimensions != other.rhsBatchDimensions {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_OpSharding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpSharding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "tile_shape"),
    3: .standard(proto: "tile_assignment_dimensions"),
    4: .standard(proto: "tile_assignment_devices"),
    5: .standard(proto: "tuple_shardings"),
  ]

  fileprivate class _StorageClass {
    var _type: Xla_OpSharding.TypeEnum = .replicated
    var _tileShape: Xla_Shape? = nil
    var _tileAssignmentDimensions: [Int64] = []
    var _tileAssignmentDevices: [Int64] = []
    var _tupleShardings: [Xla_OpSharding] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _tileShape = source._tileShape
      _tileAssignmentDimensions = source._tileAssignmentDimensions
      _tileAssignmentDevices = source._tileAssignmentDevices
      _tupleShardings = source._tupleShardings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._tileShape)
        case 3: try decoder.decodeRepeatedInt64Field(value: &_storage._tileAssignmentDimensions)
        case 4: try decoder.decodeRepeatedInt64Field(value: &_storage._tileAssignmentDevices)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._tupleShardings)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .replicated {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._tileShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._tileAssignmentDimensions.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._tileAssignmentDimensions, fieldNumber: 3)
      }
      if !_storage._tileAssignmentDevices.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._tileAssignmentDevices, fieldNumber: 4)
      }
      if !_storage._tupleShardings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tupleShardings, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_OpSharding) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._type != other_storage._type {return false}
        if _storage._tileShape != other_storage._tileShape {return false}
        if _storage._tileAssignmentDimensions != other_storage._tileAssignmentDimensions {return false}
        if _storage._tileAssignmentDevices != other_storage._tileAssignmentDevices {return false}
        if _storage._tupleShardings != other_storage._tupleShardings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_OpSharding.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REPLICATED"),
    1: .same(proto: "MAXIMAL"),
    2: .same(proto: "TUPLE"),
    3: .same(proto: "OTHER"),
  ]
}
