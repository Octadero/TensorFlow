// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tensorflow/compiler/xla/service/hlo.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 The TensorFlow Authors. All Rights Reserved.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//==============================================================================

// This proto file defines messages which represent the HLO module. This is a
// full fidelity serialization of the c++ HLO constructs.
//
// Many of the protos below are simple 1-to-1 serializations of the
// corresponding C++ classes, e.g., HloModule, HloComputation, and
// HloInstruction.
//
// FIELD NAMES ARE IMPORTANT
//
// Unlike most protos, you can't safely change the names of fields, even if you
// keep the numeric ids the same. This is because we sometimes serialize these
// protos as JSON, which includes the field names in the serialization.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Serialization of HloInstruction.
public struct Xla_HloInstructionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var opcode: String {
    get {return _storage._opcode}
    set {_uniqueStorage()._opcode = newValue}
  }

  public var shape: Xla_Shape {
    get {return _storage._shape ?? Xla_Shape()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_storage._shape = nil}

  public var metadata: Xla_OpMetadata {
    get {return _storage._metadata ?? Xla_OpMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_storage._metadata = nil}

  /// Literal, only present for kConstant.
  public var literal: Xla_LiteralProto {
    get {return _storage._literal ?? Xla_LiteralProto()}
    set {_uniqueStorage()._literal = newValue}
  }
  /// Returns true if `literal` has been explicitly set.
  public var hasLiteral: Bool {return _storage._literal != nil}
  /// Clears the value of `literal`. Subsequent reads from it will return its default value.
  public mutating func clearLiteral() {_storage._literal = nil}

  /// Parameter number is only present for kParameter.
  public var parameterNumber: Int64 {
    get {return _storage._parameterNumber}
    set {_uniqueStorage()._parameterNumber = newValue}
  }

  /// Fusion state, only present for kFusion.
  public var fusionKind: String {
    get {return _storage._fusionKind}
    set {_uniqueStorage()._fusionKind = newValue}
  }

  /// Index for kGetTupleElement.
  public var tupleIndex: Int64 {
    get {return _storage._tupleIndex}
    set {_uniqueStorage()._tupleIndex = newValue}
  }

  /// Dimensions present for some operations that require reshaping or
  /// broadcasting, including Reshape, Reduce, ReduceWindow, and Reverse.
  public var dimensions: [Int64] {
    get {return _storage._dimensions}
    set {_uniqueStorage()._dimensions = newValue}
  }

  /// Describes the window in a windowed operation such as convolution.
  public var window: Xla_Window {
    get {return _storage._window ?? Xla_Window()}
    set {_uniqueStorage()._window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return _storage._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {_storage._window = nil}

  /// Describes the dimension numbers used for a convolution.
  public var convolutionDimensionNumbers: Xla_ConvolutionDimensionNumbers {
    get {return _storage._convolutionDimensionNumbers ?? Xla_ConvolutionDimensionNumbers()}
    set {_uniqueStorage()._convolutionDimensionNumbers = newValue}
  }
  /// Returns true if `convolutionDimensionNumbers` has been explicitly set.
  public var hasConvolutionDimensionNumbers: Bool {return _storage._convolutionDimensionNumbers != nil}
  /// Clears the value of `convolutionDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearConvolutionDimensionNumbers() {_storage._convolutionDimensionNumbers = nil}

  public var sliceDimensions: [Xla_HloInstructionProto.SliceDimensions] {
    get {return _storage._sliceDimensions}
    set {_uniqueStorage()._sliceDimensions = newValue}
  }

  /// The bit sizes for a reduce-precision operation.
  public var exponentBits: Int32 {
    get {return _storage._exponentBits}
    set {_uniqueStorage()._exponentBits = newValue}
  }

  public var mantissaBits: Int32 {
    get {return _storage._mantissaBits}
    set {_uniqueStorage()._mantissaBits = newValue}
  }

  /// Describes the [start, start + size) range size for a dynamic slice
  /// ('start' is specified dynamically in the second operand of the operation).
  public var dynamicSliceSizes: [Int64] {
    get {return _storage._dynamicSliceSizes}
    set {_uniqueStorage()._dynamicSliceSizes = newValue}
  }

  /// The padding configuration that describes the edge padding and interior
  /// padding of this pad instruction. Only set for pad instructions.
  public var paddingConfig: Xla_PaddingConfig {
    get {return _storage._paddingConfig ?? Xla_PaddingConfig()}
    set {_uniqueStorage()._paddingConfig = newValue}
  }
  /// Returns true if `paddingConfig` has been explicitly set.
  public var hasPaddingConfig: Bool {return _storage._paddingConfig != nil}
  /// Clears the value of `paddingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPaddingConfig() {_storage._paddingConfig = nil}

  /// Outfeed configuration information, only present for kOutfeed.
  public var outfeedConfig: Data {
    get {return _storage._outfeedConfig}
    set {_uniqueStorage()._outfeedConfig = newValue}
  }

  /// The distribution requested for random number generation.
  /// Only present for kRng.
  public var distribution: Xla_RandomDistribution {
    get {return _storage._distribution}
    set {_uniqueStorage()._distribution = newValue}
  }

  /// A small float number added to the variance to avoid divide-by-zero error.
  /// Only present for kBatchNormTraining.
  public var epsilon: Float {
    get {return _storage._epsilon}
    set {_uniqueStorage()._epsilon = newValue}
  }

  /// An integer value representing the index of the feature dimension.
  /// Only present for kBatchNormTraining.
  public var featureIndex: Int64 {
    get {return _storage._featureIndex}
    set {_uniqueStorage()._featureIndex = newValue}
  }

  /// Represents a unique identifier for each Send/Recv instruction pair.
  /// Only present for kSend or kRecv.
  public var channelID: Int64 {
    get {return _storage._channelID}
    set {_uniqueStorage()._channelID = newValue}
  }

  /// The string representation of the infeed configuration.
  public var infeedConfig: Data {
    get {return _storage._infeedConfig}
    set {_uniqueStorage()._infeedConfig = newValue}
  }

  /// Name of a global symbol to call, only present for kCustomCall.
  public var customCallTarget: String {
    get {return _storage._customCallTarget}
    set {_uniqueStorage()._customCallTarget = newValue}
  }

  /// Shape of outfeed request.
  public var outfeedShape: Xla_Shape {
    get {return _storage._outfeedShape ?? Xla_Shape()}
    set {_uniqueStorage()._outfeedShape = newValue}
  }
  /// Returns true if `outfeedShape` has been explicitly set.
  public var hasOutfeedShape: Bool {return _storage._outfeedShape != nil}
  /// Clears the value of `outfeedShape`. Subsequent reads from it will return its default value.
  public mutating func clearOutfeedShape() {_storage._outfeedShape = nil}

  /// Describes the dimension numbers used for a dot operation
  public var dotDimensionNumbers: Xla_DotDimensionNumbers {
    get {return _storage._dotDimensionNumbers ?? Xla_DotDimensionNumbers()}
    set {_uniqueStorage()._dotDimensionNumbers = newValue}
  }
  /// Returns true if `dotDimensionNumbers` has been explicitly set.
  public var hasDotDimensionNumbers: Bool {return _storage._dotDimensionNumbers != nil}
  /// Clears the value of `dotDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearDotDimensionNumbers() {_storage._dotDimensionNumbers = nil}

  /// FFT type (FFT, IFFT, etc).
  public var fftType: Xla_FftType {
    get {return _storage._fftType}
    set {_uniqueStorage()._fftType = newValue}
  }

  /// FFT length.
  public var fftLength: [Int64] {
    get {return _storage._fftLength}
    set {_uniqueStorage()._fftLength = newValue}
  }

  /// Gather dimension numbers.
  public var gatherDimensionNumbers: Xla_GatherDimensionNumbers {
    get {return _storage._gatherDimensionNumbers ?? Xla_GatherDimensionNumbers()}
    set {_uniqueStorage()._gatherDimensionNumbers = newValue}
  }
  /// Returns true if `gatherDimensionNumbers` has been explicitly set.
  public var hasGatherDimensionNumbers: Bool {return _storage._gatherDimensionNumbers != nil}
  /// Clears the value of `gatherDimensionNumbers`. Subsequent reads from it will return its default value.
  public mutating func clearGatherDimensionNumbers() {_storage._gatherDimensionNumbers = nil}

  public var gatherWindowBounds: [Int64] {
    get {return _storage._gatherWindowBounds}
    set {_uniqueStorage()._gatherWindowBounds = newValue}
  }

  /// Compute Host.
  public var channelName: String {
    get {return _storage._channelName}
    set {_uniqueStorage()._channelName = newValue}
  }

  public var costEstimateNs: Int64 {
    get {return _storage._costEstimateNs}
    set {_uniqueStorage()._costEstimateNs = newValue}
  }

  /// The id of this instruction.
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var operandIds: [Int64] {
    get {return _storage._operandIds}
    set {_uniqueStorage()._operandIds = newValue}
  }

  public var controlPredecessorIds: [Int64] {
    get {return _storage._controlPredecessorIds}
    set {_uniqueStorage()._controlPredecessorIds = newValue}
  }

  public var calledComputationIds: [Int64] {
    get {return _storage._calledComputationIds}
    set {_uniqueStorage()._calledComputationIds = newValue}
  }

  public var sharding: Xla_OpSharding {
    get {return _storage._sharding ?? Xla_OpSharding()}
    set {_uniqueStorage()._sharding = newValue}
  }
  /// Returns true if `sharding` has been explicitly set.
  public var hasSharding: Bool {return _storage._sharding != nil}
  /// Clears the value of `sharding`. Subsequent reads from it will return its default value.
  public mutating func clearSharding() {_storage._sharding = nil}

  /// Backend configuration for the instruction. Has backend-specific meaning.
  public var backendConfig: String {
    get {return _storage._backendConfig}
    set {_uniqueStorage()._backendConfig = newValue}
  }

  /// Cross Replica Sum fields.
  public var replicaGroupIds: [Int64] {
    get {return _storage._replicaGroupIds}
    set {_uniqueStorage()._replicaGroupIds = newValue}
  }

  public var allReduceID: Int64 {
    get {return _storage._allReduceID}
    set {_uniqueStorage()._allReduceID = newValue}
  }

  public var crossReplicaSumBarrier: String {
    get {return _storage._crossReplicaSumBarrier}
    set {_uniqueStorage()._crossReplicaSumBarrier = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the [begin, end) index range and stride for slices.
  public struct SliceDimensions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var start: Int64 = 0

    public var limit: Int64 = 0

    public var stride: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of HloComputation.
public struct Xla_HloComputationProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The array of instructions is always in a valid dependency order, where
  /// operands appear before their users.
  public var instructions: [Xla_HloInstructionProto] {
    get {return _storage._instructions}
    set {_uniqueStorage()._instructions = newValue}
  }

  /// The program shape (with layout) of this computation.
  public var programShape: Xla_ProgramShape {
    get {return _storage._programShape ?? Xla_ProgramShape()}
    set {_uniqueStorage()._programShape = newValue}
  }
  /// Returns true if `programShape` has been explicitly set.
  public var hasProgramShape: Bool {return _storage._programShape != nil}
  /// Clears the value of `programShape`. Subsequent reads from it will return its default value.
  public mutating func clearProgramShape() {_storage._programShape = nil}

  /// The id of this computation.
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The id of the root of the computation.
  public var rootID: Int64 {
    get {return _storage._rootID}
    set {_uniqueStorage()._rootID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of HloModule.
public struct Xla_HloModuleProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var entryComputationName: String {
    get {return _storage._entryComputationName}
    set {_uniqueStorage()._entryComputationName = newValue}
  }

  public var entryComputationID: Int64 {
    get {return _storage._entryComputationID}
    set {_uniqueStorage()._entryComputationID = newValue}
  }

  /// The array of computations is always in a valid dependency order, where
  /// callees appear before their callers.
  public var computations: [Xla_HloComputationProto] {
    get {return _storage._computations}
    set {_uniqueStorage()._computations = newValue}
  }

  /// The program shape (with layout) of the entry computation.
  public var programShape: Xla_ProgramShape {
    get {return _storage._programShape ?? Xla_ProgramShape()}
    set {_uniqueStorage()._programShape = newValue}
  }
  /// Returns true if `programShape` has been explicitly set.
  public var hasProgramShape: Bool {return _storage._programShape != nil}
  /// Clears the value of `programShape`. Subsequent reads from it will return its default value.
  public mutating func clearProgramShape() {_storage._programShape = nil}

  /// The id of this module.
  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of HloOrdering.
public struct Xla_HloOrderingProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sequentialComputations: [Xla_HloOrderingProto.SequentialComputation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// NOTE: currently only sequential orderings are serialized.
  public struct SequentialComputation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var computationName: String = String()

    public var instructionNames: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Serialization of LogicalBuffer.
public struct Xla_LogicalBufferProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var size: Int64 {
    get {return _storage._size}
    set {_uniqueStorage()._size = newValue}
  }

  /// The location where the buffer is defined.
  public var definedAt: Xla_LogicalBufferProto.Location {
    get {return _storage._definedAt ?? Xla_LogicalBufferProto.Location()}
    set {_uniqueStorage()._definedAt = newValue}
  }
  /// Returns true if `definedAt` has been explicitly set.
  public var hasDefinedAt: Bool {return _storage._definedAt != nil}
  /// Clears the value of `definedAt`. Subsequent reads from it will return its default value.
  public mutating func clearDefinedAt() {_storage._definedAt = nil}

  public var color: Int64 {
    get {return _storage._color}
    set {_uniqueStorage()._color = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Location represents an instruction and its shape index, which uniquely
  /// identifies a point where a buffer is needed.
  public struct Location {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// NOTE: module_name isn't necessary, since all LogicalBuffers are
    /// associated with a single HloModule.
    public var computationName: String = String()

    public var instructionName: String = String()

    public var shapeIndex: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Serialization of BufferAllocation.
public struct Xla_BufferAllocationProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var index: Int64 = 0

  public var size: Int64 = 0

  public var isThreadLocal: Bool = false

  public var isReusable: Bool = false

  public var isEntryComputationParameter: Bool = false

  public var parameterNumber: Int64 = 0

  public var parameterShapeIndex: [Int64] = []

  public var maybeLiveOut: Bool = false

  public var color: Int64 = 0

  public var assigned: [Xla_BufferAllocationProto.Assigned] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Assigned represents a single LogicalBuffer that is assigned to this
  /// BufferAllocation.
  public struct Assigned {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var logicalBufferID: Int64 = 0

    public var offset: Int64 = 0

    public var size: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A trace of a HeapSimulator run.
public struct Xla_HeapSimulatorTrace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var events: [Xla_HeapSimulatorTrace.Event] = []

  public var wholeModuleSimulation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The trace includes a list of events, where each event describes one action
  /// performed by the heap simulator.
  public struct Event {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var kind: Xla_HeapSimulatorTrace.Event.Kind = .alloc

    /// The id of the LogicalBuffer that the event applies to.
    public var bufferID: Int64 = 0

    /// The HloInstruction that the simulation was processing that caused this
    /// event to occur, identified by its computation and instruction name. E.g.
    /// buffers defined by instruction A are allocated when processing A.
    public var computationName: String = String()

    public var instructionName: String = String()

    /// The id of the canonical LogicalBuffer that the buffer shares with. Only
    /// set for SHARE_WITH events.
    public var shareWithCanonicalID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Kind: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// A memory region was allocated for the buffer.
      case alloc // = 0

      /// A memory region was freed for the buffer.
      case free // = 1

      /// A buffer was shared with another (canonical) buffer. This is similar to
      /// ALLOC, except that instead of allocating a new region of memory, the
      /// memory region of the canonical buffer is directly re-used. Multiple
      /// buffers may share with the same canonical buffer. The lifetime of the
      /// canonical buffer is extended to the union of all lifetimes.
      case shareWith // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .alloc
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .alloc
        case 1: self = .free
        case 2: self = .shareWith
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .alloc: return 0
        case .free: return 1
        case .shareWith: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

/// Serialization of BufferAssignment.
public struct Xla_BufferAssignmentProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var logicalBuffers: [Xla_LogicalBufferProto] = []

  public var bufferAliases: [Xla_BufferAssignmentProto.BufferAlias] = []

  public var bufferAllocations: [Xla_BufferAllocationProto] = []

  public var heapSimulatorTraces: [Xla_HeapSimulatorTrace] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Alias represents a source LogicalBuffer, and the buffer location that
  /// aliases it.
  public struct BufferAlias {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sourceBufferID: Int64 {
      get {return _storage._sourceBufferID}
      set {_uniqueStorage()._sourceBufferID = newValue}
    }

    public var location: Xla_LogicalBufferProto.Location {
      get {return _storage._location ?? Xla_LogicalBufferProto.Location()}
      set {_uniqueStorage()._location = newValue}
    }
    /// Returns true if `location` has been explicitly set.
    public var hasLocation: Bool {return _storage._location != nil}
    /// Clears the value of `location`. Subsequent reads from it will return its default value.
    public mutating func clearLocation() {_storage._location = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Grouping message that contains all of the information above.
public struct Xla_HloProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hloModule: Xla_HloModuleProto {
    get {return _storage._hloModule ?? Xla_HloModuleProto()}
    set {_uniqueStorage()._hloModule = newValue}
  }
  /// Returns true if `hloModule` has been explicitly set.
  public var hasHloModule: Bool {return _storage._hloModule != nil}
  /// Clears the value of `hloModule`. Subsequent reads from it will return its default value.
  public mutating func clearHloModule() {_storage._hloModule = nil}

  public var hloOrdering: Xla_HloOrderingProto {
    get {return _storage._hloOrdering ?? Xla_HloOrderingProto()}
    set {_uniqueStorage()._hloOrdering = newValue}
  }
  /// Returns true if `hloOrdering` has been explicitly set.
  public var hasHloOrdering: Bool {return _storage._hloOrdering != nil}
  /// Clears the value of `hloOrdering`. Subsequent reads from it will return its default value.
  public mutating func clearHloOrdering() {_storage._hloOrdering = nil}

  public var bufferAssignment: Xla_BufferAssignmentProto {
    get {return _storage._bufferAssignment ?? Xla_BufferAssignmentProto()}
    set {_uniqueStorage()._bufferAssignment = newValue}
  }
  /// Returns true if `bufferAssignment` has been explicitly set.
  public var hasBufferAssignment: Bool {return _storage._bufferAssignment != nil}
  /// Clears the value of `bufferAssignment`. Subsequent reads from it will return its default value.
  public mutating func clearBufferAssignment() {_storage._bufferAssignment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Encapsulates HloProto together with the arguments, result, and
/// execution_platform. This message is used for purposes such as
/// analysis/replay/file-storage.
public struct Xla_HloSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hlo graph.
  public var hlo: Xla_HloProto {
    get {return _storage._hlo ?? Xla_HloProto()}
    set {_uniqueStorage()._hlo = newValue}
  }
  /// Returns true if `hlo` has been explicitly set.
  public var hasHlo: Bool {return _storage._hlo != nil}
  /// Clears the value of `hlo`. Subsequent reads from it will return its default value.
  public mutating func clearHlo() {_storage._hlo = nil}

  /// The arguments passed to the graph.
  public var arguments: [Xla_LiteralProto] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  /// The result of the graph.
  public var result: Xla_LiteralProto {
    get {return _storage._result ?? Xla_LiteralProto()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  public var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  public mutating func clearResult() {_storage._result = nil}

  /// The name of the platform used to run the graph.
  public var executionPlatform: String {
    get {return _storage._executionPlatform}
    set {_uniqueStorage()._executionPlatform = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xla"

extension Xla_HloInstructionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloInstructionProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "opcode"),
    3: .same(proto: "shape"),
    7: .same(proto: "metadata"),
    8: .same(proto: "literal"),
    9: .standard(proto: "parameter_number"),
    11: .standard(proto: "fusion_kind"),
    13: .standard(proto: "tuple_index"),
    14: .same(proto: "dimensions"),
    15: .same(proto: "window"),
    16: .standard(proto: "convolution_dimension_numbers"),
    17: .standard(proto: "slice_dimensions"),
    18: .standard(proto: "exponent_bits"),
    19: .standard(proto: "mantissa_bits"),
    20: .standard(proto: "dynamic_slice_sizes"),
    21: .standard(proto: "padding_config"),
    22: .standard(proto: "outfeed_config"),
    23: .same(proto: "distribution"),
    24: .same(proto: "epsilon"),
    25: .standard(proto: "feature_index"),
    26: .standard(proto: "channel_id"),
    27: .standard(proto: "infeed_config"),
    28: .standard(proto: "custom_call_target"),
    29: .standard(proto: "outfeed_shape"),
    30: .standard(proto: "dot_dimension_numbers"),
    31: .standard(proto: "fft_type"),
    32: .standard(proto: "fft_length"),
    33: .standard(proto: "gather_dimension_numbers"),
    34: .standard(proto: "gather_window_bounds"),
    41: .standard(proto: "channel_name"),
    42: .standard(proto: "cost_estimate_ns"),
    35: .same(proto: "id"),
    36: .standard(proto: "operand_ids"),
    37: .standard(proto: "control_predecessor_ids"),
    38: .standard(proto: "called_computation_ids"),
    40: .same(proto: "sharding"),
    43: .standard(proto: "backend_config"),
    44: .standard(proto: "replica_group_ids"),
    45: .standard(proto: "all_reduce_id"),
    46: .standard(proto: "cross_replica_sum_barrier"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _opcode: String = String()
    var _shape: Xla_Shape? = nil
    var _metadata: Xla_OpMetadata? = nil
    var _literal: Xla_LiteralProto? = nil
    var _parameterNumber: Int64 = 0
    var _fusionKind: String = String()
    var _tupleIndex: Int64 = 0
    var _dimensions: [Int64] = []
    var _window: Xla_Window? = nil
    var _convolutionDimensionNumbers: Xla_ConvolutionDimensionNumbers? = nil
    var _sliceDimensions: [Xla_HloInstructionProto.SliceDimensions] = []
    var _exponentBits: Int32 = 0
    var _mantissaBits: Int32 = 0
    var _dynamicSliceSizes: [Int64] = []
    var _paddingConfig: Xla_PaddingConfig? = nil
    var _outfeedConfig: Data = SwiftProtobuf.Internal.emptyData
    var _distribution: Xla_RandomDistribution = .rngInvalid
    var _epsilon: Float = 0
    var _featureIndex: Int64 = 0
    var _channelID: Int64 = 0
    var _infeedConfig: Data = SwiftProtobuf.Internal.emptyData
    var _customCallTarget: String = String()
    var _outfeedShape: Xla_Shape? = nil
    var _dotDimensionNumbers: Xla_DotDimensionNumbers? = nil
    var _fftType: Xla_FftType = .fft
    var _fftLength: [Int64] = []
    var _gatherDimensionNumbers: Xla_GatherDimensionNumbers? = nil
    var _gatherWindowBounds: [Int64] = []
    var _channelName: String = String()
    var _costEstimateNs: Int64 = 0
    var _id: Int64 = 0
    var _operandIds: [Int64] = []
    var _controlPredecessorIds: [Int64] = []
    var _calledComputationIds: [Int64] = []
    var _sharding: Xla_OpSharding? = nil
    var _backendConfig: String = String()
    var _replicaGroupIds: [Int64] = []
    var _allReduceID: Int64 = 0
    var _crossReplicaSumBarrier: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _opcode = source._opcode
      _shape = source._shape
      _metadata = source._metadata
      _literal = source._literal
      _parameterNumber = source._parameterNumber
      _fusionKind = source._fusionKind
      _tupleIndex = source._tupleIndex
      _dimensions = source._dimensions
      _window = source._window
      _convolutionDimensionNumbers = source._convolutionDimensionNumbers
      _sliceDimensions = source._sliceDimensions
      _exponentBits = source._exponentBits
      _mantissaBits = source._mantissaBits
      _dynamicSliceSizes = source._dynamicSliceSizes
      _paddingConfig = source._paddingConfig
      _outfeedConfig = source._outfeedConfig
      _distribution = source._distribution
      _epsilon = source._epsilon
      _featureIndex = source._featureIndex
      _channelID = source._channelID
      _infeedConfig = source._infeedConfig
      _customCallTarget = source._customCallTarget
      _outfeedShape = source._outfeedShape
      _dotDimensionNumbers = source._dotDimensionNumbers
      _fftType = source._fftType
      _fftLength = source._fftLength
      _gatherDimensionNumbers = source._gatherDimensionNumbers
      _gatherWindowBounds = source._gatherWindowBounds
      _channelName = source._channelName
      _costEstimateNs = source._costEstimateNs
      _id = source._id
      _operandIds = source._operandIds
      _controlPredecessorIds = source._controlPredecessorIds
      _calledComputationIds = source._calledComputationIds
      _sharding = source._sharding
      _backendConfig = source._backendConfig
      _replicaGroupIds = source._replicaGroupIds
      _allReduceID = source._allReduceID
      _crossReplicaSumBarrier = source._crossReplicaSumBarrier
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._opcode)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._shape)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._literal)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._parameterNumber)
        case 11: try decoder.decodeSingularStringField(value: &_storage._fusionKind)
        case 13: try decoder.decodeSingularInt64Field(value: &_storage._tupleIndex)
        case 14: try decoder.decodeRepeatedInt64Field(value: &_storage._dimensions)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._window)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._convolutionDimensionNumbers)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._sliceDimensions)
        case 18: try decoder.decodeSingularInt32Field(value: &_storage._exponentBits)
        case 19: try decoder.decodeSingularInt32Field(value: &_storage._mantissaBits)
        case 20: try decoder.decodeRepeatedInt64Field(value: &_storage._dynamicSliceSizes)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._paddingConfig)
        case 22: try decoder.decodeSingularBytesField(value: &_storage._outfeedConfig)
        case 23: try decoder.decodeSingularEnumField(value: &_storage._distribution)
        case 24: try decoder.decodeSingularFloatField(value: &_storage._epsilon)
        case 25: try decoder.decodeSingularInt64Field(value: &_storage._featureIndex)
        case 26: try decoder.decodeSingularInt64Field(value: &_storage._channelID)
        case 27: try decoder.decodeSingularBytesField(value: &_storage._infeedConfig)
        case 28: try decoder.decodeSingularStringField(value: &_storage._customCallTarget)
        case 29: try decoder.decodeSingularMessageField(value: &_storage._outfeedShape)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._dotDimensionNumbers)
        case 31: try decoder.decodeSingularEnumField(value: &_storage._fftType)
        case 32: try decoder.decodeRepeatedInt64Field(value: &_storage._fftLength)
        case 33: try decoder.decodeSingularMessageField(value: &_storage._gatherDimensionNumbers)
        case 34: try decoder.decodeRepeatedInt64Field(value: &_storage._gatherWindowBounds)
        case 35: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 36: try decoder.decodeRepeatedInt64Field(value: &_storage._operandIds)
        case 37: try decoder.decodeRepeatedInt64Field(value: &_storage._controlPredecessorIds)
        case 38: try decoder.decodeRepeatedInt64Field(value: &_storage._calledComputationIds)
        case 40: try decoder.decodeSingularMessageField(value: &_storage._sharding)
        case 41: try decoder.decodeSingularStringField(value: &_storage._channelName)
        case 42: try decoder.decodeSingularInt64Field(value: &_storage._costEstimateNs)
        case 43: try decoder.decodeSingularStringField(value: &_storage._backendConfig)
        case 44: try decoder.decodeRepeatedInt64Field(value: &_storage._replicaGroupIds)
        case 45: try decoder.decodeSingularInt64Field(value: &_storage._allReduceID)
        case 46: try decoder.decodeSingularStringField(value: &_storage._crossReplicaSumBarrier)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._opcode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._opcode, fieldNumber: 2)
      }
      if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._literal {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._parameterNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parameterNumber, fieldNumber: 9)
      }
      if !_storage._fusionKind.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fusionKind, fieldNumber: 11)
      }
      if _storage._tupleIndex != 0 {
        try visitor.visitSingularInt64Field(value: _storage._tupleIndex, fieldNumber: 13)
      }
      if !_storage._dimensions.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dimensions, fieldNumber: 14)
      }
      if let v = _storage._window {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._convolutionDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._sliceDimensions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sliceDimensions, fieldNumber: 17)
      }
      if _storage._exponentBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exponentBits, fieldNumber: 18)
      }
      if _storage._mantissaBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mantissaBits, fieldNumber: 19)
      }
      if !_storage._dynamicSliceSizes.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._dynamicSliceSizes, fieldNumber: 20)
      }
      if let v = _storage._paddingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if !_storage._outfeedConfig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._outfeedConfig, fieldNumber: 22)
      }
      if _storage._distribution != .rngInvalid {
        try visitor.visitSingularEnumField(value: _storage._distribution, fieldNumber: 23)
      }
      if _storage._epsilon != 0 {
        try visitor.visitSingularFloatField(value: _storage._epsilon, fieldNumber: 24)
      }
      if _storage._featureIndex != 0 {
        try visitor.visitSingularInt64Field(value: _storage._featureIndex, fieldNumber: 25)
      }
      if _storage._channelID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._channelID, fieldNumber: 26)
      }
      if !_storage._infeedConfig.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._infeedConfig, fieldNumber: 27)
      }
      if !_storage._customCallTarget.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customCallTarget, fieldNumber: 28)
      }
      if let v = _storage._outfeedShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._dotDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if _storage._fftType != .fft {
        try visitor.visitSingularEnumField(value: _storage._fftType, fieldNumber: 31)
      }
      if !_storage._fftLength.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._fftLength, fieldNumber: 32)
      }
      if let v = _storage._gatherDimensionNumbers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if !_storage._gatherWindowBounds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._gatherWindowBounds, fieldNumber: 34)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 35)
      }
      if !_storage._operandIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._operandIds, fieldNumber: 36)
      }
      if !_storage._controlPredecessorIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._controlPredecessorIds, fieldNumber: 37)
      }
      if !_storage._calledComputationIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._calledComputationIds, fieldNumber: 38)
      }
      if let v = _storage._sharding {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
      if !_storage._channelName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._channelName, fieldNumber: 41)
      }
      if _storage._costEstimateNs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._costEstimateNs, fieldNumber: 42)
      }
      if !_storage._backendConfig.isEmpty {
        try visitor.visitSingularStringField(value: _storage._backendConfig, fieldNumber: 43)
      }
      if !_storage._replicaGroupIds.isEmpty {
        try visitor.visitPackedInt64Field(value: _storage._replicaGroupIds, fieldNumber: 44)
      }
      if _storage._allReduceID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allReduceID, fieldNumber: 45)
      }
      if !_storage._crossReplicaSumBarrier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._crossReplicaSumBarrier, fieldNumber: 46)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloInstructionProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._opcode != other_storage._opcode {return false}
        if _storage._shape != other_storage._shape {return false}
        if _storage._metadata != other_storage._metadata {return false}
        if _storage._literal != other_storage._literal {return false}
        if _storage._parameterNumber != other_storage._parameterNumber {return false}
        if _storage._fusionKind != other_storage._fusionKind {return false}
        if _storage._tupleIndex != other_storage._tupleIndex {return false}
        if _storage._dimensions != other_storage._dimensions {return false}
        if _storage._window != other_storage._window {return false}
        if _storage._convolutionDimensionNumbers != other_storage._convolutionDimensionNumbers {return false}
        if _storage._sliceDimensions != other_storage._sliceDimensions {return false}
        if _storage._exponentBits != other_storage._exponentBits {return false}
        if _storage._mantissaBits != other_storage._mantissaBits {return false}
        if _storage._dynamicSliceSizes != other_storage._dynamicSliceSizes {return false}
        if _storage._paddingConfig != other_storage._paddingConfig {return false}
        if _storage._outfeedConfig != other_storage._outfeedConfig {return false}
        if _storage._distribution != other_storage._distribution {return false}
        if _storage._epsilon != other_storage._epsilon {return false}
        if _storage._featureIndex != other_storage._featureIndex {return false}
        if _storage._channelID != other_storage._channelID {return false}
        if _storage._infeedConfig != other_storage._infeedConfig {return false}
        if _storage._customCallTarget != other_storage._customCallTarget {return false}
        if _storage._outfeedShape != other_storage._outfeedShape {return false}
        if _storage._dotDimensionNumbers != other_storage._dotDimensionNumbers {return false}
        if _storage._fftType != other_storage._fftType {return false}
        if _storage._fftLength != other_storage._fftLength {return false}
        if _storage._gatherDimensionNumbers != other_storage._gatherDimensionNumbers {return false}
        if _storage._gatherWindowBounds != other_storage._gatherWindowBounds {return false}
        if _storage._channelName != other_storage._channelName {return false}
        if _storage._costEstimateNs != other_storage._costEstimateNs {return false}
        if _storage._id != other_storage._id {return false}
        if _storage._operandIds != other_storage._operandIds {return false}
        if _storage._controlPredecessorIds != other_storage._controlPredecessorIds {return false}
        if _storage._calledComputationIds != other_storage._calledComputationIds {return false}
        if _storage._sharding != other_storage._sharding {return false}
        if _storage._backendConfig != other_storage._backendConfig {return false}
        if _storage._replicaGroupIds != other_storage._replicaGroupIds {return false}
        if _storage._allReduceID != other_storage._allReduceID {return false}
        if _storage._crossReplicaSumBarrier != other_storage._crossReplicaSumBarrier {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloInstructionProto.SliceDimensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_HloInstructionProto.protoMessageName + ".SliceDimensions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "limit"),
    3: .same(proto: "stride"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.start)
      case 2: try decoder.decodeSingularInt64Field(value: &self.limit)
      case 3: try decoder.decodeSingularInt64Field(value: &self.stride)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt64Field(value: self.start, fieldNumber: 1)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 2)
    }
    if self.stride != 0 {
      try visitor.visitSingularInt64Field(value: self.stride, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloInstructionProto.SliceDimensions) -> Bool {
    if self.start != other.start {return false}
    if self.limit != other.limit {return false}
    if self.stride != other.stride {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloComputationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloComputationProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "instructions"),
    4: .standard(proto: "program_shape"),
    5: .same(proto: "id"),
    6: .standard(proto: "root_id"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _instructions: [Xla_HloInstructionProto] = []
    var _programShape: Xla_ProgramShape? = nil
    var _id: Int64 = 0
    var _rootID: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _instructions = source._instructions
      _programShape = source._programShape
      _id = source._id
      _rootID = source._rootID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._instructions)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._programShape)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._rootID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._instructions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._instructions, fieldNumber: 2)
      }
      if let v = _storage._programShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 5)
      }
      if _storage._rootID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._rootID, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloComputationProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._instructions != other_storage._instructions {return false}
        if _storage._programShape != other_storage._programShape {return false}
        if _storage._id != other_storage._id {return false}
        if _storage._rootID != other_storage._rootID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloModuleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloModuleProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "entry_computation_name"),
    6: .standard(proto: "entry_computation_id"),
    3: .same(proto: "computations"),
    4: .standard(proto: "program_shape"),
    5: .same(proto: "id"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _entryComputationName: String = String()
    var _entryComputationID: Int64 = 0
    var _computations: [Xla_HloComputationProto] = []
    var _programShape: Xla_ProgramShape? = nil
    var _id: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _entryComputationName = source._entryComputationName
      _entryComputationID = source._entryComputationID
      _computations = source._computations
      _programShape = source._programShape
      _id = source._id
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularStringField(value: &_storage._entryComputationName)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._computations)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._programShape)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 6: try decoder.decodeSingularInt64Field(value: &_storage._entryComputationID)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._entryComputationName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entryComputationName, fieldNumber: 2)
      }
      if !_storage._computations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._computations, fieldNumber: 3)
      }
      if let v = _storage._programShape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 5)
      }
      if _storage._entryComputationID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._entryComputationID, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloModuleProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._name != other_storage._name {return false}
        if _storage._entryComputationName != other_storage._entryComputationName {return false}
        if _storage._entryComputationID != other_storage._entryComputationID {return false}
        if _storage._computations != other_storage._computations {return false}
        if _storage._programShape != other_storage._programShape {return false}
        if _storage._id != other_storage._id {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloOrderingProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloOrderingProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sequential_computations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.sequentialComputations)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sequentialComputations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sequentialComputations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloOrderingProto) -> Bool {
    if self.sequentialComputations != other.sequentialComputations {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloOrderingProto.SequentialComputation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_HloOrderingProto.protoMessageName + ".SequentialComputation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "computation_name"),
    2: .standard(proto: "instruction_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.computationName)
      case 2: try decoder.decodeRepeatedStringField(value: &self.instructionNames)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.computationName.isEmpty {
      try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 1)
    }
    if !self.instructionNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instructionNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloOrderingProto.SequentialComputation) -> Bool {
    if self.computationName != other.computationName {return false}
    if self.instructionNames != other.instructionNames {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_LogicalBufferProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogicalBufferProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "size"),
    3: .standard(proto: "defined_at"),
    4: .same(proto: "color"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _size: Int64 = 0
    var _definedAt: Xla_LogicalBufferProto.Location? = nil
    var _color: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _size = source._size
      _definedAt = source._definedAt
      _color = source._color
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._size)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._definedAt)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._color)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt64Field(value: _storage._size, fieldNumber: 2)
      }
      if let v = _storage._definedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if _storage._color != 0 {
        try visitor.visitSingularInt64Field(value: _storage._color, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_LogicalBufferProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._id != other_storage._id {return false}
        if _storage._size != other_storage._size {return false}
        if _storage._definedAt != other_storage._definedAt {return false}
        if _storage._color != other_storage._color {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_LogicalBufferProto.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_LogicalBufferProto.protoMessageName + ".Location"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "computation_name"),
    2: .standard(proto: "instruction_name"),
    3: .standard(proto: "shape_index"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.computationName)
      case 2: try decoder.decodeSingularStringField(value: &self.instructionName)
      case 3: try decoder.decodeRepeatedInt64Field(value: &self.shapeIndex)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.computationName.isEmpty {
      try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 1)
    }
    if !self.instructionName.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionName, fieldNumber: 2)
    }
    if !self.shapeIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.shapeIndex, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_LogicalBufferProto.Location) -> Bool {
    if self.computationName != other.computationName {return false}
    if self.instructionName != other.instructionName {return false}
    if self.shapeIndex != other.shapeIndex {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAllocationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BufferAllocationProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "size"),
    3: .standard(proto: "is_thread_local"),
    4: .standard(proto: "is_reusable"),
    5: .standard(proto: "is_entry_computation_parameter"),
    6: .standard(proto: "parameter_number"),
    10: .standard(proto: "parameter_shape_index"),
    7: .standard(proto: "maybe_live_out"),
    8: .same(proto: "color"),
    9: .same(proto: "assigned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
      case 2: try decoder.decodeSingularInt64Field(value: &self.size)
      case 3: try decoder.decodeSingularBoolField(value: &self.isThreadLocal)
      case 4: try decoder.decodeSingularBoolField(value: &self.isReusable)
      case 5: try decoder.decodeSingularBoolField(value: &self.isEntryComputationParameter)
      case 6: try decoder.decodeSingularInt64Field(value: &self.parameterNumber)
      case 7: try decoder.decodeSingularBoolField(value: &self.maybeLiveOut)
      case 8: try decoder.decodeSingularInt64Field(value: &self.color)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.assigned)
      case 10: try decoder.decodeRepeatedInt64Field(value: &self.parameterShapeIndex)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 2)
    }
    if self.isThreadLocal != false {
      try visitor.visitSingularBoolField(value: self.isThreadLocal, fieldNumber: 3)
    }
    if self.isReusable != false {
      try visitor.visitSingularBoolField(value: self.isReusable, fieldNumber: 4)
    }
    if self.isEntryComputationParameter != false {
      try visitor.visitSingularBoolField(value: self.isEntryComputationParameter, fieldNumber: 5)
    }
    if self.parameterNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.parameterNumber, fieldNumber: 6)
    }
    if self.maybeLiveOut != false {
      try visitor.visitSingularBoolField(value: self.maybeLiveOut, fieldNumber: 7)
    }
    if self.color != 0 {
      try visitor.visitSingularInt64Field(value: self.color, fieldNumber: 8)
    }
    if !self.assigned.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assigned, fieldNumber: 9)
    }
    if !self.parameterShapeIndex.isEmpty {
      try visitor.visitPackedInt64Field(value: self.parameterShapeIndex, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAllocationProto) -> Bool {
    if self.index != other.index {return false}
    if self.size != other.size {return false}
    if self.isThreadLocal != other.isThreadLocal {return false}
    if self.isReusable != other.isReusable {return false}
    if self.isEntryComputationParameter != other.isEntryComputationParameter {return false}
    if self.parameterNumber != other.parameterNumber {return false}
    if self.parameterShapeIndex != other.parameterShapeIndex {return false}
    if self.maybeLiveOut != other.maybeLiveOut {return false}
    if self.color != other.color {return false}
    if self.assigned != other.assigned {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAllocationProto.Assigned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_BufferAllocationProto.protoMessageName + ".Assigned"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logical_buffer_id"),
    2: .same(proto: "offset"),
    3: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.logicalBufferID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.offset)
      case 3: try decoder.decodeSingularInt64Field(value: &self.size)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.logicalBufferID != 0 {
      try visitor.visitSingularInt64Field(value: self.logicalBufferID, fieldNumber: 1)
    }
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 2)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAllocationProto.Assigned) -> Bool {
    if self.logicalBufferID != other.logicalBufferID {return false}
    if self.offset != other.offset {return false}
    if self.size != other.size {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeapSimulatorTrace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "whole_module_simulation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.events)
      case 2: try decoder.decodeSingularBoolField(value: &self.wholeModuleSimulation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if self.wholeModuleSimulation != false {
      try visitor.visitSingularBoolField(value: self.wholeModuleSimulation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HeapSimulatorTrace) -> Bool {
    if self.events != other.events {return false}
    if self.wholeModuleSimulation != other.wholeModuleSimulation {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_HeapSimulatorTrace.protoMessageName + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .standard(proto: "buffer_id"),
    3: .standard(proto: "computation_name"),
    4: .standard(proto: "instruction_name"),
    5: .standard(proto: "share_with_canonical_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.kind)
      case 2: try decoder.decodeSingularInt64Field(value: &self.bufferID)
      case 3: try decoder.decodeSingularStringField(value: &self.computationName)
      case 4: try decoder.decodeSingularStringField(value: &self.instructionName)
      case 5: try decoder.decodeSingularInt64Field(value: &self.shareWithCanonicalID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .alloc {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if self.bufferID != 0 {
      try visitor.visitSingularInt64Field(value: self.bufferID, fieldNumber: 2)
    }
    if !self.computationName.isEmpty {
      try visitor.visitSingularStringField(value: self.computationName, fieldNumber: 3)
    }
    if !self.instructionName.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionName, fieldNumber: 4)
    }
    if self.shareWithCanonicalID != 0 {
      try visitor.visitSingularInt64Field(value: self.shareWithCanonicalID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HeapSimulatorTrace.Event) -> Bool {
    if self.kind != other.kind {return false}
    if self.bufferID != other.bufferID {return false}
    if self.computationName != other.computationName {return false}
    if self.instructionName != other.instructionName {return false}
    if self.shareWithCanonicalID != other.shareWithCanonicalID {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HeapSimulatorTrace.Event.Kind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOC"),
    1: .same(proto: "FREE"),
    2: .same(proto: "SHARE_WITH"),
  ]
}

extension Xla_BufferAssignmentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BufferAssignmentProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "logical_buffers"),
    2: .standard(proto: "buffer_aliases"),
    3: .standard(proto: "buffer_allocations"),
    4: .standard(proto: "heap_simulator_traces"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.logicalBuffers)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.bufferAliases)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.bufferAllocations)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.heapSimulatorTraces)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logicalBuffers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logicalBuffers, fieldNumber: 1)
    }
    if !self.bufferAliases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bufferAliases, fieldNumber: 2)
    }
    if !self.bufferAllocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bufferAllocations, fieldNumber: 3)
    }
    if !self.heapSimulatorTraces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.heapSimulatorTraces, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAssignmentProto) -> Bool {
    if self.logicalBuffers != other.logicalBuffers {return false}
    if self.bufferAliases != other.bufferAliases {return false}
    if self.bufferAllocations != other.bufferAllocations {return false}
    if self.heapSimulatorTraces != other.heapSimulatorTraces {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_BufferAssignmentProto.BufferAlias: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Xla_BufferAssignmentProto.protoMessageName + ".BufferAlias"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_buffer_id"),
    2: .same(proto: "location"),
  ]

  fileprivate class _StorageClass {
    var _sourceBufferID: Int64 = 0
    var _location: Xla_LogicalBufferProto.Location? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sourceBufferID = source._sourceBufferID
      _location = source._location
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._sourceBufferID)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._location)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sourceBufferID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._sourceBufferID, fieldNumber: 1)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_BufferAssignmentProto.BufferAlias) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._sourceBufferID != other_storage._sourceBufferID {return false}
        if _storage._location != other_storage._location {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloProto"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hlo_module"),
    2: .standard(proto: "hlo_ordering"),
    3: .standard(proto: "buffer_assignment"),
  ]

  fileprivate class _StorageClass {
    var _hloModule: Xla_HloModuleProto? = nil
    var _hloOrdering: Xla_HloOrderingProto? = nil
    var _bufferAssignment: Xla_BufferAssignmentProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hloModule = source._hloModule
      _hloOrdering = source._hloOrdering
      _bufferAssignment = source._bufferAssignment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._hloModule)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._hloOrdering)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._bufferAssignment)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._hloModule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._hloOrdering {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._bufferAssignment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloProto) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._hloModule != other_storage._hloModule {return false}
        if _storage._hloOrdering != other_storage._hloOrdering {return false}
        if _storage._bufferAssignment != other_storage._bufferAssignment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Xla_HloSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HloSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hlo"),
    2: .same(proto: "arguments"),
    3: .same(proto: "result"),
    4: .standard(proto: "execution_platform"),
  ]

  fileprivate class _StorageClass {
    var _hlo: Xla_HloProto? = nil
    var _arguments: [Xla_LiteralProto] = []
    var _result: Xla_LiteralProto? = nil
    var _executionPlatform: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hlo = source._hlo
      _arguments = source._arguments
      _result = source._result
      _executionPlatform = source._executionPlatform
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._hlo)
        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._arguments)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._result)
        case 4: try decoder.decodeSingularStringField(value: &_storage._executionPlatform)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._hlo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 2)
      }
      if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._executionPlatform.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executionPlatform, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public func _protobuf_generated_isEqualTo(other: Xla_HloSnapshot) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let other_storage = _args.1
        if _storage._hlo != other_storage._hlo {return false}
        if _storage._arguments != other_storage._arguments {return false}
        if _storage._result != other_storage._result {return false}
        if _storage._executionPlatform != other_storage._executionPlatform {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
